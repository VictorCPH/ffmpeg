/* automatically generated by rust-bindgen */

#![allow(warnings)]
#[link(name = "avformat")]
extern "C" {}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _TIME_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _BSD_SOURCE: u32 = 1;
pub const _SVID_SOURCE: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_BSD: u32 = 1;
pub const __USE_SVID: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201103;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 19;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCKS_PER_SEC: u32 = 1000000;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const __time_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __timespec_defined: u32 = 1;
pub const _XLOCALE_H: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const _G_config_h: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _G_HAVE_MMAP: u32 = 1;
pub const _G_HAVE_MREMAP: u32 = 1;
pub const _G_IO_IO_FILE_VERSION: u32 = 131073;
pub const _G_BUFSIZ: u32 = 8192;
pub const _IO_BUFSIZ: u32 = 8192;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _IO_UNIFIED_JUMPTABLES: u32 = 1;
pub const EOF: i32 = -1;
pub const _IOS_INPUT: u32 = 1;
pub const _IOS_OUTPUT: u32 = 2;
pub const _IOS_ATEND: u32 = 4;
pub const _IOS_APPEND: u32 = 8;
pub const _IOS_TRUNC: u32 = 16;
pub const _IOS_NOCREATE: u32 = 32;
pub const _IOS_NOREPLACE: u32 = 64;
pub const _IOS_BIN: u32 = 128;
pub const _IO_MAGIC: u32 = 4222418944;
pub const _OLD_STDIO_MAGIC: u32 = 4206624768;
pub const _IO_MAGIC_MASK: u32 = 4294901760;
pub const _IO_USER_BUF: u32 = 1;
pub const _IO_UNBUFFERED: u32 = 2;
pub const _IO_NO_READS: u32 = 4;
pub const _IO_NO_WRITES: u32 = 8;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_DELETE_DONT_CLOSE: u32 = 64;
pub const _IO_LINKED: u32 = 128;
pub const _IO_IN_BACKUP: u32 = 256;
pub const _IO_LINE_BUF: u32 = 512;
pub const _IO_TIED_PUT_GET: u32 = 1024;
pub const _IO_CURRENTLY_PUTTING: u32 = 2048;
pub const _IO_IS_APPENDING: u32 = 4096;
pub const _IO_IS_FILEBUF: u32 = 8192;
pub const _IO_BAD_SEEN: u32 = 16384;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IO_FLAGS2_MMAP: u32 = 1;
pub const _IO_FLAGS2_NOTCANCEL: u32 = 2;
pub const _IO_FLAGS2_USER_WBUF: u32 = 8;
pub const _IO_SKIPWS: u32 = 1;
pub const _IO_LEFT: u32 = 2;
pub const _IO_RIGHT: u32 = 4;
pub const _IO_INTERNAL: u32 = 8;
pub const _IO_DEC: u32 = 16;
pub const _IO_OCT: u32 = 32;
pub const _IO_HEX: u32 = 64;
pub const _IO_SHOWBASE: u32 = 128;
pub const _IO_SHOWPOINT: u32 = 256;
pub const _IO_UPPERCASE: u32 = 512;
pub const _IO_SHOWPOS: u32 = 1024;
pub const _IO_SCIENTIFIC: u32 = 2048;
pub const _IO_FIXED: u32 = 4096;
pub const _IO_UNITBUF: u32 = 8192;
pub const _IO_STDIO: u32 = 16384;
pub const _IO_DONT_CLOSE: u32 = 32768;
pub const _IO_BOOLALPHA: u32 = 65536;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const FF_LAMBDA_SHIFT: u32 = 7;
pub const FF_LAMBDA_SCALE: u32 = 128;
pub const FF_QP2LAMBDA: u32 = 118;
pub const FF_LAMBDA_MAX: u32 = 32767;
pub const FF_QUALITY_SCALE: u32 = 128;
pub const AV_TIME_BASE: u32 = 1000000;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const PRId8: &'static [u8; 2usize] = b"d\0";
pub const PRId16: &'static [u8; 2usize] = b"d\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRId64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIi8: &'static [u8; 2usize] = b"i\0";
pub const PRIi16: &'static [u8; 2usize] = b"i\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIi64: &'static [u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST16: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST32: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIo8: &'static [u8; 2usize] = b"o\0";
pub const PRIo16: &'static [u8; 2usize] = b"o\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIo64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIu8: &'static [u8; 2usize] = b"u\0";
pub const PRIu16: &'static [u8; 2usize] = b"u\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIu64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIx8: &'static [u8; 2usize] = b"x\0";
pub const PRIx16: &'static [u8; 2usize] = b"x\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIx64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIX8: &'static [u8; 2usize] = b"X\0";
pub const PRIX16: &'static [u8; 2usize] = b"X\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRIX64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST16: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIdMAX: &'static [u8; 3usize] = b"ld\0";
pub const PRIiMAX: &'static [u8; 3usize] = b"li\0";
pub const PRIoMAX: &'static [u8; 3usize] = b"lo\0";
pub const PRIuMAX: &'static [u8; 3usize] = b"lu\0";
pub const PRIxMAX: &'static [u8; 3usize] = b"lx\0";
pub const PRIXMAX: &'static [u8; 3usize] = b"lX\0";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\0";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\0";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\0";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\0";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNd64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNi64: &'static [u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST32: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNu64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNo64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNx64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNdMAX: &'static [u8; 3usize] = b"ld\0";
pub const SCNiMAX: &'static [u8; 3usize] = b"li\0";
pub const SCNoMAX: &'static [u8; 3usize] = b"lo\0";
pub const SCNuMAX: &'static [u8; 3usize] = b"lu\0";
pub const SCNxMAX: &'static [u8; 3usize] = b"lx\0";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\0";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\0";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\0";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\0";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\0";
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _MATH_H: u32 = 1;
pub const _MATH_H_MATHDEF: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const FP_NAN: u32 = 0;
pub const FP_INFINITE: u32 = 1;
pub const FP_ZERO: u32 = 2;
pub const FP_SUBNORMAL: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const _SIGSET_H_types: u32 = 1;
pub const _STRUCT_TIMEVAL: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _SYS_SYSMACROS_H: u32 = 1;
pub const _BITS_PTHREADTYPES_H: u32 = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __have_pthread_attr_t: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_ELISION: u32 = 1;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const LIBAVUTIL_VERSION_MAJOR: u32 = 55;
pub const LIBAVUTIL_VERSION_MINOR: u32 = 34;
pub const LIBAVUTIL_VERSION_MICRO: u32 = 101;
pub const AV_HAVE_BIGENDIAN: u32 = 0;
pub const AV_HAVE_FAST_UNALIGNED: u32 = 1;
pub const AVERROR_EXPERIMENTAL: i32 = -733130664;
pub const AVERROR_INPUT_CHANGED: i32 = -1668179713;
pub const AVERROR_OUTPUT_CHANGED: i32 = -1668179714;
pub const AV_ERROR_MAX_STRING_SIZE: u32 = 64;
pub const M_LOG2_10: f64 = 3.321928094887362;
pub const M_PHI: f64 = 1.618033988749895;
pub const AV_LOG_QUIET: i32 = -8;
pub const AV_LOG_PANIC: u32 = 0;
pub const AV_LOG_FATAL: u32 = 8;
pub const AV_LOG_ERROR: u32 = 16;
pub const AV_LOG_WARNING: u32 = 24;
pub const AV_LOG_INFO: u32 = 32;
pub const AV_LOG_VERBOSE: u32 = 40;
pub const AV_LOG_DEBUG: u32 = 48;
pub const AV_LOG_TRACE: u32 = 56;
pub const AV_LOG_MAX_OFFSET: u32 = 64;
pub const AV_LOG_SKIP_REPEATED: u32 = 1;
pub const AV_LOG_PRINT_LEVEL: u32 = 2;
pub const AVPALETTE_SIZE: u32 = 1024;
pub const AVPALETTE_COUNT: u32 = 256;
pub const AV_BUFFER_FLAG_READONLY: u32 = 1;
pub const AV_CPU_FLAG_FORCE: u32 = 2147483648;
pub const AV_CPU_FLAG_MMX: u32 = 1;
pub const AV_CPU_FLAG_MMXEXT: u32 = 2;
pub const AV_CPU_FLAG_MMX2: u32 = 2;
pub const AV_CPU_FLAG_3DNOW: u32 = 4;
pub const AV_CPU_FLAG_SSE: u32 = 8;
pub const AV_CPU_FLAG_SSE2: u32 = 16;
pub const AV_CPU_FLAG_SSE2SLOW: u32 = 1073741824;
pub const AV_CPU_FLAG_3DNOWEXT: u32 = 32;
pub const AV_CPU_FLAG_SSE3: u32 = 64;
pub const AV_CPU_FLAG_SSE3SLOW: u32 = 536870912;
pub const AV_CPU_FLAG_SSSE3: u32 = 128;
pub const AV_CPU_FLAG_ATOM: u32 = 268435456;
pub const AV_CPU_FLAG_SSE4: u32 = 256;
pub const AV_CPU_FLAG_SSE42: u32 = 512;
pub const AV_CPU_FLAG_AESNI: u32 = 524288;
pub const AV_CPU_FLAG_AVX: u32 = 16384;
pub const AV_CPU_FLAG_AVXSLOW: u32 = 134217728;
pub const AV_CPU_FLAG_XOP: u32 = 1024;
pub const AV_CPU_FLAG_FMA4: u32 = 2048;
pub const AV_CPU_FLAG_CMOV: u32 = 4096;
pub const AV_CPU_FLAG_AVX2: u32 = 32768;
pub const AV_CPU_FLAG_FMA3: u32 = 65536;
pub const AV_CPU_FLAG_BMI1: u32 = 131072;
pub const AV_CPU_FLAG_BMI2: u32 = 262144;
pub const AV_CPU_FLAG_ALTIVEC: u32 = 1;
pub const AV_CPU_FLAG_VSX: u32 = 2;
pub const AV_CPU_FLAG_POWER8: u32 = 4;
pub const AV_CPU_FLAG_ARMV5TE: u32 = 1;
pub const AV_CPU_FLAG_ARMV6: u32 = 2;
pub const AV_CPU_FLAG_ARMV6T2: u32 = 4;
pub const AV_CPU_FLAG_VFP: u32 = 8;
pub const AV_CPU_FLAG_VFPV3: u32 = 16;
pub const AV_CPU_FLAG_NEON: u32 = 32;
pub const AV_CPU_FLAG_ARMV8: u32 = 64;
pub const AV_CPU_FLAG_VFP_VM: u32 = 128;
pub const AV_CPU_FLAG_SETEND: u32 = 65536;
pub const AV_CH_FRONT_LEFT: u32 = 1;
pub const AV_CH_FRONT_RIGHT: u32 = 2;
pub const AV_CH_FRONT_CENTER: u32 = 4;
pub const AV_CH_LOW_FREQUENCY: u32 = 8;
pub const AV_CH_BACK_LEFT: u32 = 16;
pub const AV_CH_BACK_RIGHT: u32 = 32;
pub const AV_CH_FRONT_LEFT_OF_CENTER: u32 = 64;
pub const AV_CH_FRONT_RIGHT_OF_CENTER: u32 = 128;
pub const AV_CH_BACK_CENTER: u32 = 256;
pub const AV_CH_SIDE_LEFT: u32 = 512;
pub const AV_CH_SIDE_RIGHT: u32 = 1024;
pub const AV_CH_TOP_CENTER: u32 = 2048;
pub const AV_CH_TOP_FRONT_LEFT: u32 = 4096;
pub const AV_CH_TOP_FRONT_CENTER: u32 = 8192;
pub const AV_CH_TOP_FRONT_RIGHT: u32 = 16384;
pub const AV_CH_TOP_BACK_LEFT: u32 = 32768;
pub const AV_CH_TOP_BACK_CENTER: u32 = 65536;
pub const AV_CH_TOP_BACK_RIGHT: u32 = 131072;
pub const AV_CH_STEREO_LEFT: u32 = 536870912;
pub const AV_CH_STEREO_RIGHT: u32 = 1073741824;
pub const AV_CH_WIDE_LEFT: u32 = 2147483648;
pub const AV_CH_WIDE_RIGHT: u64 = 4294967296;
pub const AV_CH_SURROUND_DIRECT_LEFT: u64 = 8589934592;
pub const AV_CH_SURROUND_DIRECT_RIGHT: u64 = 17179869184;
pub const AV_CH_LOW_FREQUENCY_2: u64 = 34359738368;
pub const AV_CH_LAYOUT_NATIVE: i64 = -9223372036854775808;
pub const AV_CH_LAYOUT_MONO: u32 = 4;
pub const AV_CH_LAYOUT_STEREO: u32 = 3;
pub const AV_CH_LAYOUT_2POINT1: u32 = 11;
pub const AV_CH_LAYOUT_2_1: u32 = 259;
pub const AV_CH_LAYOUT_SURROUND: u32 = 7;
pub const AV_CH_LAYOUT_3POINT1: u32 = 15;
pub const AV_CH_LAYOUT_4POINT0: u32 = 263;
pub const AV_CH_LAYOUT_4POINT1: u32 = 271;
pub const AV_CH_LAYOUT_2_2: u32 = 1539;
pub const AV_CH_LAYOUT_QUAD: u32 = 51;
pub const AV_CH_LAYOUT_5POINT0: u32 = 1543;
pub const AV_CH_LAYOUT_5POINT1: u32 = 1551;
pub const AV_CH_LAYOUT_5POINT0_BACK: u32 = 55;
pub const AV_CH_LAYOUT_5POINT1_BACK: u32 = 63;
pub const AV_CH_LAYOUT_6POINT0: u32 = 1799;
pub const AV_CH_LAYOUT_6POINT0_FRONT: u32 = 1731;
pub const AV_CH_LAYOUT_HEXAGONAL: u32 = 311;
pub const AV_CH_LAYOUT_6POINT1: u32 = 1807;
pub const AV_CH_LAYOUT_6POINT1_BACK: u32 = 319;
pub const AV_CH_LAYOUT_6POINT1_FRONT: u32 = 1739;
pub const AV_CH_LAYOUT_7POINT0: u32 = 1591;
pub const AV_CH_LAYOUT_7POINT0_FRONT: u32 = 1735;
pub const AV_CH_LAYOUT_7POINT1: u32 = 1599;
pub const AV_CH_LAYOUT_7POINT1_WIDE: u32 = 1743;
pub const AV_CH_LAYOUT_7POINT1_WIDE_BACK: u32 = 255;
pub const AV_CH_LAYOUT_OCTAGONAL: u32 = 1847;
pub const AV_CH_LAYOUT_HEXADECAGONAL: u64 = 6442710839;
pub const AV_CH_LAYOUT_STEREO_DOWNMIX: u32 = 1610612736;
pub const AV_DICT_MATCH_CASE: u32 = 1;
pub const AV_DICT_IGNORE_SUFFIX: u32 = 2;
pub const AV_DICT_DONT_STRDUP_KEY: u32 = 4;
pub const AV_DICT_DONT_STRDUP_VAL: u32 = 8;
pub const AV_DICT_DONT_OVERWRITE: u32 = 16;
pub const AV_DICT_APPEND: u32 = 32;
pub const AV_DICT_MULTIKEY: u32 = 64;
pub const AV_NUM_DATA_POINTERS: u32 = 8;
pub const AV_FRAME_FLAG_CORRUPT: u32 = 1;
pub const AV_FRAME_FLAG_DISCARD: u32 = 4;
pub const FF_DECODE_ERROR_INVALID_BITSTREAM: u32 = 1;
pub const FF_DECODE_ERROR_MISSING_REFERENCE: u32 = 2;
pub const LIBAVCODEC_VERSION_MAJOR: u32 = 57;
pub const LIBAVCODEC_VERSION_MINOR: u32 = 64;
pub const LIBAVCODEC_VERSION_MICRO: u32 = 101;
pub const AV_CODEC_PROP_INTRA_ONLY: u32 = 1;
pub const AV_CODEC_PROP_LOSSY: u32 = 2;
pub const AV_CODEC_PROP_LOSSLESS: u32 = 4;
pub const AV_CODEC_PROP_REORDER: u32 = 8;
pub const AV_CODEC_PROP_BITMAP_SUB: u32 = 65536;
pub const AV_CODEC_PROP_TEXT_SUB: u32 = 131072;
pub const AV_INPUT_BUFFER_PADDING_SIZE: u32 = 32;
pub const AV_INPUT_BUFFER_MIN_SIZE: u32 = 16384;
pub const FF_INPUT_BUFFER_PADDING_SIZE: u32 = 32;
pub const FF_MIN_BUFFER_SIZE: u32 = 16384;
pub const FF_MAX_B_FRAMES: u32 = 16;
pub const AV_CODEC_FLAG_UNALIGNED: u32 = 1;
pub const AV_CODEC_FLAG_QSCALE: u32 = 2;
pub const AV_CODEC_FLAG_4MV: u32 = 4;
pub const AV_CODEC_FLAG_OUTPUT_CORRUPT: u32 = 8;
pub const AV_CODEC_FLAG_QPEL: u32 = 16;
pub const AV_CODEC_FLAG_PASS1: u32 = 512;
pub const AV_CODEC_FLAG_PASS2: u32 = 1024;
pub const AV_CODEC_FLAG_LOOP_FILTER: u32 = 2048;
pub const AV_CODEC_FLAG_GRAY: u32 = 8192;
pub const AV_CODEC_FLAG_PSNR: u32 = 32768;
pub const AV_CODEC_FLAG_TRUNCATED: u32 = 65536;
pub const AV_CODEC_FLAG_INTERLACED_DCT: u32 = 262144;
pub const AV_CODEC_FLAG_LOW_DELAY: u32 = 524288;
pub const AV_CODEC_FLAG_GLOBAL_HEADER: u32 = 4194304;
pub const AV_CODEC_FLAG_BITEXACT: u32 = 8388608;
pub const AV_CODEC_FLAG_AC_PRED: u32 = 16777216;
pub const AV_CODEC_FLAG_INTERLACED_ME: u32 = 536870912;
pub const AV_CODEC_FLAG_CLOSED_GOP: u32 = 2147483648;
pub const AV_CODEC_FLAG2_FAST: u32 = 1;
pub const AV_CODEC_FLAG2_NO_OUTPUT: u32 = 4;
pub const AV_CODEC_FLAG2_LOCAL_HEADER: u32 = 8;
pub const AV_CODEC_FLAG2_DROP_FRAME_TIMECODE: u32 = 8192;
pub const AV_CODEC_FLAG2_CHUNKS: u32 = 32768;
pub const AV_CODEC_FLAG2_IGNORE_CROP: u32 = 65536;
pub const AV_CODEC_FLAG2_SHOW_ALL: u32 = 4194304;
pub const AV_CODEC_FLAG2_EXPORT_MVS: u32 = 268435456;
pub const AV_CODEC_FLAG2_SKIP_MANUAL: u32 = 536870912;
pub const AV_CODEC_FLAG2_RO_FLUSH_NOOP: u32 = 1073741824;
pub const AV_CODEC_CAP_DRAW_HORIZ_BAND: u32 = 1;
pub const AV_CODEC_CAP_DR1: u32 = 2;
pub const AV_CODEC_CAP_TRUNCATED: u32 = 8;
pub const AV_CODEC_CAP_DELAY: u32 = 32;
pub const AV_CODEC_CAP_SMALL_LAST_FRAME: u32 = 64;
pub const AV_CODEC_CAP_HWACCEL_VDPAU: u32 = 128;
pub const AV_CODEC_CAP_SUBFRAMES: u32 = 256;
pub const AV_CODEC_CAP_EXPERIMENTAL: u32 = 512;
pub const AV_CODEC_CAP_CHANNEL_CONF: u32 = 1024;
pub const AV_CODEC_CAP_FRAME_THREADS: u32 = 4096;
pub const AV_CODEC_CAP_SLICE_THREADS: u32 = 8192;
pub const AV_CODEC_CAP_PARAM_CHANGE: u32 = 16384;
pub const AV_CODEC_CAP_AUTO_THREADS: u32 = 32768;
pub const AV_CODEC_CAP_VARIABLE_FRAME_SIZE: u32 = 65536;
pub const AV_CODEC_CAP_AVOID_PROBING: u32 = 131072;
pub const AV_CODEC_CAP_INTRA_ONLY: u32 = 1073741824;
pub const AV_CODEC_CAP_LOSSLESS: u32 = 2147483648;
pub const CODEC_FLAG_UNALIGNED: u32 = 1;
pub const CODEC_FLAG_QSCALE: u32 = 2;
pub const CODEC_FLAG_4MV: u32 = 4;
pub const CODEC_FLAG_OUTPUT_CORRUPT: u32 = 8;
pub const CODEC_FLAG_QPEL: u32 = 16;
pub const CODEC_FLAG_GMC: u32 = 32;
pub const CODEC_FLAG_MV0: u32 = 64;
pub const CODEC_FLAG_INPUT_PRESERVED: u32 = 256;
pub const CODEC_FLAG_PASS1: u32 = 512;
pub const CODEC_FLAG_PASS2: u32 = 1024;
pub const CODEC_FLAG_GRAY: u32 = 8192;
pub const CODEC_FLAG_EMU_EDGE: u32 = 16384;
pub const CODEC_FLAG_PSNR: u32 = 32768;
pub const CODEC_FLAG_TRUNCATED: u32 = 65536;
pub const CODEC_FLAG_NORMALIZE_AQP: u32 = 131072;
pub const CODEC_FLAG_INTERLACED_DCT: u32 = 262144;
pub const CODEC_FLAG_LOW_DELAY: u32 = 524288;
pub const CODEC_FLAG_GLOBAL_HEADER: u32 = 4194304;
pub const CODEC_FLAG_BITEXACT: u32 = 8388608;
pub const CODEC_FLAG_AC_PRED: u32 = 16777216;
pub const CODEC_FLAG_LOOP_FILTER: u32 = 2048;
pub const CODEC_FLAG_INTERLACED_ME: u32 = 536870912;
pub const CODEC_FLAG_CLOSED_GOP: u32 = 2147483648;
pub const CODEC_FLAG2_FAST: u32 = 1;
pub const CODEC_FLAG2_NO_OUTPUT: u32 = 4;
pub const CODEC_FLAG2_LOCAL_HEADER: u32 = 8;
pub const CODEC_FLAG2_DROP_FRAME_TIMECODE: u32 = 8192;
pub const CODEC_FLAG2_IGNORE_CROP: u32 = 65536;
pub const CODEC_FLAG2_CHUNKS: u32 = 32768;
pub const CODEC_FLAG2_SHOW_ALL: u32 = 4194304;
pub const CODEC_FLAG2_EXPORT_MVS: u32 = 268435456;
pub const CODEC_FLAG2_SKIP_MANUAL: u32 = 536870912;
pub const CODEC_CAP_DRAW_HORIZ_BAND: u32 = 1;
pub const CODEC_CAP_DR1: u32 = 2;
pub const CODEC_CAP_TRUNCATED: u32 = 8;
pub const CODEC_CAP_HWACCEL: u32 = 16;
pub const CODEC_CAP_DELAY: u32 = 32;
pub const CODEC_CAP_SMALL_LAST_FRAME: u32 = 64;
pub const CODEC_CAP_HWACCEL_VDPAU: u32 = 128;
pub const CODEC_CAP_SUBFRAMES: u32 = 256;
pub const CODEC_CAP_EXPERIMENTAL: u32 = 512;
pub const CODEC_CAP_CHANNEL_CONF: u32 = 1024;
pub const CODEC_CAP_NEG_LINESIZES: u32 = 2048;
pub const CODEC_CAP_FRAME_THREADS: u32 = 4096;
pub const CODEC_CAP_SLICE_THREADS: u32 = 8192;
pub const CODEC_CAP_PARAM_CHANGE: u32 = 16384;
pub const CODEC_CAP_AUTO_THREADS: u32 = 32768;
pub const CODEC_CAP_VARIABLE_FRAME_SIZE: u32 = 65536;
pub const CODEC_CAP_INTRA_ONLY: u32 = 1073741824;
pub const CODEC_CAP_LOSSLESS: u32 = 2147483648;
pub const HWACCEL_CODEC_CAP_EXPERIMENTAL: u32 = 512;
pub const MB_TYPE_INTRA4x4: u32 = 1;
pub const MB_TYPE_INTRA16x16: u32 = 2;
pub const MB_TYPE_INTRA_PCM: u32 = 4;
pub const MB_TYPE_16x16: u32 = 8;
pub const MB_TYPE_16x8: u32 = 16;
pub const MB_TYPE_8x16: u32 = 32;
pub const MB_TYPE_8x8: u32 = 64;
pub const MB_TYPE_INTERLACED: u32 = 128;
pub const MB_TYPE_DIRECT2: u32 = 256;
pub const MB_TYPE_ACPRED: u32 = 512;
pub const MB_TYPE_GMC: u32 = 1024;
pub const MB_TYPE_SKIP: u32 = 2048;
pub const MB_TYPE_P0L0: u32 = 4096;
pub const MB_TYPE_P1L0: u32 = 8192;
pub const MB_TYPE_P0L1: u32 = 16384;
pub const MB_TYPE_P1L1: u32 = 32768;
pub const MB_TYPE_L0: u32 = 12288;
pub const MB_TYPE_L1: u32 = 49152;
pub const MB_TYPE_L0L1: u32 = 61440;
pub const MB_TYPE_QUANT: u32 = 65536;
pub const MB_TYPE_CBP: u32 = 131072;
pub const FF_QSCALE_TYPE_MPEG1: u32 = 0;
pub const FF_QSCALE_TYPE_MPEG2: u32 = 1;
pub const FF_QSCALE_TYPE_H264: u32 = 2;
pub const FF_QSCALE_TYPE_VP56: u32 = 3;
pub const AV_GET_BUFFER_FLAG_REF: u32 = 1;
pub const AV_PKT_FLAG_KEY: u32 = 1;
pub const AV_PKT_FLAG_CORRUPT: u32 = 2;
pub const AV_PKT_FLAG_DISCARD: u32 = 4;
pub const FF_COMPRESSION_DEFAULT: i32 = -1;
pub const FF_ASPECT_EXTENDED: u32 = 15;
pub const FF_RC_STRATEGY_XVID: u32 = 1;
pub const FF_PRED_LEFT: u32 = 0;
pub const FF_PRED_PLANE: u32 = 1;
pub const FF_PRED_MEDIAN: u32 = 2;
pub const FF_CMP_SAD: u32 = 0;
pub const FF_CMP_SSE: u32 = 1;
pub const FF_CMP_SATD: u32 = 2;
pub const FF_CMP_DCT: u32 = 3;
pub const FF_CMP_PSNR: u32 = 4;
pub const FF_CMP_BIT: u32 = 5;
pub const FF_CMP_RD: u32 = 6;
pub const FF_CMP_ZERO: u32 = 7;
pub const FF_CMP_VSAD: u32 = 8;
pub const FF_CMP_VSSE: u32 = 9;
pub const FF_CMP_NSSE: u32 = 10;
pub const FF_CMP_W53: u32 = 11;
pub const FF_CMP_W97: u32 = 12;
pub const FF_CMP_DCTMAX: u32 = 13;
pub const FF_CMP_DCT264: u32 = 14;
pub const FF_CMP_MEDIAN_SAD: u32 = 15;
pub const FF_CMP_CHROMA: u32 = 256;
pub const FF_DTG_AFD_SAME: u32 = 8;
pub const FF_DTG_AFD_4_3: u32 = 9;
pub const FF_DTG_AFD_16_9: u32 = 10;
pub const FF_DTG_AFD_14_9: u32 = 11;
pub const FF_DTG_AFD_4_3_SP_14_9: u32 = 13;
pub const FF_DTG_AFD_16_9_SP_14_9: u32 = 14;
pub const FF_DTG_AFD_SP_4_3: u32 = 15;
pub const FF_DEFAULT_QUANT_BIAS: u32 = 999999;
pub const SLICE_FLAG_CODED_ORDER: u32 = 1;
pub const SLICE_FLAG_ALLOW_FIELD: u32 = 2;
pub const SLICE_FLAG_ALLOW_PLANE: u32 = 4;
pub const FF_MB_DECISION_SIMPLE: u32 = 0;
pub const FF_MB_DECISION_BITS: u32 = 1;
pub const FF_MB_DECISION_RD: u32 = 2;
pub const FF_CODER_TYPE_VLC: u32 = 0;
pub const FF_CODER_TYPE_AC: u32 = 1;
pub const FF_CODER_TYPE_RAW: u32 = 2;
pub const FF_CODER_TYPE_RLE: u32 = 3;
pub const FF_CODER_TYPE_DEFLATE: u32 = 4;
pub const FF_BUG_AUTODETECT: u32 = 1;
pub const FF_BUG_OLD_MSMPEG4: u32 = 2;
pub const FF_BUG_XVID_ILACE: u32 = 4;
pub const FF_BUG_UMP4: u32 = 8;
pub const FF_BUG_NO_PADDING: u32 = 16;
pub const FF_BUG_AMV: u32 = 32;
pub const FF_BUG_AC_VLC: u32 = 0;
pub const FF_BUG_QPEL_CHROMA: u32 = 64;
pub const FF_BUG_STD_QPEL: u32 = 128;
pub const FF_BUG_QPEL_CHROMA2: u32 = 256;
pub const FF_BUG_DIRECT_BLOCKSIZE: u32 = 512;
pub const FF_BUG_EDGE: u32 = 1024;
pub const FF_BUG_HPEL_CHROMA: u32 = 2048;
pub const FF_BUG_DC_CLIP: u32 = 4096;
pub const FF_BUG_MS: u32 = 8192;
pub const FF_BUG_TRUNCATED: u32 = 16384;
pub const FF_BUG_IEDGE: u32 = 32768;
pub const FF_COMPLIANCE_VERY_STRICT: u32 = 2;
pub const FF_COMPLIANCE_STRICT: u32 = 1;
pub const FF_COMPLIANCE_NORMAL: u32 = 0;
pub const FF_COMPLIANCE_UNOFFICIAL: i32 = -1;
pub const FF_COMPLIANCE_EXPERIMENTAL: i32 = -2;
pub const FF_EC_GUESS_MVS: u32 = 1;
pub const FF_EC_DEBLOCK: u32 = 2;
pub const FF_EC_FAVOR_INTER: u32 = 256;
pub const FF_DEBUG_PICT_INFO: u32 = 1;
pub const FF_DEBUG_RC: u32 = 2;
pub const FF_DEBUG_BITSTREAM: u32 = 4;
pub const FF_DEBUG_MB_TYPE: u32 = 8;
pub const FF_DEBUG_QP: u32 = 16;
pub const FF_DEBUG_MV: u32 = 32;
pub const FF_DEBUG_DCT_COEFF: u32 = 64;
pub const FF_DEBUG_SKIP: u32 = 128;
pub const FF_DEBUG_STARTCODE: u32 = 256;
pub const FF_DEBUG_PTS: u32 = 512;
pub const FF_DEBUG_ER: u32 = 1024;
pub const FF_DEBUG_MMCO: u32 = 2048;
pub const FF_DEBUG_BUGS: u32 = 4096;
pub const FF_DEBUG_VIS_QP: u32 = 8192;
pub const FF_DEBUG_VIS_MB_TYPE: u32 = 16384;
pub const FF_DEBUG_BUFFERS: u32 = 32768;
pub const FF_DEBUG_THREADS: u32 = 65536;
pub const FF_DEBUG_GREEN_MD: u32 = 8388608;
pub const FF_DEBUG_NOMC: u32 = 16777216;
pub const FF_DEBUG_VIS_MV_P_FOR: u32 = 1;
pub const FF_DEBUG_VIS_MV_B_FOR: u32 = 2;
pub const FF_DEBUG_VIS_MV_B_BACK: u32 = 4;
pub const AV_EF_CRCCHECK: u32 = 1;
pub const AV_EF_BITSTREAM: u32 = 2;
pub const AV_EF_BUFFER: u32 = 4;
pub const AV_EF_EXPLODE: u32 = 8;
pub const AV_EF_IGNORE_ERR: u32 = 32768;
pub const AV_EF_CAREFUL: u32 = 65536;
pub const AV_EF_COMPLIANT: u32 = 131072;
pub const AV_EF_AGGRESSIVE: u32 = 262144;
pub const FF_DCT_AUTO: u32 = 0;
pub const FF_DCT_FASTINT: u32 = 1;
pub const FF_DCT_INT: u32 = 2;
pub const FF_DCT_MMX: u32 = 3;
pub const FF_DCT_ALTIVEC: u32 = 5;
pub const FF_DCT_FAAN: u32 = 6;
pub const FF_IDCT_AUTO: u32 = 0;
pub const FF_IDCT_INT: u32 = 1;
pub const FF_IDCT_SIMPLE: u32 = 2;
pub const FF_IDCT_SIMPLEMMX: u32 = 3;
pub const FF_IDCT_ARM: u32 = 7;
pub const FF_IDCT_ALTIVEC: u32 = 8;
pub const FF_IDCT_SH4: u32 = 9;
pub const FF_IDCT_SIMPLEARM: u32 = 10;
pub const FF_IDCT_IPP: u32 = 13;
pub const FF_IDCT_XVID: u32 = 14;
pub const FF_IDCT_XVIDMMX: u32 = 14;
pub const FF_IDCT_SIMPLEARMV5TE: u32 = 16;
pub const FF_IDCT_SIMPLEARMV6: u32 = 17;
pub const FF_IDCT_SIMPLEVIS: u32 = 18;
pub const FF_IDCT_FAAN: u32 = 20;
pub const FF_IDCT_SIMPLENEON: u32 = 22;
pub const FF_IDCT_SIMPLEALPHA: u32 = 23;
pub const FF_IDCT_SIMPLEAUTO: u32 = 128;
pub const FF_THREAD_FRAME: u32 = 1;
pub const FF_THREAD_SLICE: u32 = 2;
pub const FF_PROFILE_UNKNOWN: i32 = -99;
pub const FF_PROFILE_RESERVED: i32 = -100;
pub const FF_PROFILE_AAC_MAIN: u32 = 0;
pub const FF_PROFILE_AAC_LOW: u32 = 1;
pub const FF_PROFILE_AAC_SSR: u32 = 2;
pub const FF_PROFILE_AAC_LTP: u32 = 3;
pub const FF_PROFILE_AAC_HE: u32 = 4;
pub const FF_PROFILE_AAC_HE_V2: u32 = 28;
pub const FF_PROFILE_AAC_LD: u32 = 22;
pub const FF_PROFILE_AAC_ELD: u32 = 38;
pub const FF_PROFILE_MPEG2_AAC_LOW: u32 = 128;
pub const FF_PROFILE_MPEG2_AAC_HE: u32 = 131;
pub const FF_PROFILE_DNXHD: u32 = 0;
pub const FF_PROFILE_DNXHR_LB: u32 = 1;
pub const FF_PROFILE_DNXHR_SQ: u32 = 2;
pub const FF_PROFILE_DNXHR_HQ: u32 = 3;
pub const FF_PROFILE_DNXHR_HQX: u32 = 4;
pub const FF_PROFILE_DNXHR_444: u32 = 5;
pub const FF_PROFILE_DTS: u32 = 20;
pub const FF_PROFILE_DTS_ES: u32 = 30;
pub const FF_PROFILE_DTS_96_24: u32 = 40;
pub const FF_PROFILE_DTS_HD_HRA: u32 = 50;
pub const FF_PROFILE_DTS_HD_MA: u32 = 60;
pub const FF_PROFILE_DTS_EXPRESS: u32 = 70;
pub const FF_PROFILE_MPEG2_422: u32 = 0;
pub const FF_PROFILE_MPEG2_HIGH: u32 = 1;
pub const FF_PROFILE_MPEG2_SS: u32 = 2;
pub const FF_PROFILE_MPEG2_SNR_SCALABLE: u32 = 3;
pub const FF_PROFILE_MPEG2_MAIN: u32 = 4;
pub const FF_PROFILE_MPEG2_SIMPLE: u32 = 5;
pub const FF_PROFILE_H264_CONSTRAINED: u32 = 512;
pub const FF_PROFILE_H264_INTRA: u32 = 2048;
pub const FF_PROFILE_H264_BASELINE: u32 = 66;
pub const FF_PROFILE_H264_CONSTRAINED_BASELINE: u32 = 578;
pub const FF_PROFILE_H264_MAIN: u32 = 77;
pub const FF_PROFILE_H264_EXTENDED: u32 = 88;
pub const FF_PROFILE_H264_HIGH: u32 = 100;
pub const FF_PROFILE_H264_HIGH_10: u32 = 110;
pub const FF_PROFILE_H264_HIGH_10_INTRA: u32 = 2158;
pub const FF_PROFILE_H264_MULTIVIEW_HIGH: u32 = 118;
pub const FF_PROFILE_H264_HIGH_422: u32 = 122;
pub const FF_PROFILE_H264_HIGH_422_INTRA: u32 = 2170;
pub const FF_PROFILE_H264_STEREO_HIGH: u32 = 128;
pub const FF_PROFILE_H264_HIGH_444: u32 = 144;
pub const FF_PROFILE_H264_HIGH_444_PREDICTIVE: u32 = 244;
pub const FF_PROFILE_H264_HIGH_444_INTRA: u32 = 2292;
pub const FF_PROFILE_H264_CAVLC_444: u32 = 44;
pub const FF_PROFILE_VC1_SIMPLE: u32 = 0;
pub const FF_PROFILE_VC1_MAIN: u32 = 1;
pub const FF_PROFILE_VC1_COMPLEX: u32 = 2;
pub const FF_PROFILE_VC1_ADVANCED: u32 = 3;
pub const FF_PROFILE_MPEG4_SIMPLE: u32 = 0;
pub const FF_PROFILE_MPEG4_SIMPLE_SCALABLE: u32 = 1;
pub const FF_PROFILE_MPEG4_CORE: u32 = 2;
pub const FF_PROFILE_MPEG4_MAIN: u32 = 3;
pub const FF_PROFILE_MPEG4_N_BIT: u32 = 4;
pub const FF_PROFILE_MPEG4_SCALABLE_TEXTURE: u32 = 5;
pub const FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION: u32 = 6;
pub const FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE: u32 = 7;
pub const FF_PROFILE_MPEG4_HYBRID: u32 = 8;
pub const FF_PROFILE_MPEG4_ADVANCED_REAL_TIME: u32 = 9;
pub const FF_PROFILE_MPEG4_CORE_SCALABLE: u32 = 10;
pub const FF_PROFILE_MPEG4_ADVANCED_CODING: u32 = 11;
pub const FF_PROFILE_MPEG4_ADVANCED_CORE: u32 = 12;
pub const FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE: u32 = 13;
pub const FF_PROFILE_MPEG4_SIMPLE_STUDIO: u32 = 14;
pub const FF_PROFILE_MPEG4_ADVANCED_SIMPLE: u32 = 15;
pub const FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0: u32 = 1;
pub const FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1: u32 = 2;
pub const FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION: u32 = 32768;
pub const FF_PROFILE_JPEG2000_DCINEMA_2K: u32 = 3;
pub const FF_PROFILE_JPEG2000_DCINEMA_4K: u32 = 4;
pub const FF_PROFILE_VP9_0: u32 = 0;
pub const FF_PROFILE_VP9_1: u32 = 1;
pub const FF_PROFILE_VP9_2: u32 = 2;
pub const FF_PROFILE_VP9_3: u32 = 3;
pub const FF_PROFILE_HEVC_MAIN: u32 = 1;
pub const FF_PROFILE_HEVC_MAIN_10: u32 = 2;
pub const FF_PROFILE_HEVC_MAIN_STILL_PICTURE: u32 = 3;
pub const FF_PROFILE_HEVC_REXT: u32 = 4;
pub const FF_LEVEL_UNKNOWN: i32 = -99;
pub const FF_SUB_CHARENC_MODE_DO_NOTHING: i32 = -1;
pub const FF_SUB_CHARENC_MODE_AUTOMATIC: u32 = 0;
pub const FF_SUB_CHARENC_MODE_PRE_DECODER: u32 = 1;
pub const FF_CODEC_PROPERTY_LOSSLESS: u32 = 1;
pub const FF_CODEC_PROPERTY_CLOSED_CAPTIONS: u32 = 2;
pub const FF_SUB_TEXT_FMT_ASS: u32 = 0;
pub const FF_SUB_TEXT_FMT_ASS_WITH_TIMINGS: u32 = 1;
pub const AV_HWACCEL_FLAG_IGNORE_LEVEL: u32 = 1;
pub const AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH: u32 = 2;
pub const AV_SUBTITLE_FLAG_FORCED: u32 = 1;
pub const AV_PARSER_PTS_NB: u32 = 4;
pub const PARSER_FLAG_COMPLETE_FRAMES: u32 = 1;
pub const PARSER_FLAG_ONCE: u32 = 2;
pub const PARSER_FLAG_FETCHED_OFFSET: u32 = 4;
pub const PARSER_FLAG_USE_CODEC_TS: u32 = 4096;
pub const LIBAVFORMAT_VERSION_MAJOR: u32 = 57;
pub const LIBAVFORMAT_VERSION_MINOR: u32 = 56;
pub const LIBAVFORMAT_VERSION_MICRO: u32 = 101;
pub const FF_API_R_FRAME_RATE: u32 = 1;
pub const AVIO_SEEKABLE_NORMAL: u32 = 1;
pub const AVIO_SEEKABLE_TIME: u32 = 2;
pub const AVSEEK_SIZE: u32 = 65536;
pub const AVSEEK_FORCE: u32 = 131072;
pub const AVIO_FLAG_READ: u32 = 1;
pub const AVIO_FLAG_WRITE: u32 = 2;
pub const AVIO_FLAG_READ_WRITE: u32 = 3;
pub const AVIO_FLAG_NONBLOCK: u32 = 8;
pub const AVIO_FLAG_DIRECT: u32 = 32768;
pub const AVPROBE_SCORE_EXTENSION: u32 = 50;
pub const AVPROBE_SCORE_MIME: u32 = 75;
pub const AVPROBE_SCORE_MAX: u32 = 100;
pub const AVPROBE_PADDING_SIZE: u32 = 32;
pub const AVFMT_NOFILE: u32 = 1;
pub const AVFMT_NEEDNUMBER: u32 = 2;
pub const AVFMT_SHOW_IDS: u32 = 8;
pub const AVFMT_RAWPICTURE: u32 = 32;
pub const AVFMT_GLOBALHEADER: u32 = 64;
pub const AVFMT_NOTIMESTAMPS: u32 = 128;
pub const AVFMT_GENERIC_INDEX: u32 = 256;
pub const AVFMT_TS_DISCONT: u32 = 512;
pub const AVFMT_VARIABLE_FPS: u32 = 1024;
pub const AVFMT_NODIMENSIONS: u32 = 2048;
pub const AVFMT_NOSTREAMS: u32 = 4096;
pub const AVFMT_NOBINSEARCH: u32 = 8192;
pub const AVFMT_NOGENSEARCH: u32 = 16384;
pub const AVFMT_NO_BYTE_SEEK: u32 = 32768;
pub const AVFMT_ALLOW_FLUSH: u32 = 65536;
pub const AVFMT_TS_NONSTRICT: u32 = 131072;
pub const AVFMT_TS_NEGATIVE: u32 = 262144;
pub const AVFMT_SEEK_TO_PTS: u32 = 67108864;
pub const AVINDEX_KEYFRAME: u32 = 1;
pub const AVINDEX_DISCARD_FRAME: u32 = 2;
pub const AV_DISPOSITION_DEFAULT: u32 = 1;
pub const AV_DISPOSITION_DUB: u32 = 2;
pub const AV_DISPOSITION_ORIGINAL: u32 = 4;
pub const AV_DISPOSITION_COMMENT: u32 = 8;
pub const AV_DISPOSITION_LYRICS: u32 = 16;
pub const AV_DISPOSITION_KARAOKE: u32 = 32;
pub const AV_DISPOSITION_FORCED: u32 = 64;
pub const AV_DISPOSITION_HEARING_IMPAIRED: u32 = 128;
pub const AV_DISPOSITION_VISUAL_IMPAIRED: u32 = 256;
pub const AV_DISPOSITION_CLEAN_EFFECTS: u32 = 512;
pub const AV_DISPOSITION_ATTACHED_PIC: u32 = 1024;
pub const AV_DISPOSITION_TIMED_THUMBNAILS: u32 = 2048;
pub const AV_DISPOSITION_CAPTIONS: u32 = 65536;
pub const AV_DISPOSITION_DESCRIPTIONS: u32 = 131072;
pub const AV_DISPOSITION_METADATA: u32 = 262144;
pub const AV_PTS_WRAP_IGNORE: u32 = 0;
pub const AV_PTS_WRAP_ADD_OFFSET: u32 = 1;
pub const AV_PTS_WRAP_SUB_OFFSET: i32 = -1;
pub const AVSTREAM_EVENT_FLAG_METADATA_UPDATED: u32 = 1;
pub const MAX_STD_TIMEBASES: u32 = 399;
pub const MAX_REORDER_DELAY: u32 = 16;
pub const AV_PROGRAM_RUNNING: u32 = 1;
pub const AVFMTCTX_NOHEADER: u32 = 1;
pub const AVFMT_FLAG_GENPTS: u32 = 1;
pub const AVFMT_FLAG_IGNIDX: u32 = 2;
pub const AVFMT_FLAG_NONBLOCK: u32 = 4;
pub const AVFMT_FLAG_IGNDTS: u32 = 8;
pub const AVFMT_FLAG_NOFILLIN: u32 = 16;
pub const AVFMT_FLAG_NOPARSE: u32 = 32;
pub const AVFMT_FLAG_NOBUFFER: u32 = 64;
pub const AVFMT_FLAG_CUSTOM_IO: u32 = 128;
pub const AVFMT_FLAG_DISCARD_CORRUPT: u32 = 256;
pub const AVFMT_FLAG_FLUSH_PACKETS: u32 = 512;
pub const AVFMT_FLAG_BITEXACT: u32 = 1024;
pub const AVFMT_FLAG_MP4A_LATM: u32 = 32768;
pub const AVFMT_FLAG_SORT_DTS: u32 = 65536;
pub const AVFMT_FLAG_PRIV_OPT: u32 = 131072;
pub const AVFMT_FLAG_FAST_SEEK: u32 = 524288;
pub const AVFMT_FLAG_SHORTEST: u32 = 1048576;
pub const AVFMT_FLAG_AUTO_BSF: u32 = 2097152;
pub const FF_FDEBUG_TS: u32 = 1;
pub const AVFMT_EVENT_FLAG_METADATA_UPDATED: u32 = 1;
pub const AVFMT_AVOID_NEG_TS_AUTO: i32 = -1;
pub const AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE: u32 = 1;
pub const AVFMT_AVOID_NEG_TS_MAKE_ZERO: u32 = 2;
pub const AVSEEK_FLAG_BACKWARD: u32 = 1;
pub const AVSEEK_FLAG_BYTE: u32 = 2;
pub const AVSEEK_FLAG_ANY: u32 = 4;
pub const AVSEEK_FLAG_FRAME: u32 = 8;
pub const AVSTREAM_INIT_IN_WRITE_HEADER: u32 = 0;
pub const AVSTREAM_INIT_IN_INIT_OUTPUT: u32 = 1;
pub const AV_FRAME_FILENAME_FLAGS_MULTIPLE: u32 = 1;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
pub type pid_t = __pid_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: __locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
pub type FILE = _IO_FILE;
pub type __FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
pub const __codecvt_result___codecvt_ok: __codecvt_result = 0;
pub const __codecvt_result___codecvt_partial: __codecvt_result = 1;
pub const __codecvt_result___codecvt_error: __codecvt_result = 2;
pub const __codecvt_result___codecvt_noconv: __codecvt_result = 3;
pub type __codecvt_result = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type __io_write_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> __ssize_t,
>;
pub type __io_seek_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type __io_close_fn = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int, arg3: __ssize_t)
        -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void, arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gets(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __s: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn avutil_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn av_version_info() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn avutil_configuration() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn avutil_license() -> *const ::std::os::raw::c_char;
}
pub const AVMediaType_AVMEDIA_TYPE_UNKNOWN: AVMediaType = -1;
pub const AVMediaType_AVMEDIA_TYPE_VIDEO: AVMediaType = 0;
pub const AVMediaType_AVMEDIA_TYPE_AUDIO: AVMediaType = 1;
pub const AVMediaType_AVMEDIA_TYPE_DATA: AVMediaType = 2;
pub const AVMediaType_AVMEDIA_TYPE_SUBTITLE: AVMediaType = 3;
pub const AVMediaType_AVMEDIA_TYPE_ATTACHMENT: AVMediaType = 4;
pub const AVMediaType_AVMEDIA_TYPE_NB: AVMediaType = 5;
pub type AVMediaType = i32;
extern "C" {
    pub fn av_get_media_type_string(media_type: AVMediaType) -> *const ::std::os::raw::c_char;
}
pub const AVPictureType_AV_PICTURE_TYPE_NONE: AVPictureType = 0;
pub const AVPictureType_AV_PICTURE_TYPE_I: AVPictureType = 1;
pub const AVPictureType_AV_PICTURE_TYPE_P: AVPictureType = 2;
pub const AVPictureType_AV_PICTURE_TYPE_B: AVPictureType = 3;
pub const AVPictureType_AV_PICTURE_TYPE_S: AVPictureType = 4;
pub const AVPictureType_AV_PICTURE_TYPE_SI: AVPictureType = 5;
pub const AVPictureType_AV_PICTURE_TYPE_SP: AVPictureType = 6;
pub const AVPictureType_AV_PICTURE_TYPE_BI: AVPictureType = 7;
pub type AVPictureType = u32;
extern "C" {
    pub fn av_get_picture_type_char(pict_type: AVPictureType) -> ::std::os::raw::c_char;
}
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn __atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn expl(__x: u128) -> u128;
}
extern "C" {
    pub fn __expl(__x: u128) -> u128;
}
extern "C" {
    pub fn frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn logl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logl(__x: u128) -> u128;
}
extern "C" {
    pub fn log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn __expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn __log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn __ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn __fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn __floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn __significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn __isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn __scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn __roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn __truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fpclassifyl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub fn __scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
pub const _LIB_VERSION_TYPE__IEEE_: _LIB_VERSION_TYPE = -1;
pub const _LIB_VERSION_TYPE__SVID_: _LIB_VERSION_TYPE = 0;
pub const _LIB_VERSION_TYPE__XOPEN_: _LIB_VERSION_TYPE = 1;
pub const _LIB_VERSION_TYPE__POSIX_: _LIB_VERSION_TYPE = 2;
pub const _LIB_VERSION_TYPE__ISOC_: _LIB_VERSION_TYPE = 3;
pub type _LIB_VERSION_TYPE = i32;
extern "C" {
    pub static mut _LIB_VERSION: _LIB_VERSION_TYPE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exception {
    pub type_: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
extern "C" {
    pub fn matherr(__exc: *mut exception) -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub __wait_terminated: wait__bindgen_ty_1,
    pub __wait_stopped: wait__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn __w_termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set___w_termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn __w_coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___w_coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __w_retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___w_retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __w_termsig: ::std::os::raw::c_uint,
        __w_coredump: ::std::os::raw::c_uint,
        __w_retcode: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let __w_termsig: u32 = unsafe { ::std::mem::transmute(__w_termsig) };
            __w_termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let __w_coredump: u32 = unsafe { ::std::mem::transmute(__w_coredump) };
            __w_coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let __w_retcode: u32 = unsafe { ::std::mem::transmute(__w_retcode) };
            __w_retcode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn __w_stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___w_stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __w_stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___w_stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __w_stopval: ::std::os::raw::c_uint,
        __w_stopsig: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let __w_stopval: u32 = unsafe { ::std::mem::transmute(__w_stopval) };
            __w_stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let __w_stopsig: u32 = unsafe { ::std::mem::transmute(__w_stopsig) };
            __w_stopsig as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __WAIT_STATUS {
    pub __uptr: *mut wait,
    pub __iptr: *mut ::std::os::raw::c_int,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(
        __major: ::std::os::raw::c_uint,
        __minor: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulonglong;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: pthread_mutex_t___pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: pthread_cond_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: pthread_rwlock_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __pad1: ::std::os::raw::c_ulong,
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn cfree(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> usize;
}
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: __locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: __locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: __locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_log2(v: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_log2_16bit(v: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_strerror(
        errnum: ::std::os::raw::c_int,
        errbuf: *mut ::std::os::raw::c_char,
        errbuf_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_mallocz(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_calloc(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_realloc(ptr: *mut ::std::os::raw::c_void, size: usize)
        -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_reallocp(ptr: *mut ::std::os::raw::c_void, size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_realloc_f(
        ptr: *mut ::std::os::raw::c_void,
        nelem: usize,
        elsize: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_realloc_array(
        ptr: *mut ::std::os::raw::c_void,
        nmemb: usize,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_reallocp_array(
        ptr: *mut ::std::os::raw::c_void,
        nmemb: usize,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_fast_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_fast_malloc(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    );
}
extern "C" {
    pub fn av_fast_mallocz(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    );
}
extern "C" {
    pub fn av_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn av_freep(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn av_strdup(s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_strndup(s: *const ::std::os::raw::c_char, len: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_memdup(p: *const ::std::os::raw::c_void, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_memcpy_backptr(dst: *mut u8, back: ::std::os::raw::c_int, cnt: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_dynarray_add(
        tab_ptr: *mut ::std::os::raw::c_void,
        nb_ptr: *mut ::std::os::raw::c_int,
        elem: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn av_dynarray_add_nofree(
        tab_ptr: *mut ::std::os::raw::c_void,
        nb_ptr: *mut ::std::os::raw::c_int,
        elem: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_dynarray2_add(
        tab_ptr: *mut *mut ::std::os::raw::c_void,
        nb_ptr: *mut ::std::os::raw::c_int,
        elem_size: usize,
        elem_data: *const u8,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_max_alloc(max: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVRational {
    pub num: ::std::os::raw::c_int,
    pub den: ::std::os::raw::c_int,
}
extern "C" {
    pub fn av_reduce(
        dst_num: *mut ::std::os::raw::c_int,
        dst_den: *mut ::std::os::raw::c_int,
        num: i64,
        den: i64,
        max: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_mul_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    pub fn av_div_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    pub fn av_add_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    pub fn av_sub_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    pub fn av_d2q(d: f64, max: ::std::os::raw::c_int) -> AVRational;
}
extern "C" {
    pub fn av_nearer_q(q: AVRational, q1: AVRational, q2: AVRational) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_find_nearest_q_idx(q: AVRational, q_list: *const AVRational)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_q2intfloat(q: AVRational) -> u32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union av_intfloat32 {
    pub i: u32,
    pub f: f32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union av_intfloat64 {
    pub i: u64,
    pub f: f64,
    _bindgen_union_align: u64,
}
pub const AVRounding_AV_ROUND_ZERO: AVRounding = 0;
pub const AVRounding_AV_ROUND_INF: AVRounding = 1;
pub const AVRounding_AV_ROUND_DOWN: AVRounding = 2;
pub const AVRounding_AV_ROUND_UP: AVRounding = 3;
pub const AVRounding_AV_ROUND_NEAR_INF: AVRounding = 5;
pub const AVRounding_AV_ROUND_PASS_MINMAX: AVRounding = 8192;
pub type AVRounding = u32;
extern "C" {
    pub fn av_gcd(a: i64, b: i64) -> i64;
}
extern "C" {
    pub fn av_rescale(a: i64, b: i64, c: i64) -> i64;
}
extern "C" {
    pub fn av_rescale_rnd(a: i64, b: i64, c: i64, rnd: AVRounding) -> i64;
}
extern "C" {
    pub fn av_rescale_q(a: i64, bq: AVRational, cq: AVRational) -> i64;
}
extern "C" {
    pub fn av_rescale_q_rnd(a: i64, bq: AVRational, cq: AVRational, rnd: AVRounding) -> i64;
}
extern "C" {
    pub fn av_compare_ts(
        ts_a: i64,
        tb_a: AVRational,
        ts_b: i64,
        tb_b: AVRational,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_compare_mod(a: u64, b: u64, mod_: u64) -> i64;
}
extern "C" {
    pub fn av_rescale_delta(
        in_tb: AVRational,
        in_ts: i64,
        fs_tb: AVRational,
        duration: ::std::os::raw::c_int,
        last: *mut i64,
        out_tb: AVRational,
    ) -> i64;
}
extern "C" {
    pub fn av_add_stable(ts_tb: AVRational, ts: i64, inc_tb: AVRational, inc: i64) -> i64;
}
pub const AVClassCategory_AV_CLASS_CATEGORY_NA: AVClassCategory = 0;
pub const AVClassCategory_AV_CLASS_CATEGORY_INPUT: AVClassCategory = 1;
pub const AVClassCategory_AV_CLASS_CATEGORY_OUTPUT: AVClassCategory = 2;
pub const AVClassCategory_AV_CLASS_CATEGORY_MUXER: AVClassCategory = 3;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEMUXER: AVClassCategory = 4;
pub const AVClassCategory_AV_CLASS_CATEGORY_ENCODER: AVClassCategory = 5;
pub const AVClassCategory_AV_CLASS_CATEGORY_DECODER: AVClassCategory = 6;
pub const AVClassCategory_AV_CLASS_CATEGORY_FILTER: AVClassCategory = 7;
pub const AVClassCategory_AV_CLASS_CATEGORY_BITSTREAM_FILTER: AVClassCategory = 8;
pub const AVClassCategory_AV_CLASS_CATEGORY_SWSCALER: AVClassCategory = 9;
pub const AVClassCategory_AV_CLASS_CATEGORY_SWRESAMPLER: AVClassCategory = 10;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT: AVClassCategory = 40;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT: AVClassCategory = 41;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT: AVClassCategory = 42;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT: AVClassCategory = 43;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_OUTPUT: AVClassCategory = 44;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_INPUT: AVClassCategory = 45;
pub const AVClassCategory_AV_CLASS_CATEGORY_NB: AVClassCategory = 46;
pub type AVClassCategory = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVOptionRanges {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVClass {
    pub class_name: *const ::std::os::raw::c_char,
    pub item_name: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    pub option: *const AVOption,
    pub version: ::std::os::raw::c_int,
    pub log_level_offset_offset: ::std::os::raw::c_int,
    pub parent_log_context_offset: ::std::os::raw::c_int,
    pub child_next: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut ::std::os::raw::c_void,
            prev: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub child_class_next:
        ::std::option::Option<unsafe extern "C" fn(prev: *const AVClass) -> *const AVClass>,
    pub category: AVClassCategory,
    pub get_category: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> AVClassCategory,
    >,
    pub query_ranges: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut *mut AVOptionRanges,
            obj: *mut ::std::os::raw::c_void,
            key: *const ::std::os::raw::c_char,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
}
extern "C" {
    pub fn av_log(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn av_vlog(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn av_log_get_level() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_log_set_level(level: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_log_set_callback(
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_char,
                arg4: *mut __va_list_tag,
            ),
        >,
    );
}
extern "C" {
    pub fn av_log_default_callback(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn av_default_item_name(ctx: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_default_get_category(ptr: *mut ::std::os::raw::c_void) -> AVClassCategory;
}
extern "C" {
    pub fn av_log_format_line(
        ptr: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: *mut __va_list_tag,
        line: *mut ::std::os::raw::c_char,
        line_size: ::std::os::raw::c_int,
        print_prefix: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn av_log_format_line2(
        ptr: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: *mut __va_list_tag,
        line: *mut ::std::os::raw::c_char,
        line_size: ::std::os::raw::c_int,
        print_prefix: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_log_set_flags(arg: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_log_get_flags() -> ::std::os::raw::c_int;
}
pub const AVPixelFormat_AV_PIX_FMT_NONE: AVPixelFormat = -1;
pub const AVPixelFormat_AV_PIX_FMT_YUV420P: AVPixelFormat = 0;
pub const AVPixelFormat_AV_PIX_FMT_YUYV422: AVPixelFormat = 1;
pub const AVPixelFormat_AV_PIX_FMT_RGB24: AVPixelFormat = 2;
pub const AVPixelFormat_AV_PIX_FMT_BGR24: AVPixelFormat = 3;
pub const AVPixelFormat_AV_PIX_FMT_YUV422P: AVPixelFormat = 4;
pub const AVPixelFormat_AV_PIX_FMT_YUV444P: AVPixelFormat = 5;
pub const AVPixelFormat_AV_PIX_FMT_YUV410P: AVPixelFormat = 6;
pub const AVPixelFormat_AV_PIX_FMT_YUV411P: AVPixelFormat = 7;
pub const AVPixelFormat_AV_PIX_FMT_GRAY8: AVPixelFormat = 8;
pub const AVPixelFormat_AV_PIX_FMT_MONOWHITE: AVPixelFormat = 9;
pub const AVPixelFormat_AV_PIX_FMT_MONOBLACK: AVPixelFormat = 10;
pub const AVPixelFormat_AV_PIX_FMT_PAL8: AVPixelFormat = 11;
pub const AVPixelFormat_AV_PIX_FMT_YUVJ420P: AVPixelFormat = 12;
pub const AVPixelFormat_AV_PIX_FMT_YUVJ422P: AVPixelFormat = 13;
pub const AVPixelFormat_AV_PIX_FMT_YUVJ444P: AVPixelFormat = 14;
pub const AVPixelFormat_AV_PIX_FMT_XVMC_MPEG2_MC: AVPixelFormat = 15;
pub const AVPixelFormat_AV_PIX_FMT_XVMC_MPEG2_IDCT: AVPixelFormat = 16;
pub const AVPixelFormat_AV_PIX_FMT_XVMC: AVPixelFormat = 16;
pub const AVPixelFormat_AV_PIX_FMT_UYVY422: AVPixelFormat = 17;
pub const AVPixelFormat_AV_PIX_FMT_UYYVYY411: AVPixelFormat = 18;
pub const AVPixelFormat_AV_PIX_FMT_BGR8: AVPixelFormat = 19;
pub const AVPixelFormat_AV_PIX_FMT_BGR4: AVPixelFormat = 20;
pub const AVPixelFormat_AV_PIX_FMT_BGR4_BYTE: AVPixelFormat = 21;
pub const AVPixelFormat_AV_PIX_FMT_RGB8: AVPixelFormat = 22;
pub const AVPixelFormat_AV_PIX_FMT_RGB4: AVPixelFormat = 23;
pub const AVPixelFormat_AV_PIX_FMT_RGB4_BYTE: AVPixelFormat = 24;
pub const AVPixelFormat_AV_PIX_FMT_NV12: AVPixelFormat = 25;
pub const AVPixelFormat_AV_PIX_FMT_NV21: AVPixelFormat = 26;
pub const AVPixelFormat_AV_PIX_FMT_ARGB: AVPixelFormat = 27;
pub const AVPixelFormat_AV_PIX_FMT_RGBA: AVPixelFormat = 28;
pub const AVPixelFormat_AV_PIX_FMT_ABGR: AVPixelFormat = 29;
pub const AVPixelFormat_AV_PIX_FMT_BGRA: AVPixelFormat = 30;
pub const AVPixelFormat_AV_PIX_FMT_GRAY16BE: AVPixelFormat = 31;
pub const AVPixelFormat_AV_PIX_FMT_GRAY16LE: AVPixelFormat = 32;
pub const AVPixelFormat_AV_PIX_FMT_YUV440P: AVPixelFormat = 33;
pub const AVPixelFormat_AV_PIX_FMT_YUVJ440P: AVPixelFormat = 34;
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P: AVPixelFormat = 35;
pub const AVPixelFormat_AV_PIX_FMT_VDPAU_H264: AVPixelFormat = 36;
pub const AVPixelFormat_AV_PIX_FMT_VDPAU_MPEG1: AVPixelFormat = 37;
pub const AVPixelFormat_AV_PIX_FMT_VDPAU_MPEG2: AVPixelFormat = 38;
pub const AVPixelFormat_AV_PIX_FMT_VDPAU_WMV3: AVPixelFormat = 39;
pub const AVPixelFormat_AV_PIX_FMT_VDPAU_VC1: AVPixelFormat = 40;
pub const AVPixelFormat_AV_PIX_FMT_RGB48BE: AVPixelFormat = 41;
pub const AVPixelFormat_AV_PIX_FMT_RGB48LE: AVPixelFormat = 42;
pub const AVPixelFormat_AV_PIX_FMT_RGB565BE: AVPixelFormat = 43;
pub const AVPixelFormat_AV_PIX_FMT_RGB565LE: AVPixelFormat = 44;
pub const AVPixelFormat_AV_PIX_FMT_RGB555BE: AVPixelFormat = 45;
pub const AVPixelFormat_AV_PIX_FMT_RGB555LE: AVPixelFormat = 46;
pub const AVPixelFormat_AV_PIX_FMT_BGR565BE: AVPixelFormat = 47;
pub const AVPixelFormat_AV_PIX_FMT_BGR565LE: AVPixelFormat = 48;
pub const AVPixelFormat_AV_PIX_FMT_BGR555BE: AVPixelFormat = 49;
pub const AVPixelFormat_AV_PIX_FMT_BGR555LE: AVPixelFormat = 50;
pub const AVPixelFormat_AV_PIX_FMT_VAAPI_MOCO: AVPixelFormat = 51;
pub const AVPixelFormat_AV_PIX_FMT_VAAPI_IDCT: AVPixelFormat = 52;
pub const AVPixelFormat_AV_PIX_FMT_VAAPI_VLD: AVPixelFormat = 53;
pub const AVPixelFormat_AV_PIX_FMT_VAAPI: AVPixelFormat = 53;
pub const AVPixelFormat_AV_PIX_FMT_YUV420P16LE: AVPixelFormat = 54;
pub const AVPixelFormat_AV_PIX_FMT_YUV420P16BE: AVPixelFormat = 55;
pub const AVPixelFormat_AV_PIX_FMT_YUV422P16LE: AVPixelFormat = 56;
pub const AVPixelFormat_AV_PIX_FMT_YUV422P16BE: AVPixelFormat = 57;
pub const AVPixelFormat_AV_PIX_FMT_YUV444P16LE: AVPixelFormat = 58;
pub const AVPixelFormat_AV_PIX_FMT_YUV444P16BE: AVPixelFormat = 59;
pub const AVPixelFormat_AV_PIX_FMT_VDPAU_MPEG4: AVPixelFormat = 60;
pub const AVPixelFormat_AV_PIX_FMT_DXVA2_VLD: AVPixelFormat = 61;
pub const AVPixelFormat_AV_PIX_FMT_RGB444LE: AVPixelFormat = 62;
pub const AVPixelFormat_AV_PIX_FMT_RGB444BE: AVPixelFormat = 63;
pub const AVPixelFormat_AV_PIX_FMT_BGR444LE: AVPixelFormat = 64;
pub const AVPixelFormat_AV_PIX_FMT_BGR444BE: AVPixelFormat = 65;
pub const AVPixelFormat_AV_PIX_FMT_YA8: AVPixelFormat = 66;
pub const AVPixelFormat_AV_PIX_FMT_Y400A: AVPixelFormat = 66;
pub const AVPixelFormat_AV_PIX_FMT_GRAY8A: AVPixelFormat = 66;
pub const AVPixelFormat_AV_PIX_FMT_BGR48BE: AVPixelFormat = 67;
pub const AVPixelFormat_AV_PIX_FMT_BGR48LE: AVPixelFormat = 68;
pub const AVPixelFormat_AV_PIX_FMT_YUV420P9BE: AVPixelFormat = 69;
pub const AVPixelFormat_AV_PIX_FMT_YUV420P9LE: AVPixelFormat = 70;
pub const AVPixelFormat_AV_PIX_FMT_YUV420P10BE: AVPixelFormat = 71;
pub const AVPixelFormat_AV_PIX_FMT_YUV420P10LE: AVPixelFormat = 72;
pub const AVPixelFormat_AV_PIX_FMT_YUV422P10BE: AVPixelFormat = 73;
pub const AVPixelFormat_AV_PIX_FMT_YUV422P10LE: AVPixelFormat = 74;
pub const AVPixelFormat_AV_PIX_FMT_YUV444P9BE: AVPixelFormat = 75;
pub const AVPixelFormat_AV_PIX_FMT_YUV444P9LE: AVPixelFormat = 76;
pub const AVPixelFormat_AV_PIX_FMT_YUV444P10BE: AVPixelFormat = 77;
pub const AVPixelFormat_AV_PIX_FMT_YUV444P10LE: AVPixelFormat = 78;
pub const AVPixelFormat_AV_PIX_FMT_YUV422P9BE: AVPixelFormat = 79;
pub const AVPixelFormat_AV_PIX_FMT_YUV422P9LE: AVPixelFormat = 80;
pub const AVPixelFormat_AV_PIX_FMT_VDA_VLD: AVPixelFormat = 81;
pub const AVPixelFormat_AV_PIX_FMT_GBRP: AVPixelFormat = 82;
pub const AVPixelFormat_AV_PIX_FMT_GBR24P: AVPixelFormat = 82;
pub const AVPixelFormat_AV_PIX_FMT_GBRP9BE: AVPixelFormat = 83;
pub const AVPixelFormat_AV_PIX_FMT_GBRP9LE: AVPixelFormat = 84;
pub const AVPixelFormat_AV_PIX_FMT_GBRP10BE: AVPixelFormat = 85;
pub const AVPixelFormat_AV_PIX_FMT_GBRP10LE: AVPixelFormat = 86;
pub const AVPixelFormat_AV_PIX_FMT_GBRP16BE: AVPixelFormat = 87;
pub const AVPixelFormat_AV_PIX_FMT_GBRP16LE: AVPixelFormat = 88;
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P: AVPixelFormat = 89;
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P: AVPixelFormat = 90;
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P9BE: AVPixelFormat = 91;
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P9LE: AVPixelFormat = 92;
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P9BE: AVPixelFormat = 93;
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P9LE: AVPixelFormat = 94;
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P9BE: AVPixelFormat = 95;
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P9LE: AVPixelFormat = 96;
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P10BE: AVPixelFormat = 97;
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P10LE: AVPixelFormat = 98;
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P10BE: AVPixelFormat = 99;
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P10LE: AVPixelFormat = 100;
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P10BE: AVPixelFormat = 101;
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P10LE: AVPixelFormat = 102;
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P16BE: AVPixelFormat = 103;
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P16LE: AVPixelFormat = 104;
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P16BE: AVPixelFormat = 105;
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P16LE: AVPixelFormat = 106;
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P16BE: AVPixelFormat = 107;
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P16LE: AVPixelFormat = 108;
pub const AVPixelFormat_AV_PIX_FMT_VDPAU: AVPixelFormat = 109;
pub const AVPixelFormat_AV_PIX_FMT_XYZ12LE: AVPixelFormat = 110;
pub const AVPixelFormat_AV_PIX_FMT_XYZ12BE: AVPixelFormat = 111;
pub const AVPixelFormat_AV_PIX_FMT_NV16: AVPixelFormat = 112;
pub const AVPixelFormat_AV_PIX_FMT_NV20LE: AVPixelFormat = 113;
pub const AVPixelFormat_AV_PIX_FMT_NV20BE: AVPixelFormat = 114;
pub const AVPixelFormat_AV_PIX_FMT_RGBA64BE: AVPixelFormat = 115;
pub const AVPixelFormat_AV_PIX_FMT_RGBA64LE: AVPixelFormat = 116;
pub const AVPixelFormat_AV_PIX_FMT_BGRA64BE: AVPixelFormat = 117;
pub const AVPixelFormat_AV_PIX_FMT_BGRA64LE: AVPixelFormat = 118;
pub const AVPixelFormat_AV_PIX_FMT_YVYU422: AVPixelFormat = 119;
pub const AVPixelFormat_AV_PIX_FMT_VDA: AVPixelFormat = 120;
pub const AVPixelFormat_AV_PIX_FMT_YA16BE: AVPixelFormat = 121;
pub const AVPixelFormat_AV_PIX_FMT_YA16LE: AVPixelFormat = 122;
pub const AVPixelFormat_AV_PIX_FMT_GBRAP: AVPixelFormat = 123;
pub const AVPixelFormat_AV_PIX_FMT_GBRAP16BE: AVPixelFormat = 124;
pub const AVPixelFormat_AV_PIX_FMT_GBRAP16LE: AVPixelFormat = 125;
pub const AVPixelFormat_AV_PIX_FMT_QSV: AVPixelFormat = 126;
pub const AVPixelFormat_AV_PIX_FMT_MMAL: AVPixelFormat = 127;
pub const AVPixelFormat_AV_PIX_FMT_D3D11VA_VLD: AVPixelFormat = 128;
pub const AVPixelFormat_AV_PIX_FMT_CUDA: AVPixelFormat = 129;
pub const AVPixelFormat_AV_PIX_FMT_0RGB: AVPixelFormat = 295;
pub const AVPixelFormat_AV_PIX_FMT_RGB0: AVPixelFormat = 296;
pub const AVPixelFormat_AV_PIX_FMT_0BGR: AVPixelFormat = 297;
pub const AVPixelFormat_AV_PIX_FMT_BGR0: AVPixelFormat = 298;
pub const AVPixelFormat_AV_PIX_FMT_YUV420P12BE: AVPixelFormat = 299;
pub const AVPixelFormat_AV_PIX_FMT_YUV420P12LE: AVPixelFormat = 300;
pub const AVPixelFormat_AV_PIX_FMT_YUV420P14BE: AVPixelFormat = 301;
pub const AVPixelFormat_AV_PIX_FMT_YUV420P14LE: AVPixelFormat = 302;
pub const AVPixelFormat_AV_PIX_FMT_YUV422P12BE: AVPixelFormat = 303;
pub const AVPixelFormat_AV_PIX_FMT_YUV422P12LE: AVPixelFormat = 304;
pub const AVPixelFormat_AV_PIX_FMT_YUV422P14BE: AVPixelFormat = 305;
pub const AVPixelFormat_AV_PIX_FMT_YUV422P14LE: AVPixelFormat = 306;
pub const AVPixelFormat_AV_PIX_FMT_YUV444P12BE: AVPixelFormat = 307;
pub const AVPixelFormat_AV_PIX_FMT_YUV444P12LE: AVPixelFormat = 308;
pub const AVPixelFormat_AV_PIX_FMT_YUV444P14BE: AVPixelFormat = 309;
pub const AVPixelFormat_AV_PIX_FMT_YUV444P14LE: AVPixelFormat = 310;
pub const AVPixelFormat_AV_PIX_FMT_GBRP12BE: AVPixelFormat = 311;
pub const AVPixelFormat_AV_PIX_FMT_GBRP12LE: AVPixelFormat = 312;
pub const AVPixelFormat_AV_PIX_FMT_GBRP14BE: AVPixelFormat = 313;
pub const AVPixelFormat_AV_PIX_FMT_GBRP14LE: AVPixelFormat = 314;
pub const AVPixelFormat_AV_PIX_FMT_YUVJ411P: AVPixelFormat = 315;
pub const AVPixelFormat_AV_PIX_FMT_BAYER_BGGR8: AVPixelFormat = 316;
pub const AVPixelFormat_AV_PIX_FMT_BAYER_RGGB8: AVPixelFormat = 317;
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GBRG8: AVPixelFormat = 318;
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GRBG8: AVPixelFormat = 319;
pub const AVPixelFormat_AV_PIX_FMT_BAYER_BGGR16LE: AVPixelFormat = 320;
pub const AVPixelFormat_AV_PIX_FMT_BAYER_BGGR16BE: AVPixelFormat = 321;
pub const AVPixelFormat_AV_PIX_FMT_BAYER_RGGB16LE: AVPixelFormat = 322;
pub const AVPixelFormat_AV_PIX_FMT_BAYER_RGGB16BE: AVPixelFormat = 323;
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GBRG16LE: AVPixelFormat = 324;
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GBRG16BE: AVPixelFormat = 325;
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GRBG16LE: AVPixelFormat = 326;
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GRBG16BE: AVPixelFormat = 327;
pub const AVPixelFormat_AV_PIX_FMT_YUV440P10LE: AVPixelFormat = 328;
pub const AVPixelFormat_AV_PIX_FMT_YUV440P10BE: AVPixelFormat = 329;
pub const AVPixelFormat_AV_PIX_FMT_YUV440P12LE: AVPixelFormat = 330;
pub const AVPixelFormat_AV_PIX_FMT_YUV440P12BE: AVPixelFormat = 331;
pub const AVPixelFormat_AV_PIX_FMT_AYUV64LE: AVPixelFormat = 332;
pub const AVPixelFormat_AV_PIX_FMT_AYUV64BE: AVPixelFormat = 333;
pub const AVPixelFormat_AV_PIX_FMT_VIDEOTOOLBOX: AVPixelFormat = 334;
pub const AVPixelFormat_AV_PIX_FMT_P010LE: AVPixelFormat = 335;
pub const AVPixelFormat_AV_PIX_FMT_P010BE: AVPixelFormat = 336;
pub const AVPixelFormat_AV_PIX_FMT_GBRAP12BE: AVPixelFormat = 337;
pub const AVPixelFormat_AV_PIX_FMT_GBRAP12LE: AVPixelFormat = 338;
pub const AVPixelFormat_AV_PIX_FMT_GBRAP10BE: AVPixelFormat = 339;
pub const AVPixelFormat_AV_PIX_FMT_GBRAP10LE: AVPixelFormat = 340;
pub const AVPixelFormat_AV_PIX_FMT_MEDIACODEC: AVPixelFormat = 341;
pub const AVPixelFormat_AV_PIX_FMT_NB: AVPixelFormat = 342;
pub type AVPixelFormat = i32;
pub const AVColorPrimaries_AVCOL_PRI_RESERVED0: AVColorPrimaries = 0;
pub const AVColorPrimaries_AVCOL_PRI_BT709: AVColorPrimaries = 1;
pub const AVColorPrimaries_AVCOL_PRI_UNSPECIFIED: AVColorPrimaries = 2;
pub const AVColorPrimaries_AVCOL_PRI_RESERVED: AVColorPrimaries = 3;
pub const AVColorPrimaries_AVCOL_PRI_BT470M: AVColorPrimaries = 4;
pub const AVColorPrimaries_AVCOL_PRI_BT470BG: AVColorPrimaries = 5;
pub const AVColorPrimaries_AVCOL_PRI_SMPTE170M: AVColorPrimaries = 6;
pub const AVColorPrimaries_AVCOL_PRI_SMPTE240M: AVColorPrimaries = 7;
pub const AVColorPrimaries_AVCOL_PRI_FILM: AVColorPrimaries = 8;
pub const AVColorPrimaries_AVCOL_PRI_BT2020: AVColorPrimaries = 9;
pub const AVColorPrimaries_AVCOL_PRI_SMPTEST428_1: AVColorPrimaries = 10;
pub const AVColorPrimaries_AVCOL_PRI_SMPTE431: AVColorPrimaries = 11;
pub const AVColorPrimaries_AVCOL_PRI_SMPTE432: AVColorPrimaries = 12;
pub const AVColorPrimaries_AVCOL_PRI_NB: AVColorPrimaries = 13;
pub type AVColorPrimaries = u32;
pub const AVColorTransferCharacteristic_AVCOL_TRC_RESERVED0: AVColorTransferCharacteristic = 0;
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT709: AVColorTransferCharacteristic = 1;
pub const AVColorTransferCharacteristic_AVCOL_TRC_UNSPECIFIED: AVColorTransferCharacteristic = 2;
pub const AVColorTransferCharacteristic_AVCOL_TRC_RESERVED: AVColorTransferCharacteristic = 3;
pub const AVColorTransferCharacteristic_AVCOL_TRC_GAMMA22: AVColorTransferCharacteristic = 4;
pub const AVColorTransferCharacteristic_AVCOL_TRC_GAMMA28: AVColorTransferCharacteristic = 5;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE170M: AVColorTransferCharacteristic = 6;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE240M: AVColorTransferCharacteristic = 7;
pub const AVColorTransferCharacteristic_AVCOL_TRC_LINEAR: AVColorTransferCharacteristic = 8;
pub const AVColorTransferCharacteristic_AVCOL_TRC_LOG: AVColorTransferCharacteristic = 9;
pub const AVColorTransferCharacteristic_AVCOL_TRC_LOG_SQRT: AVColorTransferCharacteristic = 10;
pub const AVColorTransferCharacteristic_AVCOL_TRC_IEC61966_2_4: AVColorTransferCharacteristic = 11;
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT1361_ECG: AVColorTransferCharacteristic = 12;
pub const AVColorTransferCharacteristic_AVCOL_TRC_IEC61966_2_1: AVColorTransferCharacteristic = 13;
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT2020_10: AVColorTransferCharacteristic = 14;
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT2020_12: AVColorTransferCharacteristic = 15;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTEST2084: AVColorTransferCharacteristic = 16;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTEST428_1: AVColorTransferCharacteristic = 17;
pub const AVColorTransferCharacteristic_AVCOL_TRC_ARIB_STD_B67: AVColorTransferCharacteristic = 18;
pub const AVColorTransferCharacteristic_AVCOL_TRC_NB: AVColorTransferCharacteristic = 19;
pub type AVColorTransferCharacteristic = u32;
pub const AVColorSpace_AVCOL_SPC_RGB: AVColorSpace = 0;
pub const AVColorSpace_AVCOL_SPC_BT709: AVColorSpace = 1;
pub const AVColorSpace_AVCOL_SPC_UNSPECIFIED: AVColorSpace = 2;
pub const AVColorSpace_AVCOL_SPC_RESERVED: AVColorSpace = 3;
pub const AVColorSpace_AVCOL_SPC_FCC: AVColorSpace = 4;
pub const AVColorSpace_AVCOL_SPC_BT470BG: AVColorSpace = 5;
pub const AVColorSpace_AVCOL_SPC_SMPTE170M: AVColorSpace = 6;
pub const AVColorSpace_AVCOL_SPC_SMPTE240M: AVColorSpace = 7;
pub const AVColorSpace_AVCOL_SPC_YCOCG: AVColorSpace = 8;
pub const AVColorSpace_AVCOL_SPC_BT2020_NCL: AVColorSpace = 9;
pub const AVColorSpace_AVCOL_SPC_BT2020_CL: AVColorSpace = 10;
pub const AVColorSpace_AVCOL_SPC_SMPTE2085: AVColorSpace = 11;
pub const AVColorSpace_AVCOL_SPC_NB: AVColorSpace = 12;
pub type AVColorSpace = u32;
pub const AVColorRange_AVCOL_RANGE_UNSPECIFIED: AVColorRange = 0;
pub const AVColorRange_AVCOL_RANGE_MPEG: AVColorRange = 1;
pub const AVColorRange_AVCOL_RANGE_JPEG: AVColorRange = 2;
pub const AVColorRange_AVCOL_RANGE_NB: AVColorRange = 3;
pub type AVColorRange = u32;
pub const AVChromaLocation_AVCHROMA_LOC_UNSPECIFIED: AVChromaLocation = 0;
pub const AVChromaLocation_AVCHROMA_LOC_LEFT: AVChromaLocation = 1;
pub const AVChromaLocation_AVCHROMA_LOC_CENTER: AVChromaLocation = 2;
pub const AVChromaLocation_AVCHROMA_LOC_TOPLEFT: AVChromaLocation = 3;
pub const AVChromaLocation_AVCHROMA_LOC_TOP: AVChromaLocation = 4;
pub const AVChromaLocation_AVCHROMA_LOC_BOTTOMLEFT: AVChromaLocation = 5;
pub const AVChromaLocation_AVCHROMA_LOC_BOTTOM: AVChromaLocation = 6;
pub const AVChromaLocation_AVCHROMA_LOC_NB: AVChromaLocation = 7;
pub type AVChromaLocation = u32;
extern "C" {
    pub fn av_int_list_length_for_size(
        elsize: ::std::os::raw::c_uint,
        list: *const ::std::os::raw::c_void,
        term: u64,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn av_fopen_utf8(
        path: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn av_get_time_base_q() -> AVRational;
}
pub const AVSampleFormat_AV_SAMPLE_FMT_NONE: AVSampleFormat = -1;
pub const AVSampleFormat_AV_SAMPLE_FMT_U8: AVSampleFormat = 0;
pub const AVSampleFormat_AV_SAMPLE_FMT_S16: AVSampleFormat = 1;
pub const AVSampleFormat_AV_SAMPLE_FMT_S32: AVSampleFormat = 2;
pub const AVSampleFormat_AV_SAMPLE_FMT_FLT: AVSampleFormat = 3;
pub const AVSampleFormat_AV_SAMPLE_FMT_DBL: AVSampleFormat = 4;
pub const AVSampleFormat_AV_SAMPLE_FMT_U8P: AVSampleFormat = 5;
pub const AVSampleFormat_AV_SAMPLE_FMT_S16P: AVSampleFormat = 6;
pub const AVSampleFormat_AV_SAMPLE_FMT_S32P: AVSampleFormat = 7;
pub const AVSampleFormat_AV_SAMPLE_FMT_FLTP: AVSampleFormat = 8;
pub const AVSampleFormat_AV_SAMPLE_FMT_DBLP: AVSampleFormat = 9;
pub const AVSampleFormat_AV_SAMPLE_FMT_S64: AVSampleFormat = 10;
pub const AVSampleFormat_AV_SAMPLE_FMT_S64P: AVSampleFormat = 11;
pub const AVSampleFormat_AV_SAMPLE_FMT_NB: AVSampleFormat = 12;
pub type AVSampleFormat = i32;
extern "C" {
    pub fn av_get_sample_fmt_name(sample_fmt: AVSampleFormat) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_get_sample_fmt(name: *const ::std::os::raw::c_char) -> AVSampleFormat;
}
extern "C" {
    pub fn av_get_alt_sample_fmt(
        sample_fmt: AVSampleFormat,
        planar: ::std::os::raw::c_int,
    ) -> AVSampleFormat;
}
extern "C" {
    pub fn av_get_packed_sample_fmt(sample_fmt: AVSampleFormat) -> AVSampleFormat;
}
extern "C" {
    pub fn av_get_planar_sample_fmt(sample_fmt: AVSampleFormat) -> AVSampleFormat;
}
extern "C" {
    pub fn av_get_sample_fmt_string(
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_get_bytes_per_sample(sample_fmt: AVSampleFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_sample_fmt_is_planar(sample_fmt: AVSampleFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_samples_get_buffer_size(
        linesize: *mut ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_samples_fill_arrays(
        audio_data: *mut *mut u8,
        linesize: *mut ::std::os::raw::c_int,
        buf: *const u8,
        nb_channels: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_samples_alloc(
        audio_data: *mut *mut u8,
        linesize: *mut ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_samples_alloc_array_and_samples(
        audio_data: *mut *mut *mut u8,
        linesize: *mut ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_samples_copy(
        dst: *mut *mut u8,
        src: *const *mut u8,
        dst_offset: ::std::os::raw::c_int,
        src_offset: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_samples_set_silence(
        audio_data: *mut *mut u8,
        offset: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBufferRef {
    pub buffer: *mut AVBuffer,
    pub data: *mut u8,
    pub size: ::std::os::raw::c_int,
}
extern "C" {
    pub fn av_buffer_alloc(size: ::std::os::raw::c_int) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_buffer_allocz(size: ::std::os::raw::c_int) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_buffer_create(
        data: *mut u8,
        size: ::std::os::raw::c_int,
        free: ::std::option::Option<
            unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void, data: *mut u8),
        >,
        opaque: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_int,
    ) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_buffer_default_free(opaque: *mut ::std::os::raw::c_void, data: *mut u8);
}
extern "C" {
    pub fn av_buffer_ref(buf: *mut AVBufferRef) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_buffer_unref(buf: *mut *mut AVBufferRef);
}
extern "C" {
    pub fn av_buffer_is_writable(buf: *const AVBufferRef) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_buffer_get_opaque(buf: *const AVBufferRef) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_buffer_get_ref_count(buf: *const AVBufferRef) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_buffer_make_writable(buf: *mut *mut AVBufferRef) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_buffer_realloc(
        buf: *mut *mut AVBufferRef,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBufferPool {
    _unused: [u8; 0],
}
extern "C" {
    pub fn av_buffer_pool_init(
        size: ::std::os::raw::c_int,
        alloc: ::std::option::Option<
            unsafe extern "C" fn(size: ::std::os::raw::c_int) -> *mut AVBufferRef,
        >,
    ) -> *mut AVBufferPool;
}
extern "C" {
    pub fn av_buffer_pool_init2(
        size: ::std::os::raw::c_int,
        opaque: *mut ::std::os::raw::c_void,
        alloc: ::std::option::Option<
            unsafe extern "C" fn(
                opaque: *mut ::std::os::raw::c_void,
                size: ::std::os::raw::c_int,
            ) -> *mut AVBufferRef,
        >,
        pool_free: ::std::option::Option<unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void)>,
    ) -> *mut AVBufferPool;
}
extern "C" {
    pub fn av_buffer_pool_uninit(pool: *mut *mut AVBufferPool);
}
extern "C" {
    pub fn av_buffer_pool_get(pool: *mut AVBufferPool) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_get_cpu_flags() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_force_cpu_flags(flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_set_cpu_flags_mask(mask: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_parse_cpu_flags(s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_parse_cpu_caps(
        flags: *mut ::std::os::raw::c_uint,
        s: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_cpu_count() -> ::std::os::raw::c_int;
}
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_NONE: AVMatrixEncoding = 0;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DOLBY: AVMatrixEncoding = 1;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DPLII: AVMatrixEncoding = 2;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DPLIIX: AVMatrixEncoding = 3;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DPLIIZ: AVMatrixEncoding = 4;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DOLBYEX: AVMatrixEncoding = 5;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DOLBYHEADPHONE: AVMatrixEncoding = 6;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_NB: AVMatrixEncoding = 7;
pub type AVMatrixEncoding = u32;
extern "C" {
    pub fn av_get_channel_layout(name: *const ::std::os::raw::c_char) -> u64;
}
extern "C" {
    pub fn av_get_channel_layout_string(
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        channel_layout: u64,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBPrint {
    _unused: [u8; 0],
}
extern "C" {
    pub fn av_bprint_channel_layout(
        bp: *mut AVBPrint,
        nb_channels: ::std::os::raw::c_int,
        channel_layout: u64,
    );
}
extern "C" {
    pub fn av_get_channel_layout_nb_channels(channel_layout: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_get_default_channel_layout(nb_channels: ::std::os::raw::c_int) -> i64;
}
extern "C" {
    pub fn av_get_channel_layout_channel_index(
        channel_layout: u64,
        channel: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_channel_layout_extract_channel(
        channel_layout: u64,
        index: ::std::os::raw::c_int,
    ) -> u64;
}
extern "C" {
    pub fn av_get_channel_name(channel: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_get_channel_description(channel: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_get_standard_channel_layout(
        index: ::std::os::raw::c_uint,
        layout: *mut u64,
        name: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDictionaryEntry {
    pub key: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDictionary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn av_dict_get(
        m: *const AVDictionary,
        key: *const ::std::os::raw::c_char,
        prev: *const AVDictionaryEntry,
        flags: ::std::os::raw::c_int,
    ) -> *mut AVDictionaryEntry;
}
extern "C" {
    pub fn av_dict_count(m: *const AVDictionary) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_dict_set(
        pm: *mut *mut AVDictionary,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_dict_set_int(
        pm: *mut *mut AVDictionary,
        key: *const ::std::os::raw::c_char,
        value: i64,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_dict_parse_string(
        pm: *mut *mut AVDictionary,
        str: *const ::std::os::raw::c_char,
        key_val_sep: *const ::std::os::raw::c_char,
        pairs_sep: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_dict_copy(
        dst: *mut *mut AVDictionary,
        src: *const AVDictionary,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_dict_free(m: *mut *mut AVDictionary);
}
extern "C" {
    pub fn av_dict_get_string(
        m: *const AVDictionary,
        buffer: *mut *mut ::std::os::raw::c_char,
        key_val_sep: ::std::os::raw::c_char,
        pairs_sep: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub const AVFrameSideDataType_AV_FRAME_DATA_PANSCAN: AVFrameSideDataType = 0;
pub const AVFrameSideDataType_AV_FRAME_DATA_A53_CC: AVFrameSideDataType = 1;
pub const AVFrameSideDataType_AV_FRAME_DATA_STEREO3D: AVFrameSideDataType = 2;
pub const AVFrameSideDataType_AV_FRAME_DATA_MATRIXENCODING: AVFrameSideDataType = 3;
pub const AVFrameSideDataType_AV_FRAME_DATA_DOWNMIX_INFO: AVFrameSideDataType = 4;
pub const AVFrameSideDataType_AV_FRAME_DATA_REPLAYGAIN: AVFrameSideDataType = 5;
pub const AVFrameSideDataType_AV_FRAME_DATA_DISPLAYMATRIX: AVFrameSideDataType = 6;
pub const AVFrameSideDataType_AV_FRAME_DATA_AFD: AVFrameSideDataType = 7;
pub const AVFrameSideDataType_AV_FRAME_DATA_MOTION_VECTORS: AVFrameSideDataType = 8;
pub const AVFrameSideDataType_AV_FRAME_DATA_SKIP_SAMPLES: AVFrameSideDataType = 9;
pub const AVFrameSideDataType_AV_FRAME_DATA_AUDIO_SERVICE_TYPE: AVFrameSideDataType = 10;
pub const AVFrameSideDataType_AV_FRAME_DATA_MASTERING_DISPLAY_METADATA: AVFrameSideDataType = 11;
pub const AVFrameSideDataType_AV_FRAME_DATA_GOP_TIMECODE: AVFrameSideDataType = 12;
pub type AVFrameSideDataType = u32;
pub const AVActiveFormatDescription_AV_AFD_SAME: AVActiveFormatDescription = 8;
pub const AVActiveFormatDescription_AV_AFD_4_3: AVActiveFormatDescription = 9;
pub const AVActiveFormatDescription_AV_AFD_16_9: AVActiveFormatDescription = 10;
pub const AVActiveFormatDescription_AV_AFD_14_9: AVActiveFormatDescription = 11;
pub const AVActiveFormatDescription_AV_AFD_4_3_SP_14_9: AVActiveFormatDescription = 13;
pub const AVActiveFormatDescription_AV_AFD_16_9_SP_14_9: AVActiveFormatDescription = 14;
pub const AVActiveFormatDescription_AV_AFD_SP_4_3: AVActiveFormatDescription = 15;
pub type AVActiveFormatDescription = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFrameSideData {
    pub type_: AVFrameSideDataType,
    pub data: *mut u8,
    pub size: ::std::os::raw::c_int,
    pub metadata: *mut AVDictionary,
    pub buf: *mut AVBufferRef,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFrame {
    pub data: [*mut u8; 8usize],
    pub linesize: [::std::os::raw::c_int; 8usize],
    pub extended_data: *mut *mut u8,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub nb_samples: ::std::os::raw::c_int,
    pub format: ::std::os::raw::c_int,
    pub key_frame: ::std::os::raw::c_int,
    pub pict_type: AVPictureType,
    pub sample_aspect_ratio: AVRational,
    pub pts: i64,
    pub pkt_pts: i64,
    pub pkt_dts: i64,
    pub coded_picture_number: ::std::os::raw::c_int,
    pub display_picture_number: ::std::os::raw::c_int,
    pub quality: ::std::os::raw::c_int,
    pub opaque: *mut ::std::os::raw::c_void,
    pub error: [u64; 8usize],
    pub repeat_pict: ::std::os::raw::c_int,
    pub interlaced_frame: ::std::os::raw::c_int,
    pub top_field_first: ::std::os::raw::c_int,
    pub palette_has_changed: ::std::os::raw::c_int,
    pub reordered_opaque: i64,
    pub sample_rate: ::std::os::raw::c_int,
    pub channel_layout: u64,
    pub buf: [*mut AVBufferRef; 8usize],
    pub extended_buf: *mut *mut AVBufferRef,
    pub nb_extended_buf: ::std::os::raw::c_int,
    pub side_data: *mut *mut AVFrameSideData,
    pub nb_side_data: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
    pub color_range: AVColorRange,
    pub color_primaries: AVColorPrimaries,
    pub color_trc: AVColorTransferCharacteristic,
    pub colorspace: AVColorSpace,
    pub chroma_location: AVChromaLocation,
    pub best_effort_timestamp: i64,
    pub pkt_pos: i64,
    pub pkt_duration: i64,
    pub metadata: *mut AVDictionary,
    pub decode_error_flags: ::std::os::raw::c_int,
    pub channels: ::std::os::raw::c_int,
    pub pkt_size: ::std::os::raw::c_int,
    pub qscale_table: *mut i8,
    pub qstride: ::std::os::raw::c_int,
    pub qscale_type: ::std::os::raw::c_int,
    pub qp_table_buf: *mut AVBufferRef,
    pub hw_frames_ctx: *mut AVBufferRef,
}
extern "C" {
    pub fn av_frame_get_best_effort_timestamp(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_best_effort_timestamp(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_pkt_duration(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_pkt_duration(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_pkt_pos(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_pkt_pos(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_channel_layout(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_channel_layout(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_channels(frame: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_set_channels(frame: *mut AVFrame, val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_frame_get_sample_rate(frame: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_set_sample_rate(frame: *mut AVFrame, val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_frame_get_metadata(frame: *const AVFrame) -> *mut AVDictionary;
}
extern "C" {
    pub fn av_frame_set_metadata(frame: *mut AVFrame, val: *mut AVDictionary);
}
extern "C" {
    pub fn av_frame_get_decode_error_flags(frame: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_set_decode_error_flags(frame: *mut AVFrame, val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_frame_get_pkt_size(frame: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_set_pkt_size(frame: *mut AVFrame, val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn avpriv_frame_get_metadatap(frame: *mut AVFrame) -> *mut *mut AVDictionary;
}
extern "C" {
    pub fn av_frame_get_qp_table(
        f: *mut AVFrame,
        stride: *mut ::std::os::raw::c_int,
        type_: *mut ::std::os::raw::c_int,
    ) -> *mut i8;
}
extern "C" {
    pub fn av_frame_set_qp_table(
        f: *mut AVFrame,
        buf: *mut AVBufferRef,
        stride: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_get_colorspace(frame: *const AVFrame) -> AVColorSpace;
}
extern "C" {
    pub fn av_frame_set_colorspace(frame: *mut AVFrame, val: AVColorSpace);
}
extern "C" {
    pub fn av_frame_get_color_range(frame: *const AVFrame) -> AVColorRange;
}
extern "C" {
    pub fn av_frame_set_color_range(frame: *mut AVFrame, val: AVColorRange);
}
extern "C" {
    pub fn av_get_colorspace_name(val: AVColorSpace) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_frame_alloc() -> *mut AVFrame;
}
extern "C" {
    pub fn av_frame_free(frame: *mut *mut AVFrame);
}
extern "C" {
    pub fn av_frame_ref(dst: *mut AVFrame, src: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_clone(src: *const AVFrame) -> *mut AVFrame;
}
extern "C" {
    pub fn av_frame_unref(frame: *mut AVFrame);
}
extern "C" {
    pub fn av_frame_move_ref(dst: *mut AVFrame, src: *mut AVFrame);
}
extern "C" {
    pub fn av_frame_get_buffer(
        frame: *mut AVFrame,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_is_writable(frame: *mut AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_make_writable(frame: *mut AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_copy(dst: *mut AVFrame, src: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_copy_props(dst: *mut AVFrame, src: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_get_plane_buffer(
        frame: *mut AVFrame,
        plane: ::std::os::raw::c_int,
    ) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_frame_new_side_data(
        frame: *mut AVFrame,
        type_: AVFrameSideDataType,
        size: ::std::os::raw::c_int,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    pub fn av_frame_get_side_data(
        frame: *const AVFrame,
        type_: AVFrameSideDataType,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    pub fn av_frame_remove_side_data(frame: *mut AVFrame, type_: AVFrameSideDataType);
}
extern "C" {
    pub fn av_frame_side_data_name(type_: AVFrameSideDataType) -> *const ::std::os::raw::c_char;
}
pub const AVCodecID_AV_CODEC_ID_NONE: AVCodecID = 0;
pub const AVCodecID_AV_CODEC_ID_MPEG1VIDEO: AVCodecID = 1;
pub const AVCodecID_AV_CODEC_ID_MPEG2VIDEO: AVCodecID = 2;
pub const AVCodecID_AV_CODEC_ID_MPEG2VIDEO_XVMC: AVCodecID = 3;
pub const AVCodecID_AV_CODEC_ID_H261: AVCodecID = 4;
pub const AVCodecID_AV_CODEC_ID_H263: AVCodecID = 5;
pub const AVCodecID_AV_CODEC_ID_RV10: AVCodecID = 6;
pub const AVCodecID_AV_CODEC_ID_RV20: AVCodecID = 7;
pub const AVCodecID_AV_CODEC_ID_MJPEG: AVCodecID = 8;
pub const AVCodecID_AV_CODEC_ID_MJPEGB: AVCodecID = 9;
pub const AVCodecID_AV_CODEC_ID_LJPEG: AVCodecID = 10;
pub const AVCodecID_AV_CODEC_ID_SP5X: AVCodecID = 11;
pub const AVCodecID_AV_CODEC_ID_JPEGLS: AVCodecID = 12;
pub const AVCodecID_AV_CODEC_ID_MPEG4: AVCodecID = 13;
pub const AVCodecID_AV_CODEC_ID_RAWVIDEO: AVCodecID = 14;
pub const AVCodecID_AV_CODEC_ID_MSMPEG4V1: AVCodecID = 15;
pub const AVCodecID_AV_CODEC_ID_MSMPEG4V2: AVCodecID = 16;
pub const AVCodecID_AV_CODEC_ID_MSMPEG4V3: AVCodecID = 17;
pub const AVCodecID_AV_CODEC_ID_WMV1: AVCodecID = 18;
pub const AVCodecID_AV_CODEC_ID_WMV2: AVCodecID = 19;
pub const AVCodecID_AV_CODEC_ID_H263P: AVCodecID = 20;
pub const AVCodecID_AV_CODEC_ID_H263I: AVCodecID = 21;
pub const AVCodecID_AV_CODEC_ID_FLV1: AVCodecID = 22;
pub const AVCodecID_AV_CODEC_ID_SVQ1: AVCodecID = 23;
pub const AVCodecID_AV_CODEC_ID_SVQ3: AVCodecID = 24;
pub const AVCodecID_AV_CODEC_ID_DVVIDEO: AVCodecID = 25;
pub const AVCodecID_AV_CODEC_ID_HUFFYUV: AVCodecID = 26;
pub const AVCodecID_AV_CODEC_ID_CYUV: AVCodecID = 27;
pub const AVCodecID_AV_CODEC_ID_H264: AVCodecID = 28;
pub const AVCodecID_AV_CODEC_ID_INDEO3: AVCodecID = 29;
pub const AVCodecID_AV_CODEC_ID_VP3: AVCodecID = 30;
pub const AVCodecID_AV_CODEC_ID_THEORA: AVCodecID = 31;
pub const AVCodecID_AV_CODEC_ID_ASV1: AVCodecID = 32;
pub const AVCodecID_AV_CODEC_ID_ASV2: AVCodecID = 33;
pub const AVCodecID_AV_CODEC_ID_FFV1: AVCodecID = 34;
pub const AVCodecID_AV_CODEC_ID_4XM: AVCodecID = 35;
pub const AVCodecID_AV_CODEC_ID_VCR1: AVCodecID = 36;
pub const AVCodecID_AV_CODEC_ID_CLJR: AVCodecID = 37;
pub const AVCodecID_AV_CODEC_ID_MDEC: AVCodecID = 38;
pub const AVCodecID_AV_CODEC_ID_ROQ: AVCodecID = 39;
pub const AVCodecID_AV_CODEC_ID_INTERPLAY_VIDEO: AVCodecID = 40;
pub const AVCodecID_AV_CODEC_ID_XAN_WC3: AVCodecID = 41;
pub const AVCodecID_AV_CODEC_ID_XAN_WC4: AVCodecID = 42;
pub const AVCodecID_AV_CODEC_ID_RPZA: AVCodecID = 43;
pub const AVCodecID_AV_CODEC_ID_CINEPAK: AVCodecID = 44;
pub const AVCodecID_AV_CODEC_ID_WS_VQA: AVCodecID = 45;
pub const AVCodecID_AV_CODEC_ID_MSRLE: AVCodecID = 46;
pub const AVCodecID_AV_CODEC_ID_MSVIDEO1: AVCodecID = 47;
pub const AVCodecID_AV_CODEC_ID_IDCIN: AVCodecID = 48;
pub const AVCodecID_AV_CODEC_ID_8BPS: AVCodecID = 49;
pub const AVCodecID_AV_CODEC_ID_SMC: AVCodecID = 50;
pub const AVCodecID_AV_CODEC_ID_FLIC: AVCodecID = 51;
pub const AVCodecID_AV_CODEC_ID_TRUEMOTION1: AVCodecID = 52;
pub const AVCodecID_AV_CODEC_ID_VMDVIDEO: AVCodecID = 53;
pub const AVCodecID_AV_CODEC_ID_MSZH: AVCodecID = 54;
pub const AVCodecID_AV_CODEC_ID_ZLIB: AVCodecID = 55;
pub const AVCodecID_AV_CODEC_ID_QTRLE: AVCodecID = 56;
pub const AVCodecID_AV_CODEC_ID_TSCC: AVCodecID = 57;
pub const AVCodecID_AV_CODEC_ID_ULTI: AVCodecID = 58;
pub const AVCodecID_AV_CODEC_ID_QDRAW: AVCodecID = 59;
pub const AVCodecID_AV_CODEC_ID_VIXL: AVCodecID = 60;
pub const AVCodecID_AV_CODEC_ID_QPEG: AVCodecID = 61;
pub const AVCodecID_AV_CODEC_ID_PNG: AVCodecID = 62;
pub const AVCodecID_AV_CODEC_ID_PPM: AVCodecID = 63;
pub const AVCodecID_AV_CODEC_ID_PBM: AVCodecID = 64;
pub const AVCodecID_AV_CODEC_ID_PGM: AVCodecID = 65;
pub const AVCodecID_AV_CODEC_ID_PGMYUV: AVCodecID = 66;
pub const AVCodecID_AV_CODEC_ID_PAM: AVCodecID = 67;
pub const AVCodecID_AV_CODEC_ID_FFVHUFF: AVCodecID = 68;
pub const AVCodecID_AV_CODEC_ID_RV30: AVCodecID = 69;
pub const AVCodecID_AV_CODEC_ID_RV40: AVCodecID = 70;
pub const AVCodecID_AV_CODEC_ID_VC1: AVCodecID = 71;
pub const AVCodecID_AV_CODEC_ID_WMV3: AVCodecID = 72;
pub const AVCodecID_AV_CODEC_ID_LOCO: AVCodecID = 73;
pub const AVCodecID_AV_CODEC_ID_WNV1: AVCodecID = 74;
pub const AVCodecID_AV_CODEC_ID_AASC: AVCodecID = 75;
pub const AVCodecID_AV_CODEC_ID_INDEO2: AVCodecID = 76;
pub const AVCodecID_AV_CODEC_ID_FRAPS: AVCodecID = 77;
pub const AVCodecID_AV_CODEC_ID_TRUEMOTION2: AVCodecID = 78;
pub const AVCodecID_AV_CODEC_ID_BMP: AVCodecID = 79;
pub const AVCodecID_AV_CODEC_ID_CSCD: AVCodecID = 80;
pub const AVCodecID_AV_CODEC_ID_MMVIDEO: AVCodecID = 81;
pub const AVCodecID_AV_CODEC_ID_ZMBV: AVCodecID = 82;
pub const AVCodecID_AV_CODEC_ID_AVS: AVCodecID = 83;
pub const AVCodecID_AV_CODEC_ID_SMACKVIDEO: AVCodecID = 84;
pub const AVCodecID_AV_CODEC_ID_NUV: AVCodecID = 85;
pub const AVCodecID_AV_CODEC_ID_KMVC: AVCodecID = 86;
pub const AVCodecID_AV_CODEC_ID_FLASHSV: AVCodecID = 87;
pub const AVCodecID_AV_CODEC_ID_CAVS: AVCodecID = 88;
pub const AVCodecID_AV_CODEC_ID_JPEG2000: AVCodecID = 89;
pub const AVCodecID_AV_CODEC_ID_VMNC: AVCodecID = 90;
pub const AVCodecID_AV_CODEC_ID_VP5: AVCodecID = 91;
pub const AVCodecID_AV_CODEC_ID_VP6: AVCodecID = 92;
pub const AVCodecID_AV_CODEC_ID_VP6F: AVCodecID = 93;
pub const AVCodecID_AV_CODEC_ID_TARGA: AVCodecID = 94;
pub const AVCodecID_AV_CODEC_ID_DSICINVIDEO: AVCodecID = 95;
pub const AVCodecID_AV_CODEC_ID_TIERTEXSEQVIDEO: AVCodecID = 96;
pub const AVCodecID_AV_CODEC_ID_TIFF: AVCodecID = 97;
pub const AVCodecID_AV_CODEC_ID_GIF: AVCodecID = 98;
pub const AVCodecID_AV_CODEC_ID_DXA: AVCodecID = 99;
pub const AVCodecID_AV_CODEC_ID_DNXHD: AVCodecID = 100;
pub const AVCodecID_AV_CODEC_ID_THP: AVCodecID = 101;
pub const AVCodecID_AV_CODEC_ID_SGI: AVCodecID = 102;
pub const AVCodecID_AV_CODEC_ID_C93: AVCodecID = 103;
pub const AVCodecID_AV_CODEC_ID_BETHSOFTVID: AVCodecID = 104;
pub const AVCodecID_AV_CODEC_ID_PTX: AVCodecID = 105;
pub const AVCodecID_AV_CODEC_ID_TXD: AVCodecID = 106;
pub const AVCodecID_AV_CODEC_ID_VP6A: AVCodecID = 107;
pub const AVCodecID_AV_CODEC_ID_AMV: AVCodecID = 108;
pub const AVCodecID_AV_CODEC_ID_VB: AVCodecID = 109;
pub const AVCodecID_AV_CODEC_ID_PCX: AVCodecID = 110;
pub const AVCodecID_AV_CODEC_ID_SUNRAST: AVCodecID = 111;
pub const AVCodecID_AV_CODEC_ID_INDEO4: AVCodecID = 112;
pub const AVCodecID_AV_CODEC_ID_INDEO5: AVCodecID = 113;
pub const AVCodecID_AV_CODEC_ID_MIMIC: AVCodecID = 114;
pub const AVCodecID_AV_CODEC_ID_RL2: AVCodecID = 115;
pub const AVCodecID_AV_CODEC_ID_ESCAPE124: AVCodecID = 116;
pub const AVCodecID_AV_CODEC_ID_DIRAC: AVCodecID = 117;
pub const AVCodecID_AV_CODEC_ID_BFI: AVCodecID = 118;
pub const AVCodecID_AV_CODEC_ID_CMV: AVCodecID = 119;
pub const AVCodecID_AV_CODEC_ID_MOTIONPIXELS: AVCodecID = 120;
pub const AVCodecID_AV_CODEC_ID_TGV: AVCodecID = 121;
pub const AVCodecID_AV_CODEC_ID_TGQ: AVCodecID = 122;
pub const AVCodecID_AV_CODEC_ID_TQI: AVCodecID = 123;
pub const AVCodecID_AV_CODEC_ID_AURA: AVCodecID = 124;
pub const AVCodecID_AV_CODEC_ID_AURA2: AVCodecID = 125;
pub const AVCodecID_AV_CODEC_ID_V210X: AVCodecID = 126;
pub const AVCodecID_AV_CODEC_ID_TMV: AVCodecID = 127;
pub const AVCodecID_AV_CODEC_ID_V210: AVCodecID = 128;
pub const AVCodecID_AV_CODEC_ID_DPX: AVCodecID = 129;
pub const AVCodecID_AV_CODEC_ID_MAD: AVCodecID = 130;
pub const AVCodecID_AV_CODEC_ID_FRWU: AVCodecID = 131;
pub const AVCodecID_AV_CODEC_ID_FLASHSV2: AVCodecID = 132;
pub const AVCodecID_AV_CODEC_ID_CDGRAPHICS: AVCodecID = 133;
pub const AVCodecID_AV_CODEC_ID_R210: AVCodecID = 134;
pub const AVCodecID_AV_CODEC_ID_ANM: AVCodecID = 135;
pub const AVCodecID_AV_CODEC_ID_BINKVIDEO: AVCodecID = 136;
pub const AVCodecID_AV_CODEC_ID_IFF_ILBM: AVCodecID = 137;
pub const AVCodecID_AV_CODEC_ID_KGV1: AVCodecID = 138;
pub const AVCodecID_AV_CODEC_ID_YOP: AVCodecID = 139;
pub const AVCodecID_AV_CODEC_ID_VP8: AVCodecID = 140;
pub const AVCodecID_AV_CODEC_ID_PICTOR: AVCodecID = 141;
pub const AVCodecID_AV_CODEC_ID_ANSI: AVCodecID = 142;
pub const AVCodecID_AV_CODEC_ID_A64_MULTI: AVCodecID = 143;
pub const AVCodecID_AV_CODEC_ID_A64_MULTI5: AVCodecID = 144;
pub const AVCodecID_AV_CODEC_ID_R10K: AVCodecID = 145;
pub const AVCodecID_AV_CODEC_ID_MXPEG: AVCodecID = 146;
pub const AVCodecID_AV_CODEC_ID_LAGARITH: AVCodecID = 147;
pub const AVCodecID_AV_CODEC_ID_PRORES: AVCodecID = 148;
pub const AVCodecID_AV_CODEC_ID_JV: AVCodecID = 149;
pub const AVCodecID_AV_CODEC_ID_DFA: AVCodecID = 150;
pub const AVCodecID_AV_CODEC_ID_WMV3IMAGE: AVCodecID = 151;
pub const AVCodecID_AV_CODEC_ID_VC1IMAGE: AVCodecID = 152;
pub const AVCodecID_AV_CODEC_ID_UTVIDEO: AVCodecID = 153;
pub const AVCodecID_AV_CODEC_ID_BMV_VIDEO: AVCodecID = 154;
pub const AVCodecID_AV_CODEC_ID_VBLE: AVCodecID = 155;
pub const AVCodecID_AV_CODEC_ID_DXTORY: AVCodecID = 156;
pub const AVCodecID_AV_CODEC_ID_V410: AVCodecID = 157;
pub const AVCodecID_AV_CODEC_ID_XWD: AVCodecID = 158;
pub const AVCodecID_AV_CODEC_ID_CDXL: AVCodecID = 159;
pub const AVCodecID_AV_CODEC_ID_XBM: AVCodecID = 160;
pub const AVCodecID_AV_CODEC_ID_ZEROCODEC: AVCodecID = 161;
pub const AVCodecID_AV_CODEC_ID_MSS1: AVCodecID = 162;
pub const AVCodecID_AV_CODEC_ID_MSA1: AVCodecID = 163;
pub const AVCodecID_AV_CODEC_ID_TSCC2: AVCodecID = 164;
pub const AVCodecID_AV_CODEC_ID_MTS2: AVCodecID = 165;
pub const AVCodecID_AV_CODEC_ID_CLLC: AVCodecID = 166;
pub const AVCodecID_AV_CODEC_ID_MSS2: AVCodecID = 167;
pub const AVCodecID_AV_CODEC_ID_VP9: AVCodecID = 168;
pub const AVCodecID_AV_CODEC_ID_AIC: AVCodecID = 169;
pub const AVCodecID_AV_CODEC_ID_ESCAPE130: AVCodecID = 170;
pub const AVCodecID_AV_CODEC_ID_G2M: AVCodecID = 171;
pub const AVCodecID_AV_CODEC_ID_WEBP: AVCodecID = 172;
pub const AVCodecID_AV_CODEC_ID_HNM4_VIDEO: AVCodecID = 173;
pub const AVCodecID_AV_CODEC_ID_HEVC: AVCodecID = 174;
pub const AVCodecID_AV_CODEC_ID_FIC: AVCodecID = 175;
pub const AVCodecID_AV_CODEC_ID_ALIAS_PIX: AVCodecID = 176;
pub const AVCodecID_AV_CODEC_ID_BRENDER_PIX: AVCodecID = 177;
pub const AVCodecID_AV_CODEC_ID_PAF_VIDEO: AVCodecID = 178;
pub const AVCodecID_AV_CODEC_ID_EXR: AVCodecID = 179;
pub const AVCodecID_AV_CODEC_ID_VP7: AVCodecID = 180;
pub const AVCodecID_AV_CODEC_ID_SANM: AVCodecID = 181;
pub const AVCodecID_AV_CODEC_ID_SGIRLE: AVCodecID = 182;
pub const AVCodecID_AV_CODEC_ID_MVC1: AVCodecID = 183;
pub const AVCodecID_AV_CODEC_ID_MVC2: AVCodecID = 184;
pub const AVCodecID_AV_CODEC_ID_HQX: AVCodecID = 185;
pub const AVCodecID_AV_CODEC_ID_TDSC: AVCodecID = 186;
pub const AVCodecID_AV_CODEC_ID_HQ_HQA: AVCodecID = 187;
pub const AVCodecID_AV_CODEC_ID_HAP: AVCodecID = 188;
pub const AVCodecID_AV_CODEC_ID_DDS: AVCodecID = 189;
pub const AVCodecID_AV_CODEC_ID_DXV: AVCodecID = 190;
pub const AVCodecID_AV_CODEC_ID_SCREENPRESSO: AVCodecID = 191;
pub const AVCodecID_AV_CODEC_ID_RSCC: AVCodecID = 192;
pub const AVCodecID_AV_CODEC_ID_Y41P: AVCodecID = 32768;
pub const AVCodecID_AV_CODEC_ID_AVRP: AVCodecID = 32769;
pub const AVCodecID_AV_CODEC_ID_012V: AVCodecID = 32770;
pub const AVCodecID_AV_CODEC_ID_AVUI: AVCodecID = 32771;
pub const AVCodecID_AV_CODEC_ID_AYUV: AVCodecID = 32772;
pub const AVCodecID_AV_CODEC_ID_TARGA_Y216: AVCodecID = 32773;
pub const AVCodecID_AV_CODEC_ID_V308: AVCodecID = 32774;
pub const AVCodecID_AV_CODEC_ID_V408: AVCodecID = 32775;
pub const AVCodecID_AV_CODEC_ID_YUV4: AVCodecID = 32776;
pub const AVCodecID_AV_CODEC_ID_AVRN: AVCodecID = 32777;
pub const AVCodecID_AV_CODEC_ID_CPIA: AVCodecID = 32778;
pub const AVCodecID_AV_CODEC_ID_XFACE: AVCodecID = 32779;
pub const AVCodecID_AV_CODEC_ID_SNOW: AVCodecID = 32780;
pub const AVCodecID_AV_CODEC_ID_SMVJPEG: AVCodecID = 32781;
pub const AVCodecID_AV_CODEC_ID_APNG: AVCodecID = 32782;
pub const AVCodecID_AV_CODEC_ID_DAALA: AVCodecID = 32783;
pub const AVCodecID_AV_CODEC_ID_CFHD: AVCodecID = 32784;
pub const AVCodecID_AV_CODEC_ID_TRUEMOTION2RT: AVCodecID = 32785;
pub const AVCodecID_AV_CODEC_ID_M101: AVCodecID = 32786;
pub const AVCodecID_AV_CODEC_ID_MAGICYUV: AVCodecID = 32787;
pub const AVCodecID_AV_CODEC_ID_SHEERVIDEO: AVCodecID = 32788;
pub const AVCodecID_AV_CODEC_ID_YLC: AVCodecID = 32789;
pub const AVCodecID_AV_CODEC_ID_FIRST_AUDIO: AVCodecID = 65536;
pub const AVCodecID_AV_CODEC_ID_PCM_S16LE: AVCodecID = 65536;
pub const AVCodecID_AV_CODEC_ID_PCM_S16BE: AVCodecID = 65537;
pub const AVCodecID_AV_CODEC_ID_PCM_U16LE: AVCodecID = 65538;
pub const AVCodecID_AV_CODEC_ID_PCM_U16BE: AVCodecID = 65539;
pub const AVCodecID_AV_CODEC_ID_PCM_S8: AVCodecID = 65540;
pub const AVCodecID_AV_CODEC_ID_PCM_U8: AVCodecID = 65541;
pub const AVCodecID_AV_CODEC_ID_PCM_MULAW: AVCodecID = 65542;
pub const AVCodecID_AV_CODEC_ID_PCM_ALAW: AVCodecID = 65543;
pub const AVCodecID_AV_CODEC_ID_PCM_S32LE: AVCodecID = 65544;
pub const AVCodecID_AV_CODEC_ID_PCM_S32BE: AVCodecID = 65545;
pub const AVCodecID_AV_CODEC_ID_PCM_U32LE: AVCodecID = 65546;
pub const AVCodecID_AV_CODEC_ID_PCM_U32BE: AVCodecID = 65547;
pub const AVCodecID_AV_CODEC_ID_PCM_S24LE: AVCodecID = 65548;
pub const AVCodecID_AV_CODEC_ID_PCM_S24BE: AVCodecID = 65549;
pub const AVCodecID_AV_CODEC_ID_PCM_U24LE: AVCodecID = 65550;
pub const AVCodecID_AV_CODEC_ID_PCM_U24BE: AVCodecID = 65551;
pub const AVCodecID_AV_CODEC_ID_PCM_S24DAUD: AVCodecID = 65552;
pub const AVCodecID_AV_CODEC_ID_PCM_ZORK: AVCodecID = 65553;
pub const AVCodecID_AV_CODEC_ID_PCM_S16LE_PLANAR: AVCodecID = 65554;
pub const AVCodecID_AV_CODEC_ID_PCM_DVD: AVCodecID = 65555;
pub const AVCodecID_AV_CODEC_ID_PCM_F32BE: AVCodecID = 65556;
pub const AVCodecID_AV_CODEC_ID_PCM_F32LE: AVCodecID = 65557;
pub const AVCodecID_AV_CODEC_ID_PCM_F64BE: AVCodecID = 65558;
pub const AVCodecID_AV_CODEC_ID_PCM_F64LE: AVCodecID = 65559;
pub const AVCodecID_AV_CODEC_ID_PCM_BLURAY: AVCodecID = 65560;
pub const AVCodecID_AV_CODEC_ID_PCM_LXF: AVCodecID = 65561;
pub const AVCodecID_AV_CODEC_ID_S302M: AVCodecID = 65562;
pub const AVCodecID_AV_CODEC_ID_PCM_S8_PLANAR: AVCodecID = 65563;
pub const AVCodecID_AV_CODEC_ID_PCM_S24LE_PLANAR: AVCodecID = 65564;
pub const AVCodecID_AV_CODEC_ID_PCM_S32LE_PLANAR: AVCodecID = 65565;
pub const AVCodecID_AV_CODEC_ID_PCM_S16BE_PLANAR: AVCodecID = 65566;
pub const AVCodecID_AV_CODEC_ID_PCM_S64LE: AVCodecID = 67584;
pub const AVCodecID_AV_CODEC_ID_PCM_S64BE: AVCodecID = 67585;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_QT: AVCodecID = 69632;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_WAV: AVCodecID = 69633;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_DK3: AVCodecID = 69634;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_DK4: AVCodecID = 69635;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_WS: AVCodecID = 69636;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_SMJPEG: AVCodecID = 69637;
pub const AVCodecID_AV_CODEC_ID_ADPCM_MS: AVCodecID = 69638;
pub const AVCodecID_AV_CODEC_ID_ADPCM_4XM: AVCodecID = 69639;
pub const AVCodecID_AV_CODEC_ID_ADPCM_XA: AVCodecID = 69640;
pub const AVCodecID_AV_CODEC_ID_ADPCM_ADX: AVCodecID = 69641;
pub const AVCodecID_AV_CODEC_ID_ADPCM_EA: AVCodecID = 69642;
pub const AVCodecID_AV_CODEC_ID_ADPCM_G726: AVCodecID = 69643;
pub const AVCodecID_AV_CODEC_ID_ADPCM_CT: AVCodecID = 69644;
pub const AVCodecID_AV_CODEC_ID_ADPCM_SWF: AVCodecID = 69645;
pub const AVCodecID_AV_CODEC_ID_ADPCM_YAMAHA: AVCodecID = 69646;
pub const AVCodecID_AV_CODEC_ID_ADPCM_SBPRO_4: AVCodecID = 69647;
pub const AVCodecID_AV_CODEC_ID_ADPCM_SBPRO_3: AVCodecID = 69648;
pub const AVCodecID_AV_CODEC_ID_ADPCM_SBPRO_2: AVCodecID = 69649;
pub const AVCodecID_AV_CODEC_ID_ADPCM_THP: AVCodecID = 69650;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_AMV: AVCodecID = 69651;
pub const AVCodecID_AV_CODEC_ID_ADPCM_EA_R1: AVCodecID = 69652;
pub const AVCodecID_AV_CODEC_ID_ADPCM_EA_R3: AVCodecID = 69653;
pub const AVCodecID_AV_CODEC_ID_ADPCM_EA_R2: AVCodecID = 69654;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_EA_SEAD: AVCodecID = 69655;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_EA_EACS: AVCodecID = 69656;
pub const AVCodecID_AV_CODEC_ID_ADPCM_EA_XAS: AVCodecID = 69657;
pub const AVCodecID_AV_CODEC_ID_ADPCM_EA_MAXIS_XA: AVCodecID = 69658;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_ISS: AVCodecID = 69659;
pub const AVCodecID_AV_CODEC_ID_ADPCM_G722: AVCodecID = 69660;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_APC: AVCodecID = 69661;
pub const AVCodecID_AV_CODEC_ID_ADPCM_VIMA: AVCodecID = 69662;
pub const AVCodecID_AV_CODEC_ID_VIMA: AVCodecID = 69662;
pub const AVCodecID_AV_CODEC_ID_ADPCM_AFC: AVCodecID = 71680;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_OKI: AVCodecID = 71681;
pub const AVCodecID_AV_CODEC_ID_ADPCM_DTK: AVCodecID = 71682;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_RAD: AVCodecID = 71683;
pub const AVCodecID_AV_CODEC_ID_ADPCM_G726LE: AVCodecID = 71684;
pub const AVCodecID_AV_CODEC_ID_ADPCM_THP_LE: AVCodecID = 71685;
pub const AVCodecID_AV_CODEC_ID_ADPCM_PSX: AVCodecID = 71686;
pub const AVCodecID_AV_CODEC_ID_ADPCM_AICA: AVCodecID = 71687;
pub const AVCodecID_AV_CODEC_ID_ADPCM_IMA_DAT4: AVCodecID = 71688;
pub const AVCodecID_AV_CODEC_ID_ADPCM_MTAF: AVCodecID = 71689;
pub const AVCodecID_AV_CODEC_ID_AMR_NB: AVCodecID = 73728;
pub const AVCodecID_AV_CODEC_ID_AMR_WB: AVCodecID = 73729;
pub const AVCodecID_AV_CODEC_ID_RA_144: AVCodecID = 77824;
pub const AVCodecID_AV_CODEC_ID_RA_288: AVCodecID = 77825;
pub const AVCodecID_AV_CODEC_ID_ROQ_DPCM: AVCodecID = 81920;
pub const AVCodecID_AV_CODEC_ID_INTERPLAY_DPCM: AVCodecID = 81921;
pub const AVCodecID_AV_CODEC_ID_XAN_DPCM: AVCodecID = 81922;
pub const AVCodecID_AV_CODEC_ID_SOL_DPCM: AVCodecID = 81923;
pub const AVCodecID_AV_CODEC_ID_SDX2_DPCM: AVCodecID = 83968;
pub const AVCodecID_AV_CODEC_ID_MP2: AVCodecID = 86016;
pub const AVCodecID_AV_CODEC_ID_MP3: AVCodecID = 86017;
pub const AVCodecID_AV_CODEC_ID_AAC: AVCodecID = 86018;
pub const AVCodecID_AV_CODEC_ID_AC3: AVCodecID = 86019;
pub const AVCodecID_AV_CODEC_ID_DTS: AVCodecID = 86020;
pub const AVCodecID_AV_CODEC_ID_VORBIS: AVCodecID = 86021;
pub const AVCodecID_AV_CODEC_ID_DVAUDIO: AVCodecID = 86022;
pub const AVCodecID_AV_CODEC_ID_WMAV1: AVCodecID = 86023;
pub const AVCodecID_AV_CODEC_ID_WMAV2: AVCodecID = 86024;
pub const AVCodecID_AV_CODEC_ID_MACE3: AVCodecID = 86025;
pub const AVCodecID_AV_CODEC_ID_MACE6: AVCodecID = 86026;
pub const AVCodecID_AV_CODEC_ID_VMDAUDIO: AVCodecID = 86027;
pub const AVCodecID_AV_CODEC_ID_FLAC: AVCodecID = 86028;
pub const AVCodecID_AV_CODEC_ID_MP3ADU: AVCodecID = 86029;
pub const AVCodecID_AV_CODEC_ID_MP3ON4: AVCodecID = 86030;
pub const AVCodecID_AV_CODEC_ID_SHORTEN: AVCodecID = 86031;
pub const AVCodecID_AV_CODEC_ID_ALAC: AVCodecID = 86032;
pub const AVCodecID_AV_CODEC_ID_WESTWOOD_SND1: AVCodecID = 86033;
pub const AVCodecID_AV_CODEC_ID_GSM: AVCodecID = 86034;
pub const AVCodecID_AV_CODEC_ID_QDM2: AVCodecID = 86035;
pub const AVCodecID_AV_CODEC_ID_COOK: AVCodecID = 86036;
pub const AVCodecID_AV_CODEC_ID_TRUESPEECH: AVCodecID = 86037;
pub const AVCodecID_AV_CODEC_ID_TTA: AVCodecID = 86038;
pub const AVCodecID_AV_CODEC_ID_SMACKAUDIO: AVCodecID = 86039;
pub const AVCodecID_AV_CODEC_ID_QCELP: AVCodecID = 86040;
pub const AVCodecID_AV_CODEC_ID_WAVPACK: AVCodecID = 86041;
pub const AVCodecID_AV_CODEC_ID_DSICINAUDIO: AVCodecID = 86042;
pub const AVCodecID_AV_CODEC_ID_IMC: AVCodecID = 86043;
pub const AVCodecID_AV_CODEC_ID_MUSEPACK7: AVCodecID = 86044;
pub const AVCodecID_AV_CODEC_ID_MLP: AVCodecID = 86045;
pub const AVCodecID_AV_CODEC_ID_GSM_MS: AVCodecID = 86046;
pub const AVCodecID_AV_CODEC_ID_ATRAC3: AVCodecID = 86047;
pub const AVCodecID_AV_CODEC_ID_VOXWARE: AVCodecID = 86048;
pub const AVCodecID_AV_CODEC_ID_APE: AVCodecID = 86049;
pub const AVCodecID_AV_CODEC_ID_NELLYMOSER: AVCodecID = 86050;
pub const AVCodecID_AV_CODEC_ID_MUSEPACK8: AVCodecID = 86051;
pub const AVCodecID_AV_CODEC_ID_SPEEX: AVCodecID = 86052;
pub const AVCodecID_AV_CODEC_ID_WMAVOICE: AVCodecID = 86053;
pub const AVCodecID_AV_CODEC_ID_WMAPRO: AVCodecID = 86054;
pub const AVCodecID_AV_CODEC_ID_WMALOSSLESS: AVCodecID = 86055;
pub const AVCodecID_AV_CODEC_ID_ATRAC3P: AVCodecID = 86056;
pub const AVCodecID_AV_CODEC_ID_EAC3: AVCodecID = 86057;
pub const AVCodecID_AV_CODEC_ID_SIPR: AVCodecID = 86058;
pub const AVCodecID_AV_CODEC_ID_MP1: AVCodecID = 86059;
pub const AVCodecID_AV_CODEC_ID_TWINVQ: AVCodecID = 86060;
pub const AVCodecID_AV_CODEC_ID_TRUEHD: AVCodecID = 86061;
pub const AVCodecID_AV_CODEC_ID_MP4ALS: AVCodecID = 86062;
pub const AVCodecID_AV_CODEC_ID_ATRAC1: AVCodecID = 86063;
pub const AVCodecID_AV_CODEC_ID_BINKAUDIO_RDFT: AVCodecID = 86064;
pub const AVCodecID_AV_CODEC_ID_BINKAUDIO_DCT: AVCodecID = 86065;
pub const AVCodecID_AV_CODEC_ID_AAC_LATM: AVCodecID = 86066;
pub const AVCodecID_AV_CODEC_ID_QDMC: AVCodecID = 86067;
pub const AVCodecID_AV_CODEC_ID_CELT: AVCodecID = 86068;
pub const AVCodecID_AV_CODEC_ID_G723_1: AVCodecID = 86069;
pub const AVCodecID_AV_CODEC_ID_G729: AVCodecID = 86070;
pub const AVCodecID_AV_CODEC_ID_8SVX_EXP: AVCodecID = 86071;
pub const AVCodecID_AV_CODEC_ID_8SVX_FIB: AVCodecID = 86072;
pub const AVCodecID_AV_CODEC_ID_BMV_AUDIO: AVCodecID = 86073;
pub const AVCodecID_AV_CODEC_ID_RALF: AVCodecID = 86074;
pub const AVCodecID_AV_CODEC_ID_IAC: AVCodecID = 86075;
pub const AVCodecID_AV_CODEC_ID_ILBC: AVCodecID = 86076;
pub const AVCodecID_AV_CODEC_ID_OPUS: AVCodecID = 86077;
pub const AVCodecID_AV_CODEC_ID_COMFORT_NOISE: AVCodecID = 86078;
pub const AVCodecID_AV_CODEC_ID_TAK: AVCodecID = 86079;
pub const AVCodecID_AV_CODEC_ID_METASOUND: AVCodecID = 86080;
pub const AVCodecID_AV_CODEC_ID_PAF_AUDIO: AVCodecID = 86081;
pub const AVCodecID_AV_CODEC_ID_ON2AVC: AVCodecID = 86082;
pub const AVCodecID_AV_CODEC_ID_DSS_SP: AVCodecID = 86083;
pub const AVCodecID_AV_CODEC_ID_FFWAVESYNTH: AVCodecID = 88064;
pub const AVCodecID_AV_CODEC_ID_SONIC: AVCodecID = 88065;
pub const AVCodecID_AV_CODEC_ID_SONIC_LS: AVCodecID = 88066;
pub const AVCodecID_AV_CODEC_ID_EVRC: AVCodecID = 88067;
pub const AVCodecID_AV_CODEC_ID_SMV: AVCodecID = 88068;
pub const AVCodecID_AV_CODEC_ID_DSD_LSBF: AVCodecID = 88069;
pub const AVCodecID_AV_CODEC_ID_DSD_MSBF: AVCodecID = 88070;
pub const AVCodecID_AV_CODEC_ID_DSD_LSBF_PLANAR: AVCodecID = 88071;
pub const AVCodecID_AV_CODEC_ID_DSD_MSBF_PLANAR: AVCodecID = 88072;
pub const AVCodecID_AV_CODEC_ID_4GV: AVCodecID = 88073;
pub const AVCodecID_AV_CODEC_ID_INTERPLAY_ACM: AVCodecID = 88074;
pub const AVCodecID_AV_CODEC_ID_XMA1: AVCodecID = 88075;
pub const AVCodecID_AV_CODEC_ID_XMA2: AVCodecID = 88076;
pub const AVCodecID_AV_CODEC_ID_DST: AVCodecID = 88077;
pub const AVCodecID_AV_CODEC_ID_FIRST_SUBTITLE: AVCodecID = 94208;
pub const AVCodecID_AV_CODEC_ID_DVD_SUBTITLE: AVCodecID = 94208;
pub const AVCodecID_AV_CODEC_ID_DVB_SUBTITLE: AVCodecID = 94209;
pub const AVCodecID_AV_CODEC_ID_TEXT: AVCodecID = 94210;
pub const AVCodecID_AV_CODEC_ID_XSUB: AVCodecID = 94211;
pub const AVCodecID_AV_CODEC_ID_SSA: AVCodecID = 94212;
pub const AVCodecID_AV_CODEC_ID_MOV_TEXT: AVCodecID = 94213;
pub const AVCodecID_AV_CODEC_ID_HDMV_PGS_SUBTITLE: AVCodecID = 94214;
pub const AVCodecID_AV_CODEC_ID_DVB_TELETEXT: AVCodecID = 94215;
pub const AVCodecID_AV_CODEC_ID_SRT: AVCodecID = 94216;
pub const AVCodecID_AV_CODEC_ID_MICRODVD: AVCodecID = 96256;
pub const AVCodecID_AV_CODEC_ID_EIA_608: AVCodecID = 96257;
pub const AVCodecID_AV_CODEC_ID_JACOSUB: AVCodecID = 96258;
pub const AVCodecID_AV_CODEC_ID_SAMI: AVCodecID = 96259;
pub const AVCodecID_AV_CODEC_ID_REALTEXT: AVCodecID = 96260;
pub const AVCodecID_AV_CODEC_ID_STL: AVCodecID = 96261;
pub const AVCodecID_AV_CODEC_ID_SUBVIEWER1: AVCodecID = 96262;
pub const AVCodecID_AV_CODEC_ID_SUBVIEWER: AVCodecID = 96263;
pub const AVCodecID_AV_CODEC_ID_SUBRIP: AVCodecID = 96264;
pub const AVCodecID_AV_CODEC_ID_WEBVTT: AVCodecID = 96265;
pub const AVCodecID_AV_CODEC_ID_MPL2: AVCodecID = 96266;
pub const AVCodecID_AV_CODEC_ID_VPLAYER: AVCodecID = 96267;
pub const AVCodecID_AV_CODEC_ID_PJS: AVCodecID = 96268;
pub const AVCodecID_AV_CODEC_ID_ASS: AVCodecID = 96269;
pub const AVCodecID_AV_CODEC_ID_HDMV_TEXT_SUBTITLE: AVCodecID = 96270;
pub const AVCodecID_AV_CODEC_ID_FIRST_UNKNOWN: AVCodecID = 98304;
pub const AVCodecID_AV_CODEC_ID_TTF: AVCodecID = 98304;
pub const AVCodecID_AV_CODEC_ID_SCTE_35: AVCodecID = 98305;
pub const AVCodecID_AV_CODEC_ID_BINTEXT: AVCodecID = 100352;
pub const AVCodecID_AV_CODEC_ID_XBIN: AVCodecID = 100353;
pub const AVCodecID_AV_CODEC_ID_IDF: AVCodecID = 100354;
pub const AVCodecID_AV_CODEC_ID_OTF: AVCodecID = 100355;
pub const AVCodecID_AV_CODEC_ID_SMPTE_KLV: AVCodecID = 100356;
pub const AVCodecID_AV_CODEC_ID_DVD_NAV: AVCodecID = 100357;
pub const AVCodecID_AV_CODEC_ID_TIMED_ID3: AVCodecID = 100358;
pub const AVCodecID_AV_CODEC_ID_BIN_DATA: AVCodecID = 100359;
pub const AVCodecID_AV_CODEC_ID_PROBE: AVCodecID = 102400;
pub const AVCodecID_AV_CODEC_ID_MPEG2TS: AVCodecID = 131072;
pub const AVCodecID_AV_CODEC_ID_MPEG4SYSTEMS: AVCodecID = 131073;
pub const AVCodecID_AV_CODEC_ID_FFMETADATA: AVCodecID = 135168;
pub const AVCodecID_AV_CODEC_ID_WRAPPED_AVFRAME: AVCodecID = 135169;
pub type AVCodecID = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecDescriptor {
    pub id: AVCodecID,
    pub type_: AVMediaType,
    pub name: *const ::std::os::raw::c_char,
    pub long_name: *const ::std::os::raw::c_char,
    pub props: ::std::os::raw::c_int,
    pub mime_types: *const *const ::std::os::raw::c_char,
    pub profiles: *const AVProfile,
}
pub const Motion_Est_ID_ME_ZERO: Motion_Est_ID = 1;
pub const Motion_Est_ID_ME_FULL: Motion_Est_ID = 2;
pub const Motion_Est_ID_ME_LOG: Motion_Est_ID = 3;
pub const Motion_Est_ID_ME_PHODS: Motion_Est_ID = 4;
pub const Motion_Est_ID_ME_EPZS: Motion_Est_ID = 5;
pub const Motion_Est_ID_ME_X1: Motion_Est_ID = 6;
pub const Motion_Est_ID_ME_HEX: Motion_Est_ID = 7;
pub const Motion_Est_ID_ME_UMH: Motion_Est_ID = 8;
pub const Motion_Est_ID_ME_TESA: Motion_Est_ID = 9;
pub const Motion_Est_ID_ME_ITER: Motion_Est_ID = 50;
pub type Motion_Est_ID = u32;
pub const AVDiscard_AVDISCARD_NONE: AVDiscard = -16;
pub const AVDiscard_AVDISCARD_DEFAULT: AVDiscard = 0;
pub const AVDiscard_AVDISCARD_NONREF: AVDiscard = 8;
pub const AVDiscard_AVDISCARD_BIDIR: AVDiscard = 16;
pub const AVDiscard_AVDISCARD_NONINTRA: AVDiscard = 24;
pub const AVDiscard_AVDISCARD_NONKEY: AVDiscard = 32;
pub const AVDiscard_AVDISCARD_ALL: AVDiscard = 48;
pub type AVDiscard = i32;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_MAIN: AVAudioServiceType = 0;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_EFFECTS: AVAudioServiceType = 1;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED: AVAudioServiceType = 2;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED: AVAudioServiceType = 3;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_DIALOGUE: AVAudioServiceType = 4;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_COMMENTARY: AVAudioServiceType = 5;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_EMERGENCY: AVAudioServiceType = 6;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_VOICE_OVER: AVAudioServiceType = 7;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_KARAOKE: AVAudioServiceType = 8;
pub const AVAudioServiceType_AV_AUDIO_SERVICE_TYPE_NB: AVAudioServiceType = 9;
pub type AVAudioServiceType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RcOverride {
    pub start_frame: ::std::os::raw::c_int,
    pub end_frame: ::std::os::raw::c_int,
    pub qscale: ::std::os::raw::c_int,
    pub quality_factor: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVPanScan {
    pub id: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub position: [[i16; 2usize]; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCPBProperties {
    pub max_bitrate: ::std::os::raw::c_int,
    pub min_bitrate: ::std::os::raw::c_int,
    pub avg_bitrate: ::std::os::raw::c_int,
    pub buffer_size: ::std::os::raw::c_int,
    pub vbv_delay: u64,
}
pub const AVPacketSideDataType_AV_PKT_DATA_PALETTE: AVPacketSideDataType = 0;
pub const AVPacketSideDataType_AV_PKT_DATA_NEW_EXTRADATA: AVPacketSideDataType = 1;
pub const AVPacketSideDataType_AV_PKT_DATA_PARAM_CHANGE: AVPacketSideDataType = 2;
pub const AVPacketSideDataType_AV_PKT_DATA_H263_MB_INFO: AVPacketSideDataType = 3;
pub const AVPacketSideDataType_AV_PKT_DATA_REPLAYGAIN: AVPacketSideDataType = 4;
pub const AVPacketSideDataType_AV_PKT_DATA_DISPLAYMATRIX: AVPacketSideDataType = 5;
pub const AVPacketSideDataType_AV_PKT_DATA_STEREO3D: AVPacketSideDataType = 6;
pub const AVPacketSideDataType_AV_PKT_DATA_AUDIO_SERVICE_TYPE: AVPacketSideDataType = 7;
pub const AVPacketSideDataType_AV_PKT_DATA_QUALITY_STATS: AVPacketSideDataType = 8;
pub const AVPacketSideDataType_AV_PKT_DATA_FALLBACK_TRACK: AVPacketSideDataType = 9;
pub const AVPacketSideDataType_AV_PKT_DATA_CPB_PROPERTIES: AVPacketSideDataType = 10;
pub const AVPacketSideDataType_AV_PKT_DATA_SKIP_SAMPLES: AVPacketSideDataType = 70;
pub const AVPacketSideDataType_AV_PKT_DATA_JP_DUALMONO: AVPacketSideDataType = 71;
pub const AVPacketSideDataType_AV_PKT_DATA_STRINGS_METADATA: AVPacketSideDataType = 72;
pub const AVPacketSideDataType_AV_PKT_DATA_SUBTITLE_POSITION: AVPacketSideDataType = 73;
pub const AVPacketSideDataType_AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL: AVPacketSideDataType = 74;
pub const AVPacketSideDataType_AV_PKT_DATA_WEBVTT_IDENTIFIER: AVPacketSideDataType = 75;
pub const AVPacketSideDataType_AV_PKT_DATA_WEBVTT_SETTINGS: AVPacketSideDataType = 76;
pub const AVPacketSideDataType_AV_PKT_DATA_METADATA_UPDATE: AVPacketSideDataType = 77;
pub const AVPacketSideDataType_AV_PKT_DATA_MPEGTS_STREAM_ID: AVPacketSideDataType = 78;
pub const AVPacketSideDataType_AV_PKT_DATA_MASTERING_DISPLAY_METADATA: AVPacketSideDataType = 79;
pub const AVPacketSideDataType_AV_PKT_DATA_NB: AVPacketSideDataType = 80;
pub type AVPacketSideDataType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVPacketSideData {
    pub data: *mut u8,
    pub size: ::std::os::raw::c_int,
    pub type_: AVPacketSideDataType,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVPacket {
    pub buf: *mut AVBufferRef,
    pub pts: i64,
    pub dts: i64,
    pub data: *mut u8,
    pub size: ::std::os::raw::c_int,
    pub stream_index: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
    pub side_data: *mut AVPacketSideData,
    pub side_data_elems: ::std::os::raw::c_int,
    pub duration: i64,
    pub pos: i64,
    pub convergence_duration: i64,
}
pub const AVSideDataParamChangeFlags_AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT:
    AVSideDataParamChangeFlags = 1;
pub const AVSideDataParamChangeFlags_AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT:
    AVSideDataParamChangeFlags = 2;
pub const AVSideDataParamChangeFlags_AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE:
    AVSideDataParamChangeFlags = 4;
pub const AVSideDataParamChangeFlags_AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS:
    AVSideDataParamChangeFlags = 8;
pub type AVSideDataParamChangeFlags = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecInternal {
    _unused: [u8; 0],
}
pub const AVFieldOrder_AV_FIELD_UNKNOWN: AVFieldOrder = 0;
pub const AVFieldOrder_AV_FIELD_PROGRESSIVE: AVFieldOrder = 1;
pub const AVFieldOrder_AV_FIELD_TT: AVFieldOrder = 2;
pub const AVFieldOrder_AV_FIELD_BB: AVFieldOrder = 3;
pub const AVFieldOrder_AV_FIELD_TB: AVFieldOrder = 4;
pub const AVFieldOrder_AV_FIELD_BT: AVFieldOrder = 5;
pub type AVFieldOrder = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecContext {
    pub av_class: *const AVClass,
    pub log_level_offset: ::std::os::raw::c_int,
    pub codec_type: AVMediaType,
    pub codec: *const AVCodec,
    pub codec_name: [::std::os::raw::c_char; 32usize],
    pub codec_id: AVCodecID,
    pub codec_tag: ::std::os::raw::c_uint,
    pub stream_codec_tag: ::std::os::raw::c_uint,
    pub priv_data: *mut ::std::os::raw::c_void,
    pub internal: *mut AVCodecInternal,
    pub opaque: *mut ::std::os::raw::c_void,
    pub bit_rate: i64,
    pub bit_rate_tolerance: ::std::os::raw::c_int,
    pub global_quality: ::std::os::raw::c_int,
    pub compression_level: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
    pub flags2: ::std::os::raw::c_int,
    pub extradata: *mut u8,
    pub extradata_size: ::std::os::raw::c_int,
    pub time_base: AVRational,
    pub ticks_per_frame: ::std::os::raw::c_int,
    pub delay: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub coded_width: ::std::os::raw::c_int,
    pub coded_height: ::std::os::raw::c_int,
    pub gop_size: ::std::os::raw::c_int,
    pub pix_fmt: AVPixelFormat,
    pub me_method: ::std::os::raw::c_int,
    pub draw_horiz_band: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVCodecContext,
            src: *const AVFrame,
            offset: *mut ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            type_: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
        ),
    >,
    pub get_format: ::std::option::Option<
        unsafe extern "C" fn(s: *mut AVCodecContext, fmt: *const AVPixelFormat) -> AVPixelFormat,
    >,
    pub max_b_frames: ::std::os::raw::c_int,
    pub b_quant_factor: f32,
    pub rc_strategy: ::std::os::raw::c_int,
    pub b_frame_strategy: ::std::os::raw::c_int,
    pub b_quant_offset: f32,
    pub has_b_frames: ::std::os::raw::c_int,
    pub mpeg_quant: ::std::os::raw::c_int,
    pub i_quant_factor: f32,
    pub i_quant_offset: f32,
    pub lumi_masking: f32,
    pub temporal_cplx_masking: f32,
    pub spatial_cplx_masking: f32,
    pub p_masking: f32,
    pub dark_masking: f32,
    pub slice_count: ::std::os::raw::c_int,
    pub prediction_method: ::std::os::raw::c_int,
    pub slice_offset: *mut ::std::os::raw::c_int,
    pub sample_aspect_ratio: AVRational,
    pub me_cmp: ::std::os::raw::c_int,
    pub me_sub_cmp: ::std::os::raw::c_int,
    pub mb_cmp: ::std::os::raw::c_int,
    pub ildct_cmp: ::std::os::raw::c_int,
    pub dia_size: ::std::os::raw::c_int,
    pub last_predictor_count: ::std::os::raw::c_int,
    pub pre_me: ::std::os::raw::c_int,
    pub me_pre_cmp: ::std::os::raw::c_int,
    pub pre_dia_size: ::std::os::raw::c_int,
    pub me_subpel_quality: ::std::os::raw::c_int,
    pub dtg_active_format: ::std::os::raw::c_int,
    pub me_range: ::std::os::raw::c_int,
    pub intra_quant_bias: ::std::os::raw::c_int,
    pub inter_quant_bias: ::std::os::raw::c_int,
    pub slice_flags: ::std::os::raw::c_int,
    pub xvmc_acceleration: ::std::os::raw::c_int,
    pub mb_decision: ::std::os::raw::c_int,
    pub intra_matrix: *mut u16,
    pub inter_matrix: *mut u16,
    pub scenechange_threshold: ::std::os::raw::c_int,
    pub noise_reduction: ::std::os::raw::c_int,
    pub me_threshold: ::std::os::raw::c_int,
    pub mb_threshold: ::std::os::raw::c_int,
    pub intra_dc_precision: ::std::os::raw::c_int,
    pub skip_top: ::std::os::raw::c_int,
    pub skip_bottom: ::std::os::raw::c_int,
    pub border_masking: f32,
    pub mb_lmin: ::std::os::raw::c_int,
    pub mb_lmax: ::std::os::raw::c_int,
    pub me_penalty_compensation: ::std::os::raw::c_int,
    pub bidir_refine: ::std::os::raw::c_int,
    pub brd_scale: ::std::os::raw::c_int,
    pub keyint_min: ::std::os::raw::c_int,
    pub refs: ::std::os::raw::c_int,
    pub chromaoffset: ::std::os::raw::c_int,
    pub scenechange_factor: ::std::os::raw::c_int,
    pub mv0_threshold: ::std::os::raw::c_int,
    pub b_sensitivity: ::std::os::raw::c_int,
    pub color_primaries: AVColorPrimaries,
    pub color_trc: AVColorTransferCharacteristic,
    pub colorspace: AVColorSpace,
    pub color_range: AVColorRange,
    pub chroma_sample_location: AVChromaLocation,
    pub slices: ::std::os::raw::c_int,
    pub field_order: AVFieldOrder,
    pub sample_rate: ::std::os::raw::c_int,
    pub channels: ::std::os::raw::c_int,
    pub sample_fmt: AVSampleFormat,
    pub frame_size: ::std::os::raw::c_int,
    pub frame_number: ::std::os::raw::c_int,
    pub block_align: ::std::os::raw::c_int,
    pub cutoff: ::std::os::raw::c_int,
    pub channel_layout: u64,
    pub request_channel_layout: u64,
    pub audio_service_type: AVAudioServiceType,
    pub request_sample_fmt: AVSampleFormat,
    pub get_buffer2: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVCodecContext,
            frame: *mut AVFrame,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub refcounted_frames: ::std::os::raw::c_int,
    pub qcompress: f32,
    pub qblur: f32,
    pub qmin: ::std::os::raw::c_int,
    pub qmax: ::std::os::raw::c_int,
    pub max_qdiff: ::std::os::raw::c_int,
    pub rc_qsquish: f32,
    pub rc_qmod_amp: f32,
    pub rc_qmod_freq: ::std::os::raw::c_int,
    pub rc_buffer_size: ::std::os::raw::c_int,
    pub rc_override_count: ::std::os::raw::c_int,
    pub rc_override: *mut RcOverride,
    pub rc_eq: *const ::std::os::raw::c_char,
    pub rc_max_rate: i64,
    pub rc_min_rate: i64,
    pub rc_buffer_aggressivity: f32,
    pub rc_initial_cplx: f32,
    pub rc_max_available_vbv_use: f32,
    pub rc_min_vbv_overflow_use: f32,
    pub rc_initial_buffer_occupancy: ::std::os::raw::c_int,
    pub coder_type: ::std::os::raw::c_int,
    pub context_model: ::std::os::raw::c_int,
    pub lmin: ::std::os::raw::c_int,
    pub lmax: ::std::os::raw::c_int,
    pub frame_skip_threshold: ::std::os::raw::c_int,
    pub frame_skip_factor: ::std::os::raw::c_int,
    pub frame_skip_exp: ::std::os::raw::c_int,
    pub frame_skip_cmp: ::std::os::raw::c_int,
    pub trellis: ::std::os::raw::c_int,
    pub min_prediction_order: ::std::os::raw::c_int,
    pub max_prediction_order: ::std::os::raw::c_int,
    pub timecode_frame_start: i64,
    pub rtp_callback: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            data: *mut ::std::os::raw::c_void,
            size: ::std::os::raw::c_int,
            mb_nb: ::std::os::raw::c_int,
        ),
    >,
    pub rtp_payload_size: ::std::os::raw::c_int,
    pub mv_bits: ::std::os::raw::c_int,
    pub header_bits: ::std::os::raw::c_int,
    pub i_tex_bits: ::std::os::raw::c_int,
    pub p_tex_bits: ::std::os::raw::c_int,
    pub i_count: ::std::os::raw::c_int,
    pub p_count: ::std::os::raw::c_int,
    pub skip_count: ::std::os::raw::c_int,
    pub misc_bits: ::std::os::raw::c_int,
    pub frame_bits: ::std::os::raw::c_int,
    pub stats_out: *mut ::std::os::raw::c_char,
    pub stats_in: *mut ::std::os::raw::c_char,
    pub workaround_bugs: ::std::os::raw::c_int,
    pub strict_std_compliance: ::std::os::raw::c_int,
    pub error_concealment: ::std::os::raw::c_int,
    pub debug: ::std::os::raw::c_int,
    pub debug_mv: ::std::os::raw::c_int,
    pub err_recognition: ::std::os::raw::c_int,
    pub reordered_opaque: i64,
    pub hwaccel: *mut AVHWAccel,
    pub hwaccel_context: *mut ::std::os::raw::c_void,
    pub error: [u64; 8usize],
    pub dct_algo: ::std::os::raw::c_int,
    pub idct_algo: ::std::os::raw::c_int,
    pub bits_per_coded_sample: ::std::os::raw::c_int,
    pub bits_per_raw_sample: ::std::os::raw::c_int,
    pub lowres: ::std::os::raw::c_int,
    pub coded_frame: *mut AVFrame,
    pub thread_count: ::std::os::raw::c_int,
    pub thread_type: ::std::os::raw::c_int,
    pub active_thread_type: ::std::os::raw::c_int,
    pub thread_safe_callbacks: ::std::os::raw::c_int,
    pub execute: ::std::option::Option<
        unsafe extern "C" fn(
            c: *mut AVCodecContext,
            func: ::std::option::Option<
                unsafe extern "C" fn(
                    c2: *mut AVCodecContext,
                    arg: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
            arg2: *mut ::std::os::raw::c_void,
            ret: *mut ::std::os::raw::c_int,
            count: ::std::os::raw::c_int,
            size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub execute2: ::std::option::Option<
        unsafe extern "C" fn(
            c: *mut AVCodecContext,
            func: ::std::option::Option<
                unsafe extern "C" fn(
                    c2: *mut AVCodecContext,
                    arg: *mut ::std::os::raw::c_void,
                    jobnr: ::std::os::raw::c_int,
                    threadnr: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_int,
            >,
            arg2: *mut ::std::os::raw::c_void,
            ret: *mut ::std::os::raw::c_int,
            count: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub nsse_weight: ::std::os::raw::c_int,
    pub profile: ::std::os::raw::c_int,
    pub level: ::std::os::raw::c_int,
    pub skip_loop_filter: AVDiscard,
    pub skip_idct: AVDiscard,
    pub skip_frame: AVDiscard,
    pub subtitle_header: *mut u8,
    pub subtitle_header_size: ::std::os::raw::c_int,
    pub error_rate: ::std::os::raw::c_int,
    pub vbv_delay: u64,
    pub side_data_only_packets: ::std::os::raw::c_int,
    pub initial_padding: ::std::os::raw::c_int,
    pub framerate: AVRational,
    pub sw_pix_fmt: AVPixelFormat,
    pub pkt_timebase: AVRational,
    pub codec_descriptor: *const AVCodecDescriptor,
    pub pts_correction_num_faulty_pts: i64,
    pub pts_correction_num_faulty_dts: i64,
    pub pts_correction_last_pts: i64,
    pub pts_correction_last_dts: i64,
    pub sub_charenc: *mut ::std::os::raw::c_char,
    pub sub_charenc_mode: ::std::os::raw::c_int,
    pub skip_alpha: ::std::os::raw::c_int,
    pub seek_preroll: ::std::os::raw::c_int,
    pub chroma_intra_matrix: *mut u16,
    pub dump_separator: *mut u8,
    pub codec_whitelist: *mut ::std::os::raw::c_char,
    pub properties: ::std::os::raw::c_uint,
    pub coded_side_data: *mut AVPacketSideData,
    pub nb_coded_side_data: ::std::os::raw::c_int,
    pub hw_frames_ctx: *mut AVBufferRef,
    pub sub_text_format: ::std::os::raw::c_int,
    pub trailing_padding: ::std::os::raw::c_int,
}
extern "C" {
    pub fn av_codec_get_pkt_timebase(avctx: *const AVCodecContext) -> AVRational;
}
extern "C" {
    pub fn av_codec_set_pkt_timebase(avctx: *mut AVCodecContext, val: AVRational);
}
extern "C" {
    pub fn av_codec_get_codec_descriptor(avctx: *const AVCodecContext) -> *const AVCodecDescriptor;
}
extern "C" {
    pub fn av_codec_set_codec_descriptor(
        avctx: *mut AVCodecContext,
        desc: *const AVCodecDescriptor,
    );
}
extern "C" {
    pub fn av_codec_get_codec_properties(avctx: *const AVCodecContext) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn av_codec_get_lowres(avctx: *const AVCodecContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_codec_set_lowres(avctx: *mut AVCodecContext, val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_codec_get_seek_preroll(avctx: *const AVCodecContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_codec_set_seek_preroll(avctx: *mut AVCodecContext, val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_codec_get_chroma_intra_matrix(avctx: *const AVCodecContext) -> *mut u16;
}
extern "C" {
    pub fn av_codec_set_chroma_intra_matrix(avctx: *mut AVCodecContext, val: *mut u16);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVProfile {
    pub profile: ::std::os::raw::c_int,
    pub name: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecDefault {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodec {
    pub name: *const ::std::os::raw::c_char,
    pub long_name: *const ::std::os::raw::c_char,
    pub type_: AVMediaType,
    pub id: AVCodecID,
    pub capabilities: ::std::os::raw::c_int,
    pub supported_framerates: *const AVRational,
    pub pix_fmts: *const AVPixelFormat,
    pub supported_samplerates: *const ::std::os::raw::c_int,
    pub sample_fmts: *const AVSampleFormat,
    pub channel_layouts: *const u64,
    pub max_lowres: u8,
    pub priv_class: *const AVClass,
    pub profiles: *const AVProfile,
    pub priv_data_size: ::std::os::raw::c_int,
    pub next: *mut AVCodec,
    pub init_thread_copy: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVCodecContext) -> ::std::os::raw::c_int,
    >,
    pub update_thread_context: ::std::option::Option<
        unsafe extern "C" fn(
            dst: *mut AVCodecContext,
            src: *const AVCodecContext,
        ) -> ::std::os::raw::c_int,
    >,
    pub defaults: *const AVCodecDefault,
    pub init_static_data: ::std::option::Option<unsafe extern "C" fn(codec: *mut AVCodec)>,
    pub init: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVCodecContext) -> ::std::os::raw::c_int,
    >,
    pub encode_sub: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVCodecContext,
            buf: *mut u8,
            buf_size: ::std::os::raw::c_int,
            sub: *const AVSubtitle,
        ) -> ::std::os::raw::c_int,
    >,
    pub encode2: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            avpkt: *mut AVPacket,
            frame: *const AVFrame,
            got_packet_ptr: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub decode: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVCodecContext,
            outdata: *mut ::std::os::raw::c_void,
            outdata_size: *mut ::std::os::raw::c_int,
            avpkt: *mut AVPacket,
        ) -> ::std::os::raw::c_int,
    >,
    pub close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVCodecContext) -> ::std::os::raw::c_int,
    >,
    pub send_frame: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            frame: *const AVFrame,
        ) -> ::std::os::raw::c_int,
    >,
    pub send_packet: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            avpkt: *const AVPacket,
        ) -> ::std::os::raw::c_int,
    >,
    pub receive_frame: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            frame: *mut AVFrame,
        ) -> ::std::os::raw::c_int,
    >,
    pub receive_packet: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            avpkt: *mut AVPacket,
        ) -> ::std::os::raw::c_int,
    >,
    pub flush: ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVCodecContext)>,
    pub caps_internal: ::std::os::raw::c_int,
}
extern "C" {
    pub fn av_codec_get_max_lowres(codec: *const AVCodec) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MpegEncContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWAccel {
    pub name: *const ::std::os::raw::c_char,
    pub type_: AVMediaType,
    pub id: AVCodecID,
    pub pix_fmt: AVPixelFormat,
    pub capabilities: ::std::os::raw::c_int,
    pub next: *mut AVHWAccel,
    pub alloc_frame: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            frame: *mut AVFrame,
        ) -> ::std::os::raw::c_int,
    >,
    pub start_frame: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            buf: *const u8,
            buf_size: u32,
        ) -> ::std::os::raw::c_int,
    >,
    pub decode_slice: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            buf: *const u8,
            buf_size: u32,
        ) -> ::std::os::raw::c_int,
    >,
    pub end_frame: ::std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext) -> ::std::os::raw::c_int,
    >,
    pub frame_priv_data_size: ::std::os::raw::c_int,
    pub decode_mb: ::std::option::Option<unsafe extern "C" fn(s: *mut MpegEncContext)>,
    pub init: ::std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext) -> ::std::os::raw::c_int,
    >,
    pub uninit: ::std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext) -> ::std::os::raw::c_int,
    >,
    pub priv_data_size: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVPicture {
    pub data: [*mut u8; 8usize],
    pub linesize: [::std::os::raw::c_int; 8usize],
}
pub const AVSubtitleType_SUBTITLE_NONE: AVSubtitleType = 0;
pub const AVSubtitleType_SUBTITLE_BITMAP: AVSubtitleType = 1;
pub const AVSubtitleType_SUBTITLE_TEXT: AVSubtitleType = 2;
pub const AVSubtitleType_SUBTITLE_ASS: AVSubtitleType = 3;
pub type AVSubtitleType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVSubtitleRect {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub w: ::std::os::raw::c_int,
    pub h: ::std::os::raw::c_int,
    pub nb_colors: ::std::os::raw::c_int,
    pub pict: AVPicture,
    pub data: [*mut u8; 4usize],
    pub linesize: [::std::os::raw::c_int; 4usize],
    pub type_: AVSubtitleType,
    pub text: *mut ::std::os::raw::c_char,
    pub ass: *mut ::std::os::raw::c_char,
    pub flags: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVSubtitle {
    pub format: u16,
    pub start_display_time: u32,
    pub end_display_time: u32,
    pub num_rects: ::std::os::raw::c_uint,
    pub rects: *mut *mut AVSubtitleRect,
    pub pts: i64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecParameters {
    pub codec_type: AVMediaType,
    pub codec_id: AVCodecID,
    pub codec_tag: u32,
    pub extradata: *mut u8,
    pub extradata_size: ::std::os::raw::c_int,
    pub format: ::std::os::raw::c_int,
    pub bit_rate: i64,
    pub bits_per_coded_sample: ::std::os::raw::c_int,
    pub bits_per_raw_sample: ::std::os::raw::c_int,
    pub profile: ::std::os::raw::c_int,
    pub level: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub sample_aspect_ratio: AVRational,
    pub field_order: AVFieldOrder,
    pub color_range: AVColorRange,
    pub color_primaries: AVColorPrimaries,
    pub color_trc: AVColorTransferCharacteristic,
    pub color_space: AVColorSpace,
    pub chroma_location: AVChromaLocation,
    pub video_delay: ::std::os::raw::c_int,
    pub channel_layout: u64,
    pub channels: ::std::os::raw::c_int,
    pub sample_rate: ::std::os::raw::c_int,
    pub block_align: ::std::os::raw::c_int,
    pub frame_size: ::std::os::raw::c_int,
    pub initial_padding: ::std::os::raw::c_int,
    pub trailing_padding: ::std::os::raw::c_int,
    pub seek_preroll: ::std::os::raw::c_int,
}
extern "C" {
    pub fn av_codec_next(c: *const AVCodec) -> *mut AVCodec;
}
extern "C" {
    pub fn avcodec_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn avcodec_configuration() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn avcodec_license() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn avcodec_register(codec: *mut AVCodec);
}
extern "C" {
    pub fn avcodec_register_all();
}
extern "C" {
    pub fn avcodec_alloc_context3(codec: *const AVCodec) -> *mut AVCodecContext;
}
extern "C" {
    pub fn avcodec_free_context(avctx: *mut *mut AVCodecContext);
}
extern "C" {
    pub fn avcodec_get_context_defaults3(
        s: *mut AVCodecContext,
        codec: *const AVCodec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_get_class() -> *const AVClass;
}
extern "C" {
    pub fn avcodec_get_frame_class() -> *const AVClass;
}
extern "C" {
    pub fn avcodec_get_subtitle_rect_class() -> *const AVClass;
}
extern "C" {
    pub fn avcodec_copy_context(
        dest: *mut AVCodecContext,
        src: *const AVCodecContext,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_parameters_alloc() -> *mut AVCodecParameters;
}
extern "C" {
    pub fn avcodec_parameters_free(par: *mut *mut AVCodecParameters);
}
extern "C" {
    pub fn avcodec_parameters_copy(
        dst: *mut AVCodecParameters,
        src: *const AVCodecParameters,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_parameters_from_context(
        par: *mut AVCodecParameters,
        codec: *const AVCodecContext,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_parameters_to_context(
        codec: *mut AVCodecContext,
        par: *const AVCodecParameters,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_open2(
        avctx: *mut AVCodecContext,
        codec: *const AVCodec,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_close(avctx: *mut AVCodecContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avsubtitle_free(sub: *mut AVSubtitle);
}
extern "C" {
    pub fn av_packet_alloc() -> *mut AVPacket;
}
extern "C" {
    pub fn av_packet_clone(src: *mut AVPacket) -> *mut AVPacket;
}
extern "C" {
    pub fn av_packet_free(pkt: *mut *mut AVPacket);
}
extern "C" {
    pub fn av_init_packet(pkt: *mut AVPacket);
}
extern "C" {
    pub fn av_new_packet(pkt: *mut AVPacket, size: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_shrink_packet(pkt: *mut AVPacket, size: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_grow_packet(
        pkt: *mut AVPacket,
        grow_by: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_packet_from_data(
        pkt: *mut AVPacket,
        data: *mut u8,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_dup_packet(pkt: *mut AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_copy_packet(dst: *mut AVPacket, src: *const AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_copy_packet_side_data(
        dst: *mut AVPacket,
        src: *const AVPacket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_free_packet(pkt: *mut AVPacket);
}
extern "C" {
    pub fn av_packet_new_side_data(
        pkt: *mut AVPacket,
        type_: AVPacketSideDataType,
        size: ::std::os::raw::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn av_packet_add_side_data(
        pkt: *mut AVPacket,
        type_: AVPacketSideDataType,
        data: *mut u8,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_packet_shrink_side_data(
        pkt: *mut AVPacket,
        type_: AVPacketSideDataType,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_packet_get_side_data(
        pkt: *mut AVPacket,
        type_: AVPacketSideDataType,
        size: *mut ::std::os::raw::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn av_packet_merge_side_data(pkt: *mut AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_packet_split_side_data(pkt: *mut AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_packet_side_data_name(type_: AVPacketSideDataType) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_packet_pack_dictionary(
        dict: *mut AVDictionary,
        size: *mut ::std::os::raw::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn av_packet_unpack_dictionary(
        data: *const u8,
        size: ::std::os::raw::c_int,
        dict: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_packet_free_side_data(pkt: *mut AVPacket);
}
extern "C" {
    pub fn av_packet_ref(dst: *mut AVPacket, src: *const AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_packet_unref(pkt: *mut AVPacket);
}
extern "C" {
    pub fn av_packet_move_ref(dst: *mut AVPacket, src: *mut AVPacket);
}
extern "C" {
    pub fn av_packet_copy_props(dst: *mut AVPacket, src: *const AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_packet_rescale_ts(pkt: *mut AVPacket, tb_src: AVRational, tb_dst: AVRational);
}
extern "C" {
    pub fn avcodec_find_decoder(id: AVCodecID) -> *mut AVCodec;
}
extern "C" {
    pub fn avcodec_find_decoder_by_name(name: *const ::std::os::raw::c_char) -> *mut AVCodec;
}
extern "C" {
    pub fn avcodec_default_get_buffer2(
        s: *mut AVCodecContext,
        frame: *mut AVFrame,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_get_edge_width() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn avcodec_align_dimensions(
        s: *mut AVCodecContext,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn avcodec_align_dimensions2(
        s: *mut AVCodecContext,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
        linesize_align: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn avcodec_enum_to_chroma_pos(
        xpos: *mut ::std::os::raw::c_int,
        ypos: *mut ::std::os::raw::c_int,
        pos: AVChromaLocation,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_chroma_pos_to_enum(
        xpos: ::std::os::raw::c_int,
        ypos: ::std::os::raw::c_int,
    ) -> AVChromaLocation;
}
extern "C" {
    pub fn avcodec_decode_audio4(
        avctx: *mut AVCodecContext,
        frame: *mut AVFrame,
        got_frame_ptr: *mut ::std::os::raw::c_int,
        avpkt: *const AVPacket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_decode_video2(
        avctx: *mut AVCodecContext,
        picture: *mut AVFrame,
        got_picture_ptr: *mut ::std::os::raw::c_int,
        avpkt: *const AVPacket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_decode_subtitle2(
        avctx: *mut AVCodecContext,
        sub: *mut AVSubtitle,
        got_sub_ptr: *mut ::std::os::raw::c_int,
        avpkt: *mut AVPacket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_send_packet(
        avctx: *mut AVCodecContext,
        avpkt: *const AVPacket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_receive_frame(
        avctx: *mut AVCodecContext,
        frame: *mut AVFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_send_frame(
        avctx: *mut AVCodecContext,
        frame: *const AVFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_receive_packet(
        avctx: *mut AVCodecContext,
        avpkt: *mut AVPacket,
    ) -> ::std::os::raw::c_int;
}
pub const AVPictureStructure_AV_PICTURE_STRUCTURE_UNKNOWN: AVPictureStructure = 0;
pub const AVPictureStructure_AV_PICTURE_STRUCTURE_TOP_FIELD: AVPictureStructure = 1;
pub const AVPictureStructure_AV_PICTURE_STRUCTURE_BOTTOM_FIELD: AVPictureStructure = 2;
pub const AVPictureStructure_AV_PICTURE_STRUCTURE_FRAME: AVPictureStructure = 3;
pub type AVPictureStructure = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecParserContext {
    pub priv_data: *mut ::std::os::raw::c_void,
    pub parser: *mut AVCodecParser,
    pub frame_offset: i64,
    pub cur_offset: i64,
    pub next_frame_offset: i64,
    pub pict_type: ::std::os::raw::c_int,
    pub repeat_pict: ::std::os::raw::c_int,
    pub pts: i64,
    pub dts: i64,
    pub last_pts: i64,
    pub last_dts: i64,
    pub fetch_timestamp: ::std::os::raw::c_int,
    pub cur_frame_start_index: ::std::os::raw::c_int,
    pub cur_frame_offset: [i64; 4usize],
    pub cur_frame_pts: [i64; 4usize],
    pub cur_frame_dts: [i64; 4usize],
    pub flags: ::std::os::raw::c_int,
    pub offset: i64,
    pub cur_frame_end: [i64; 4usize],
    pub key_frame: ::std::os::raw::c_int,
    pub convergence_duration: i64,
    pub dts_sync_point: ::std::os::raw::c_int,
    pub dts_ref_dts_delta: ::std::os::raw::c_int,
    pub pts_dts_delta: ::std::os::raw::c_int,
    pub cur_frame_pos: [i64; 4usize],
    pub pos: i64,
    pub last_pos: i64,
    pub duration: ::std::os::raw::c_int,
    pub field_order: AVFieldOrder,
    pub picture_structure: AVPictureStructure,
    pub output_picture_number: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub coded_width: ::std::os::raw::c_int,
    pub coded_height: ::std::os::raw::c_int,
    pub format: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecParser {
    pub codec_ids: [::std::os::raw::c_int; 5usize],
    pub priv_data_size: ::std::os::raw::c_int,
    pub parser_init: ::std::option::Option<
        unsafe extern "C" fn(s: *mut AVCodecParserContext) -> ::std::os::raw::c_int,
    >,
    pub parser_parse: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVCodecParserContext,
            avctx: *mut AVCodecContext,
            poutbuf: *mut *const u8,
            poutbuf_size: *mut ::std::os::raw::c_int,
            buf: *const u8,
            buf_size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub parser_close: ::std::option::Option<unsafe extern "C" fn(s: *mut AVCodecParserContext)>,
    pub split: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            buf: *const u8,
            buf_size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub next: *mut AVCodecParser,
}
extern "C" {
    pub fn av_parser_next(c: *const AVCodecParser) -> *mut AVCodecParser;
}
extern "C" {
    pub fn av_register_codec_parser(parser: *mut AVCodecParser);
}
extern "C" {
    pub fn av_parser_init(codec_id: ::std::os::raw::c_int) -> *mut AVCodecParserContext;
}
extern "C" {
    pub fn av_parser_parse2(
        s: *mut AVCodecParserContext,
        avctx: *mut AVCodecContext,
        poutbuf: *mut *mut u8,
        poutbuf_size: *mut ::std::os::raw::c_int,
        buf: *const u8,
        buf_size: ::std::os::raw::c_int,
        pts: i64,
        dts: i64,
        pos: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_parser_change(
        s: *mut AVCodecParserContext,
        avctx: *mut AVCodecContext,
        poutbuf: *mut *mut u8,
        poutbuf_size: *mut ::std::os::raw::c_int,
        buf: *const u8,
        buf_size: ::std::os::raw::c_int,
        keyframe: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_parser_close(s: *mut AVCodecParserContext);
}
extern "C" {
    pub fn avcodec_find_encoder(id: AVCodecID) -> *mut AVCodec;
}
extern "C" {
    pub fn avcodec_find_encoder_by_name(name: *const ::std::os::raw::c_char) -> *mut AVCodec;
}
extern "C" {
    pub fn avcodec_encode_audio2(
        avctx: *mut AVCodecContext,
        avpkt: *mut AVPacket,
        frame: *const AVFrame,
        got_packet_ptr: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_encode_video2(
        avctx: *mut AVCodecContext,
        avpkt: *mut AVPacket,
        frame: *const AVFrame,
        got_packet_ptr: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_encode_subtitle(
        avctx: *mut AVCodecContext,
        buf: *mut u8,
        buf_size: ::std::os::raw::c_int,
        sub: *const AVSubtitle,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReSampleContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVResampleContext {
    _unused: [u8; 0],
}
extern "C" {
    pub fn av_audio_resample_init(
        output_channels: ::std::os::raw::c_int,
        input_channels: ::std::os::raw::c_int,
        output_rate: ::std::os::raw::c_int,
        input_rate: ::std::os::raw::c_int,
        sample_fmt_out: AVSampleFormat,
        sample_fmt_in: AVSampleFormat,
        filter_length: ::std::os::raw::c_int,
        log2_phase_count: ::std::os::raw::c_int,
        linear: ::std::os::raw::c_int,
        cutoff: f64,
    ) -> *mut ReSampleContext;
}
extern "C" {
    pub fn audio_resample(
        s: *mut ReSampleContext,
        output: *mut ::std::os::raw::c_short,
        input: *mut ::std::os::raw::c_short,
        nb_samples: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn audio_resample_close(s: *mut ReSampleContext);
}
extern "C" {
    pub fn av_resample_init(
        out_rate: ::std::os::raw::c_int,
        in_rate: ::std::os::raw::c_int,
        filter_length: ::std::os::raw::c_int,
        log2_phase_count: ::std::os::raw::c_int,
        linear: ::std::os::raw::c_int,
        cutoff: f64,
    ) -> *mut AVResampleContext;
}
extern "C" {
    pub fn av_resample(
        c: *mut AVResampleContext,
        dst: *mut ::std::os::raw::c_short,
        src: *mut ::std::os::raw::c_short,
        consumed: *mut ::std::os::raw::c_int,
        src_size: ::std::os::raw::c_int,
        dst_size: ::std::os::raw::c_int,
        update_ctx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_resample_compensate(
        c: *mut AVResampleContext,
        sample_delta: ::std::os::raw::c_int,
        compensation_distance: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn av_resample_close(c: *mut AVResampleContext);
}
extern "C" {
    pub fn avpicture_alloc(
        picture: *mut AVPicture,
        pix_fmt: AVPixelFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avpicture_free(picture: *mut AVPicture);
}
extern "C" {
    pub fn avpicture_fill(
        picture: *mut AVPicture,
        ptr: *const u8,
        pix_fmt: AVPixelFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avpicture_layout(
        src: *const AVPicture,
        pix_fmt: AVPixelFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        dest: *mut ::std::os::raw::c_uchar,
        dest_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avpicture_get_size(
        pix_fmt: AVPixelFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_picture_copy(
        dst: *mut AVPicture,
        src: *const AVPicture,
        pix_fmt: AVPixelFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn av_picture_crop(
        dst: *mut AVPicture,
        src: *const AVPicture,
        pix_fmt: AVPixelFormat,
        top_band: ::std::os::raw::c_int,
        left_band: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_picture_pad(
        dst: *mut AVPicture,
        src: *const AVPicture,
        height: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        pix_fmt: AVPixelFormat,
        padtop: ::std::os::raw::c_int,
        padbottom: ::std::os::raw::c_int,
        padleft: ::std::os::raw::c_int,
        padright: ::std::os::raw::c_int,
        color: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_get_chroma_sub_sample(
        pix_fmt: AVPixelFormat,
        h_shift: *mut ::std::os::raw::c_int,
        v_shift: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn avcodec_pix_fmt_to_codec_tag(pix_fmt: AVPixelFormat) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn avcodec_get_pix_fmt_loss(
        dst_pix_fmt: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_find_best_pix_fmt_of_list(
        pix_fmt_list: *const AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: ::std::os::raw::c_int,
        loss_ptr: *mut ::std::os::raw::c_int,
    ) -> AVPixelFormat;
}
extern "C" {
    pub fn avcodec_find_best_pix_fmt_of_2(
        dst_pix_fmt1: AVPixelFormat,
        dst_pix_fmt2: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: ::std::os::raw::c_int,
        loss_ptr: *mut ::std::os::raw::c_int,
    ) -> AVPixelFormat;
}
extern "C" {
    pub fn avcodec_find_best_pix_fmt2(
        dst_pix_fmt1: AVPixelFormat,
        dst_pix_fmt2: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: ::std::os::raw::c_int,
        loss_ptr: *mut ::std::os::raw::c_int,
    ) -> AVPixelFormat;
}
extern "C" {
    pub fn avcodec_default_get_format(
        s: *mut AVCodecContext,
        fmt: *const AVPixelFormat,
    ) -> AVPixelFormat;
}
extern "C" {
    pub fn avcodec_set_dimensions(
        s: *mut AVCodecContext,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn av_get_codec_tag_string(
        buf: *mut ::std::os::raw::c_char,
        buf_size: usize,
        codec_tag: ::std::os::raw::c_uint,
    ) -> usize;
}
extern "C" {
    pub fn avcodec_string(
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_int,
        enc: *mut AVCodecContext,
        encode: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn av_get_profile_name(
        codec: *const AVCodec,
        profile: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn avcodec_profile_name(
        codec_id: AVCodecID,
        profile: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn avcodec_default_execute(
        c: *mut AVCodecContext,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                c2: *mut AVCodecContext,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
        ret: *mut ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_default_execute2(
        c: *mut AVCodecContext,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                c2: *mut AVCodecContext,
                arg2: *mut ::std::os::raw::c_void,
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
        ret: *mut ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_fill_audio_frame(
        frame: *mut AVFrame,
        nb_channels: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        buf: *const u8,
        buf_size: ::std::os::raw::c_int,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_flush_buffers(avctx: *mut AVCodecContext);
}
extern "C" {
    pub fn av_get_bits_per_sample(codec_id: AVCodecID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_get_pcm_codec(fmt: AVSampleFormat, be: ::std::os::raw::c_int) -> AVCodecID;
}
extern "C" {
    pub fn av_get_exact_bits_per_sample(codec_id: AVCodecID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_get_audio_frame_duration(
        avctx: *mut AVCodecContext,
        frame_bytes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_get_audio_frame_duration2(
        par: *mut AVCodecParameters,
        frame_bytes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBitStreamFilterContext {
    pub priv_data: *mut ::std::os::raw::c_void,
    pub filter: *mut AVBitStreamFilter,
    pub parser: *mut AVCodecParserContext,
    pub next: *mut AVBitStreamFilterContext,
    pub args: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBSFInternal {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBSFContext {
    pub av_class: *const AVClass,
    pub filter: *const AVBitStreamFilter,
    pub internal: *mut AVBSFInternal,
    pub priv_data: *mut ::std::os::raw::c_void,
    pub par_in: *mut AVCodecParameters,
    pub par_out: *mut AVCodecParameters,
    pub time_base_in: AVRational,
    pub time_base_out: AVRational,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBitStreamFilter {
    pub name: *const ::std::os::raw::c_char,
    pub codec_ids: *const AVCodecID,
    pub priv_class: *const AVClass,
    pub priv_data_size: ::std::os::raw::c_int,
    pub init: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut AVBSFContext) -> ::std::os::raw::c_int,
    >,
    pub filter: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut AVBSFContext, pkt: *mut AVPacket) -> ::std::os::raw::c_int,
    >,
    pub close: ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVBSFContext)>,
}
extern "C" {
    pub fn av_register_bitstream_filter(bsf: *mut AVBitStreamFilter);
}
extern "C" {
    pub fn av_bitstream_filter_init(
        name: *const ::std::os::raw::c_char,
    ) -> *mut AVBitStreamFilterContext;
}
extern "C" {
    pub fn av_bitstream_filter_filter(
        bsfc: *mut AVBitStreamFilterContext,
        avctx: *mut AVCodecContext,
        args: *const ::std::os::raw::c_char,
        poutbuf: *mut *mut u8,
        poutbuf_size: *mut ::std::os::raw::c_int,
        buf: *const u8,
        buf_size: ::std::os::raw::c_int,
        keyframe: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_bitstream_filter_close(bsf: *mut AVBitStreamFilterContext);
}
extern "C" {
    pub fn av_bitstream_filter_next(f: *const AVBitStreamFilter) -> *mut AVBitStreamFilter;
}
extern "C" {
    pub fn av_bsf_get_by_name(name: *const ::std::os::raw::c_char) -> *const AVBitStreamFilter;
}
extern "C" {
    pub fn av_bsf_next(opaque: *mut *mut ::std::os::raw::c_void) -> *const AVBitStreamFilter;
}
extern "C" {
    pub fn av_bsf_alloc(
        filter: *const AVBitStreamFilter,
        ctx: *mut *mut AVBSFContext,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_bsf_init(ctx: *mut AVBSFContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_bsf_send_packet(ctx: *mut AVBSFContext, pkt: *mut AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_bsf_receive_packet(
        ctx: *mut AVBSFContext,
        pkt: *mut AVPacket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_bsf_free(ctx: *mut *mut AVBSFContext);
}
extern "C" {
    pub fn av_bsf_get_class() -> *const AVClass;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBSFList {
    _unused: [u8; 0],
}
extern "C" {
    pub fn av_bsf_list_alloc() -> *mut AVBSFList;
}
extern "C" {
    pub fn av_bsf_list_free(lst: *mut *mut AVBSFList);
}
extern "C" {
    pub fn av_bsf_list_append(lst: *mut AVBSFList, bsf: *mut AVBSFContext)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_bsf_list_append2(
        lst: *mut AVBSFList,
        bsf_name: *const ::std::os::raw::c_char,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_bsf_list_finalize(
        lst: *mut *mut AVBSFList,
        bsf: *mut *mut AVBSFContext,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_bsf_list_parse_str(
        str: *const ::std::os::raw::c_char,
        bsf: *mut *mut AVBSFContext,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_bsf_get_null_filter(bsf: *mut *mut AVBSFContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_fast_padded_malloc(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    );
}
extern "C" {
    pub fn av_fast_padded_mallocz(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    );
}
extern "C" {
    pub fn av_xiphlacing(
        s: *mut ::std::os::raw::c_uchar,
        v: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn av_log_missing_feature(
        avc: *mut ::std::os::raw::c_void,
        feature: *const ::std::os::raw::c_char,
        want_sample: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn av_log_ask_for_sample(
        avc: *mut ::std::os::raw::c_void,
        msg: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn av_register_hwaccel(hwaccel: *mut AVHWAccel);
}
extern "C" {
    pub fn av_hwaccel_next(hwaccel: *const AVHWAccel) -> *mut AVHWAccel;
}
pub const AVLockOp_AV_LOCK_CREATE: AVLockOp = 0;
pub const AVLockOp_AV_LOCK_OBTAIN: AVLockOp = 1;
pub const AVLockOp_AV_LOCK_RELEASE: AVLockOp = 2;
pub const AVLockOp_AV_LOCK_DESTROY: AVLockOp = 3;
pub type AVLockOp = u32;
extern "C" {
    pub fn av_lockmgr_register(
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                mutex: *mut *mut ::std::os::raw::c_void,
                op: AVLockOp,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_get_type(codec_id: AVCodecID) -> AVMediaType;
}
extern "C" {
    pub fn avcodec_get_name(id: AVCodecID) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn avcodec_is_open(s: *mut AVCodecContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_codec_is_encoder(codec: *const AVCodec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_codec_is_decoder(codec: *const AVCodec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_descriptor_get(id: AVCodecID) -> *const AVCodecDescriptor;
}
extern "C" {
    pub fn avcodec_descriptor_next(prev: *const AVCodecDescriptor) -> *const AVCodecDescriptor;
}
extern "C" {
    pub fn avcodec_descriptor_get_by_name(
        name: *const ::std::os::raw::c_char,
    ) -> *const AVCodecDescriptor;
}
extern "C" {
    pub fn av_cpb_properties_alloc(size: *mut usize) -> *mut AVCPBProperties;
}
#[doc = " Callback for checking whether to abort blocking functions."]
#[doc = " AVERROR_EXIT is returned in this case by the interrupted"]
#[doc = " function. During blocking operations, callback is called with"]
#[doc = " opaque as parameter. If the callback returns 1, the"]
#[doc = " blocking operation will be aborted."]
#[doc = ""]
#[doc = " No members can be added to this struct without a major bump, if"]
#[doc = " new elements have been added after this struct in AVFormatContext"]
#[doc = " or AVIOContext."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVIOInterruptCB {
    pub callback: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub opaque: *mut ::std::os::raw::c_void,
}
pub const AVIODirEntryType_AVIO_ENTRY_UNKNOWN: AVIODirEntryType = 0;
pub const AVIODirEntryType_AVIO_ENTRY_BLOCK_DEVICE: AVIODirEntryType = 1;
pub const AVIODirEntryType_AVIO_ENTRY_CHARACTER_DEVICE: AVIODirEntryType = 2;
pub const AVIODirEntryType_AVIO_ENTRY_DIRECTORY: AVIODirEntryType = 3;
pub const AVIODirEntryType_AVIO_ENTRY_NAMED_PIPE: AVIODirEntryType = 4;
pub const AVIODirEntryType_AVIO_ENTRY_SYMBOLIC_LINK: AVIODirEntryType = 5;
pub const AVIODirEntryType_AVIO_ENTRY_SOCKET: AVIODirEntryType = 6;
pub const AVIODirEntryType_AVIO_ENTRY_FILE: AVIODirEntryType = 7;
pub const AVIODirEntryType_AVIO_ENTRY_SERVER: AVIODirEntryType = 8;
pub const AVIODirEntryType_AVIO_ENTRY_SHARE: AVIODirEntryType = 9;
pub const AVIODirEntryType_AVIO_ENTRY_WORKGROUP: AVIODirEntryType = 10;
#[doc = " Directory entry types."]
pub type AVIODirEntryType = u32;
#[doc = " Describes single entry of the directory."]
#[doc = ""]
#[doc = " Only name and type fields are guaranteed be set."]
#[doc = " Rest of fields are protocol or/and platform dependent and might be unknown."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVIODirEntry {
    #[doc = "< Filename"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< Type of the entry"]
    pub type_: ::std::os::raw::c_int,
    #[doc = "< Set to 1 when name is encoded with UTF-8, 0 otherwise."]
    #[doc = "Name can be encoded with UTF-8 even though 0 is set."]
    pub utf8: ::std::os::raw::c_int,
    #[doc = "< File size in bytes, -1 if unknown."]
    pub size: i64,
    #[doc = "< Time of last modification in microseconds since unix"]
    #[doc = "epoch, -1 if unknown."]
    pub modification_timestamp: i64,
    #[doc = "< Time of last access in microseconds since unix epoch,"]
    #[doc = "-1 if unknown."]
    pub access_timestamp: i64,
    #[doc = "< Time of last status change in microseconds since unix"]
    #[doc = "epoch, -1 if unknown."]
    pub status_change_timestamp: i64,
    #[doc = "< User ID of owner, -1 if unknown."]
    pub user_id: i64,
    #[doc = "< Group ID of owner, -1 if unknown."]
    pub group_id: i64,
    #[doc = "< Unix file mode, -1 if unknown."]
    pub filemode: i64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVIODirContext {
    pub url_context: *mut URLContext,
}
#[doc = " Header data; this needs to be present for the stream to be decodeable."]
pub const AVIODataMarkerType_AVIO_DATA_MARKER_HEADER: AVIODataMarkerType = 0;
#[doc = " A point in the output bytestream where a decoder can start decoding"]
#[doc = " (i.e. a keyframe). A demuxer/decoder given the data flagged with"]
#[doc = " AVIO_DATA_MARKER_HEADER, followed by any AVIO_DATA_MARKER_SYNC_POINT,"]
#[doc = " should give decodeable results."]
pub const AVIODataMarkerType_AVIO_DATA_MARKER_SYNC_POINT: AVIODataMarkerType = 1;
#[doc = " A point in the output bytestream where a demuxer can start parsing"]
#[doc = " (for non self synchronizing bytestream formats). That is, any"]
#[doc = " non-keyframe packet start point."]
pub const AVIODataMarkerType_AVIO_DATA_MARKER_BOUNDARY_POINT: AVIODataMarkerType = 2;
#[doc = " This is any, unlabelled data. It can either be a muxer not marking"]
#[doc = " any positions at all, it can be an actual boundary/sync point"]
#[doc = " that the muxer chooses not to mark, or a later part of a packet/fragment"]
#[doc = " that is cut into multiple write callbacks due to limited IO buffer size."]
pub const AVIODataMarkerType_AVIO_DATA_MARKER_UNKNOWN: AVIODataMarkerType = 3;
#[doc = " Trailer data, which doesn't contain actual content, but only for"]
#[doc = " finalizing the output file."]
pub const AVIODataMarkerType_AVIO_DATA_MARKER_TRAILER: AVIODataMarkerType = 4;
#[doc = " Different data types that can be returned via the AVIO"]
#[doc = " write_data_type callback."]
pub type AVIODataMarkerType = u32;
#[doc = " Bytestream IO Context."]
#[doc = " New fields can be added to the end with minor version bumps."]
#[doc = " Removal, reordering and changes to existing fields require a major"]
#[doc = " version bump."]
#[doc = " sizeof(AVIOContext) must not be used outside libav*."]
#[doc = ""]
#[doc = " @note None of the function pointers in AVIOContext should be called"]
#[doc = "       directly, they should only be set by the client application"]
#[doc = "       when implementing custom I/O. Normally these are set to the"]
#[doc = "       function pointers specified in avio_alloc_context()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVIOContext {
    #[doc = " A class for private options."]
    #[doc = ""]
    #[doc = " If this AVIOContext is created by avio_open2(), av_class is set and"]
    #[doc = " passes the options down to protocols."]
    #[doc = ""]
    #[doc = " If this AVIOContext is manually allocated, then av_class may be set by"]
    #[doc = " the caller."]
    #[doc = ""]
    #[doc = " warning -- this field can be NULL, be sure to not pass this AVIOContext"]
    #[doc = " to any av_opt_* functions in that case."]
    pub av_class: *const AVClass,
    #[doc = "< Start of the buffer."]
    pub buffer: *mut ::std::os::raw::c_uchar,
    #[doc = "< Maximum buffer size"]
    pub buffer_size: ::std::os::raw::c_int,
    #[doc = "< Current position in the buffer"]
    pub buf_ptr: *mut ::std::os::raw::c_uchar,
    #[doc = "< End of the data, may be less than"]
    #[doc = "buffer+buffer_size if the read function returned"]
    #[doc = "less data than requested, e.g. for streams where"]
    #[doc = "no more data has been received yet."]
    pub buf_end: *mut ::std::os::raw::c_uchar,
    #[doc = "< A private pointer, passed to the read/write/seek/..."]
    #[doc = "functions."]
    pub opaque: *mut ::std::os::raw::c_void,
    pub read_packet: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            buf: *mut u8,
            buf_size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub write_packet: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            buf: *mut u8,
            buf_size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            offset: i64,
            whence: ::std::os::raw::c_int,
        ) -> i64,
    >,
    #[doc = "< position in the file of the current buffer"]
    pub pos: i64,
    #[doc = "< true if the next seek should flush"]
    pub must_flush: ::std::os::raw::c_int,
    #[doc = "< true if eof reached"]
    pub eof_reached: ::std::os::raw::c_int,
    #[doc = "< true if open for writing"]
    pub write_flag: ::std::os::raw::c_int,
    pub max_packet_size: ::std::os::raw::c_int,
    pub checksum: ::std::os::raw::c_ulong,
    pub checksum_ptr: *mut ::std::os::raw::c_uchar,
    pub update_checksum: ::std::option::Option<
        unsafe extern "C" fn(
            checksum: ::std::os::raw::c_ulong,
            buf: *const u8,
            size: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_ulong,
    >,
    #[doc = "< contains the error code or 0 if no error happened"]
    pub error: ::std::os::raw::c_int,
    #[doc = " Pause or resume playback for network streaming protocols - e.g. MMS."]
    pub read_pause: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            pause: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Seek to a given timestamp in stream with the specified stream_index."]
    #[doc = " Needed for some network streaming protocols which don't support seeking"]
    #[doc = " to byte position."]
    pub read_seek: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            stream_index: ::std::os::raw::c_int,
            timestamp: i64,
            flags: ::std::os::raw::c_int,
        ) -> i64,
    >,
    #[doc = " A combination of AVIO_SEEKABLE_ flags or 0 when the stream is not seekable."]
    pub seekable: ::std::os::raw::c_int,
    #[doc = " max filesize, used to limit allocations"]
    #[doc = " This field is internal to libavformat and access from outside is not allowed."]
    pub maxsize: i64,
    #[doc = " avio_read and avio_write should if possible be satisfied directly"]
    #[doc = " instead of going through a buffer, and avio_seek will always"]
    #[doc = " call the underlying seek function directly."]
    pub direct: ::std::os::raw::c_int,
    #[doc = " Bytes read statistic"]
    #[doc = " This field is internal to libavformat and access from outside is not allowed."]
    pub bytes_read: i64,
    #[doc = " seek statistic"]
    #[doc = " This field is internal to libavformat and access from outside is not allowed."]
    pub seek_count: ::std::os::raw::c_int,
    #[doc = " writeout statistic"]
    #[doc = " This field is internal to libavformat and access from outside is not allowed."]
    pub writeout_count: ::std::os::raw::c_int,
    #[doc = " Original buffer size"]
    #[doc = " used internally after probing and ensure seekback to reset the buffer size"]
    #[doc = " This field is internal to libavformat and access from outside is not allowed."]
    pub orig_buffer_size: ::std::os::raw::c_int,
    #[doc = " Threshold to favor readahead over seek."]
    #[doc = " This is current internal only, do not use from outside."]
    pub short_seek_threshold: ::std::os::raw::c_int,
    #[doc = " ',' separated list of allowed protocols."]
    pub protocol_whitelist: *const ::std::os::raw::c_char,
    #[doc = " ',' separated list of disallowed protocols."]
    pub protocol_blacklist: *const ::std::os::raw::c_char,
    #[doc = " A callback that is used instead of write_packet."]
    pub write_data_type: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            buf: *mut u8,
            buf_size: ::std::os::raw::c_int,
            type_: AVIODataMarkerType,
            time: i64,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " If set, don't call write_data_type separately for AVIO_DATA_MARKER_BOUNDARY_POINT,"]
    #[doc = " but ignore them and treat them as AVIO_DATA_MARKER_UNKNOWN (to avoid needlessly"]
    #[doc = " small chunks of data returned from the callback)."]
    pub ignore_boundary_point: ::std::os::raw::c_int,
    #[doc = " Internal, not meant to be used from outside of AVIOContext."]
    pub current_type: AVIODataMarkerType,
    pub last_time: i64,
    #[doc = " A callback that is used instead of short_seek_threshold."]
    #[doc = " This is current internal only, do not use from outside."]
    pub short_seek_get: ::std::option::Option<
        unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
}
extern "C" {
    #[doc = " Return the name of the protocol that will handle the passed URL."]
    #[doc = ""]
    #[doc = " NULL is returned if no protocol could be found for the given URL."]
    #[doc = ""]
    #[doc = " @return Name of the protocol or NULL."]
    pub fn avio_find_protocol_name(
        url: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return AVIO_FLAG_* access flags corresponding to the access permissions"]
    #[doc = " of the resource in url, or a negative value corresponding to an"]
    #[doc = " AVERROR code in case of failure. The returned access flags are"]
    #[doc = " masked by the value in flags."]
    #[doc = ""]
    #[doc = " @note This function is intrinsically unsafe, in the sense that the"]
    #[doc = " checked resource may change its existence or permission status from"]
    #[doc = " one call to another. Thus you should not trust the returned value,"]
    #[doc = " unless you are sure that no other processes are accessing the"]
    #[doc = " checked resource."]
    pub fn avio_check(
        url: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Move or rename a resource."]
    #[doc = ""]
    #[doc = " @note url_src and url_dst should share the same protocol and authority."]
    #[doc = ""]
    #[doc = " @param url_src url to resource to be moved"]
    #[doc = " @param url_dst new url to resource if the operation succeeded"]
    #[doc = " @return >=0 on success or negative on error."]
    pub fn avpriv_io_move(
        url_src: *const ::std::os::raw::c_char,
        url_dst: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete a resource."]
    #[doc = ""]
    #[doc = " @param url resource to be deleted."]
    #[doc = " @return >=0 on success or negative on error."]
    pub fn avpriv_io_delete(url: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Open directory for reading."]
    #[doc = ""]
    #[doc = " @param s       directory read context. Pointer to a NULL pointer must be passed."]
    #[doc = " @param url     directory to be listed."]
    #[doc = " @param options A dictionary filled with protocol-private options. On return"]
    #[doc = "                this parameter will be destroyed and replaced with a dictionary"]
    #[doc = "                containing options that were not found. May be NULL."]
    #[doc = " @return >=0 on success or negative on error."]
    pub fn avio_open_dir(
        s: *mut *mut AVIODirContext,
        url: *const ::std::os::raw::c_char,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get next directory entry."]
    #[doc = ""]
    #[doc = " Returned entry must be freed with avio_free_directory_entry(). In particular"]
    #[doc = " it may outlive AVIODirContext."]
    #[doc = ""]
    #[doc = " @param s         directory read context."]
    #[doc = " @param[out] next next entry or NULL when no more entries."]
    #[doc = " @return >=0 on success or negative on error. End of list is not considered an"]
    #[doc = "             error."]
    pub fn avio_read_dir(
        s: *mut AVIODirContext,
        next: *mut *mut AVIODirEntry,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close directory."]
    #[doc = ""]
    #[doc = " @note Entries created using avio_read_dir() are not deleted and must be"]
    #[doc = " freeded with avio_free_directory_entry()."]
    #[doc = ""]
    #[doc = " @param s         directory read context."]
    #[doc = " @return >=0 on success or negative on error."]
    pub fn avio_close_dir(s: *mut *mut AVIODirContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free entry allocated by avio_read_dir()."]
    #[doc = ""]
    #[doc = " @param entry entry to be freed."]
    pub fn avio_free_directory_entry(entry: *mut *mut AVIODirEntry);
}
extern "C" {
    #[doc = " Allocate and initialize an AVIOContext for buffered I/O. It must be later"]
    #[doc = " freed with av_free()."]
    #[doc = ""]
    #[doc = " @param buffer Memory block for input/output operations via AVIOContext."]
    #[doc = "        The buffer must be allocated with av_malloc() and friends."]
    #[doc = "        It may be freed and replaced with a new buffer by libavformat."]
    #[doc = "        AVIOContext.buffer holds the buffer currently in use,"]
    #[doc = "        which must be later freed with av_free()."]
    #[doc = " @param buffer_size The buffer size is very important for performance."]
    #[doc = "        For protocols with fixed blocksize it should be set to this blocksize."]
    #[doc = "        For others a typical size is a cache page, e.g. 4kb."]
    #[doc = " @param write_flag Set to 1 if the buffer should be writable, 0 otherwise."]
    #[doc = " @param opaque An opaque pointer to user-specific data."]
    #[doc = " @param read_packet  A function for refilling the buffer, may be NULL."]
    #[doc = " @param write_packet A function for writing the buffer contents, may be NULL."]
    #[doc = "        The function may not change the input buffers content."]
    #[doc = " @param seek A function for seeking to specified byte position, may be NULL."]
    #[doc = ""]
    #[doc = " @return Allocated AVIOContext or NULL on failure."]
    pub fn avio_alloc_context(
        buffer: *mut ::std::os::raw::c_uchar,
        buffer_size: ::std::os::raw::c_int,
        write_flag: ::std::os::raw::c_int,
        opaque: *mut ::std::os::raw::c_void,
        read_packet: ::std::option::Option<
            unsafe extern "C" fn(
                opaque: *mut ::std::os::raw::c_void,
                buf: *mut u8,
                buf_size: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        write_packet: ::std::option::Option<
            unsafe extern "C" fn(
                opaque: *mut ::std::os::raw::c_void,
                buf: *mut u8,
                buf_size: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        seek: ::std::option::Option<
            unsafe extern "C" fn(
                opaque: *mut ::std::os::raw::c_void,
                offset: i64,
                whence: ::std::os::raw::c_int,
            ) -> i64,
        >,
    ) -> *mut AVIOContext;
}
extern "C" {
    pub fn avio_w8(s: *mut AVIOContext, b: ::std::os::raw::c_int);
}
extern "C" {
    pub fn avio_write(
        s: *mut AVIOContext,
        buf: *const ::std::os::raw::c_uchar,
        size: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn avio_wl64(s: *mut AVIOContext, val: u64);
}
extern "C" {
    pub fn avio_wb64(s: *mut AVIOContext, val: u64);
}
extern "C" {
    pub fn avio_wl32(s: *mut AVIOContext, val: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn avio_wb32(s: *mut AVIOContext, val: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn avio_wl24(s: *mut AVIOContext, val: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn avio_wb24(s: *mut AVIOContext, val: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn avio_wl16(s: *mut AVIOContext, val: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn avio_wb16(s: *mut AVIOContext, val: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Write a NULL-terminated string."]
    #[doc = " @return number of bytes written."]
    pub fn avio_put_str(
        s: *mut AVIOContext,
        str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert an UTF-8 string to UTF-16LE and write it."]
    #[doc = " @param s the AVIOContext"]
    #[doc = " @param str NULL-terminated UTF-8 string"]
    #[doc = ""]
    #[doc = " @return number of bytes written."]
    pub fn avio_put_str16le(
        s: *mut AVIOContext,
        str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert an UTF-8 string to UTF-16BE and write it."]
    #[doc = " @param s the AVIOContext"]
    #[doc = " @param str NULL-terminated UTF-8 string"]
    #[doc = ""]
    #[doc = " @return number of bytes written."]
    pub fn avio_put_str16be(
        s: *mut AVIOContext,
        str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Mark the written bytestream as a specific type."]
    #[doc = ""]
    #[doc = " Zero-length ranges are omitted from the output."]
    #[doc = ""]
    #[doc = " @param time the stream time the current bytestream pos corresponds to"]
    #[doc = "             (in AV_TIME_BASE units), or AV_NOPTS_VALUE if unknown or not"]
    #[doc = "             applicable"]
    #[doc = " @param type the kind of data written starting at the current pos"]
    pub fn avio_write_marker(s: *mut AVIOContext, time: i64, type_: AVIODataMarkerType);
}
extern "C" {
    #[doc = " fseek() equivalent for AVIOContext."]
    #[doc = " @return new position or AVERROR."]
    pub fn avio_seek(s: *mut AVIOContext, offset: i64, whence: ::std::os::raw::c_int) -> i64;
}
extern "C" {
    #[doc = " Skip given number of bytes forward"]
    #[doc = " @return new position or AVERROR."]
    pub fn avio_skip(s: *mut AVIOContext, offset: i64) -> i64;
}
extern "C" {
    #[doc = " Get the filesize."]
    #[doc = " @return filesize or AVERROR"]
    pub fn avio_size(s: *mut AVIOContext) -> i64;
}
extern "C" {
    #[doc = " feof() equivalent for AVIOContext."]
    #[doc = " @return non zero if and only if end of file"]
    pub fn avio_feof(s: *mut AVIOContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @deprecated use avio_feof()"]
    pub fn url_feof(s: *mut AVIOContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning Writes up to 4 KiB per call"]
    pub fn avio_printf(
        s: *mut AVIOContext,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Force flushing of buffered data."]
    #[doc = ""]
    #[doc = " For write streams, force the buffered data to be immediately written to the output,"]
    #[doc = " without to wait to fill the internal buffer."]
    #[doc = ""]
    #[doc = " For read streams, discard all currently buffered data, and advance the"]
    #[doc = " reported file position to that of the underlying stream. This does not"]
    #[doc = " read new data, and does not perform any seeks."]
    pub fn avio_flush(s: *mut AVIOContext);
}
extern "C" {
    #[doc = " Read size bytes from AVIOContext into buf."]
    #[doc = " @return number of bytes read or AVERROR"]
    pub fn avio_read(
        s: *mut AVIOContext,
        buf: *mut ::std::os::raw::c_uchar,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @name Functions for reading from AVIOContext"]
    #[doc = " @{"]
    #[doc = ""]
    #[doc = " @note return 0 if EOF, so you cannot use it if EOF handling is"]
    #[doc = "       necessary"]
    pub fn avio_r8(s: *mut AVIOContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_rl16(s: *mut AVIOContext) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn avio_rl24(s: *mut AVIOContext) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn avio_rl32(s: *mut AVIOContext) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn avio_rl64(s: *mut AVIOContext) -> u64;
}
extern "C" {
    pub fn avio_rb16(s: *mut AVIOContext) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn avio_rb24(s: *mut AVIOContext) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn avio_rb32(s: *mut AVIOContext) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn avio_rb64(s: *mut AVIOContext) -> u64;
}
extern "C" {
    #[doc = " Read a string from pb into buf. The reading will terminate when either"]
    #[doc = " a NULL character was encountered, maxlen bytes have been read, or nothing"]
    #[doc = " more can be read from pb. The result is guaranteed to be NULL-terminated, it"]
    #[doc = " will be truncated if buf is too small."]
    #[doc = " Note that the string is not interpreted or validated in any way, it"]
    #[doc = " might get truncated in the middle of a sequence for multi-byte encodings."]
    #[doc = ""]
    #[doc = " @return number of bytes read (is always <= maxlen)."]
    #[doc = " If reading ends on EOF or error, the return value will be one more than"]
    #[doc = " bytes actually read."]
    pub fn avio_get_str(
        pb: *mut AVIOContext,
        maxlen: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read a UTF-16 string from pb and convert it to UTF-8."]
    #[doc = " The reading will terminate when either a null or invalid character was"]
    #[doc = " encountered or maxlen bytes have been read."]
    #[doc = " @return number of bytes read (is always <= maxlen)"]
    pub fn avio_get_str16le(
        pb: *mut AVIOContext,
        maxlen: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_get_str16be(
        pb: *mut AVIOContext,
        maxlen: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create and initialize a AVIOContext for accessing the"]
    #[doc = " resource indicated by url."]
    #[doc = " @note When the resource indicated by url has been opened in"]
    #[doc = " read+write mode, the AVIOContext can be used only for writing."]
    #[doc = ""]
    #[doc = " @param s Used to return the pointer to the created AVIOContext."]
    #[doc = " In case of failure the pointed to value is set to NULL."]
    #[doc = " @param url resource to access"]
    #[doc = " @param flags flags which control how the resource indicated by url"]
    #[doc = " is to be opened"]
    #[doc = " @return >= 0 in case of success, a negative value corresponding to an"]
    #[doc = " AVERROR code in case of failure"]
    pub fn avio_open(
        s: *mut *mut AVIOContext,
        url: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create and initialize a AVIOContext for accessing the"]
    #[doc = " resource indicated by url."]
    #[doc = " @note When the resource indicated by url has been opened in"]
    #[doc = " read+write mode, the AVIOContext can be used only for writing."]
    #[doc = ""]
    #[doc = " @param s Used to return the pointer to the created AVIOContext."]
    #[doc = " In case of failure the pointed to value is set to NULL."]
    #[doc = " @param url resource to access"]
    #[doc = " @param flags flags which control how the resource indicated by url"]
    #[doc = " is to be opened"]
    #[doc = " @param int_cb an interrupt callback to be used at the protocols level"]
    #[doc = " @param options  A dictionary filled with protocol-private options. On return"]
    #[doc = " this parameter will be destroyed and replaced with a dict containing options"]
    #[doc = " that were not found. May be NULL."]
    #[doc = " @return >= 0 in case of success, a negative value corresponding to an"]
    #[doc = " AVERROR code in case of failure"]
    pub fn avio_open2(
        s: *mut *mut AVIOContext,
        url: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        int_cb: *const AVIOInterruptCB,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close the resource accessed by the AVIOContext s and free it."]
    #[doc = " This function can only be used if s was opened by avio_open()."]
    #[doc = ""]
    #[doc = " The internal buffer is automatically flushed before closing the"]
    #[doc = " resource."]
    #[doc = ""]
    #[doc = " @return 0 on success, an AVERROR < 0 on error."]
    #[doc = " @see avio_closep"]
    pub fn avio_close(s: *mut AVIOContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close the resource accessed by the AVIOContext *s, free it"]
    #[doc = " and set the pointer pointing to it to NULL."]
    #[doc = " This function can only be used if s was opened by avio_open()."]
    #[doc = ""]
    #[doc = " The internal buffer is automatically flushed before closing the"]
    #[doc = " resource."]
    #[doc = ""]
    #[doc = " @return 0 on success, an AVERROR < 0 on error."]
    #[doc = " @see avio_close"]
    pub fn avio_closep(s: *mut *mut AVIOContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Open a write only memory stream."]
    #[doc = ""]
    #[doc = " @param s new IO context"]
    #[doc = " @return zero if no error."]
    pub fn avio_open_dyn_buf(s: *mut *mut AVIOContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the written size and a pointer to the buffer."]
    #[doc = " The AVIOContext stream is left intact."]
    #[doc = " The buffer must NOT be freed."]
    #[doc = " No padding is added to the buffer."]
    #[doc = ""]
    #[doc = " @param s IO context"]
    #[doc = " @param pbuffer pointer to a byte buffer"]
    #[doc = " @return the length of the byte buffer"]
    pub fn avio_get_dyn_buf(s: *mut AVIOContext, pbuffer: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the written size and a pointer to the buffer. The buffer"]
    #[doc = " must be freed with av_free()."]
    #[doc = " Padding of AV_INPUT_BUFFER_PADDING_SIZE is added to the buffer."]
    #[doc = ""]
    #[doc = " @param s IO context"]
    #[doc = " @param pbuffer pointer to a byte buffer"]
    #[doc = " @return the length of the byte buffer"]
    pub fn avio_close_dyn_buf(s: *mut AVIOContext, pbuffer: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Iterate through names of available protocols."]
    #[doc = ""]
    #[doc = " @param opaque A private pointer representing current protocol."]
    #[doc = "        It must be a pointer to NULL on first iteration and will"]
    #[doc = "        be updated by successive calls to avio_enum_protocols."]
    #[doc = " @param output If set to 1, iterate over output protocols,"]
    #[doc = "               otherwise over input protocols."]
    #[doc = ""]
    #[doc = " @return A static string containing the name of current protocol or NULL"]
    pub fn avio_enum_protocols(
        opaque: *mut *mut ::std::os::raw::c_void,
        output: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Pause and resume playing - only meaningful if using a network streaming"]
    #[doc = " protocol (e.g. MMS)."]
    #[doc = ""]
    #[doc = " @param h     IO context from which to call the read_pause function pointer"]
    #[doc = " @param pause 1 for pause, 0 for resume"]
    pub fn avio_pause(h: *mut AVIOContext, pause: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Seek to a given timestamp relative to some component stream."]
    #[doc = " Only meaningful if using a network streaming protocol (e.g. MMS.)."]
    #[doc = ""]
    #[doc = " @param h IO context from which to call the seek function pointers"]
    #[doc = " @param stream_index The stream index that the timestamp is relative to."]
    #[doc = "        If stream_index is (-1) the timestamp should be in AV_TIME_BASE"]
    #[doc = "        units from the beginning of the presentation."]
    #[doc = "        If a stream_index >= 0 is used and the protocol does not support"]
    #[doc = "        seeking based on component streams, the call will fail."]
    #[doc = " @param timestamp timestamp in AVStream.time_base units"]
    #[doc = "        or if there is no stream specified then in AV_TIME_BASE units."]
    #[doc = " @param flags Optional combination of AVSEEK_FLAG_BACKWARD, AVSEEK_FLAG_BYTE"]
    #[doc = "        and AVSEEK_FLAG_ANY. The protocol may silently ignore"]
    #[doc = "        AVSEEK_FLAG_BACKWARD and AVSEEK_FLAG_ANY, but AVSEEK_FLAG_BYTE will"]
    #[doc = "        fail if used and not supported."]
    #[doc = " @return >= 0 on success"]
    #[doc = " @see AVInputFormat::read_seek"]
    pub fn avio_seek_time(
        h: *mut AVIOContext,
        stream_index: ::std::os::raw::c_int,
        timestamp: i64,
        flags: ::std::os::raw::c_int,
    ) -> i64;
}
extern "C" {
    #[doc = " Read contents of h into print buffer, up to max_size bytes, or up to EOF."]
    #[doc = ""]
    #[doc = " @return 0 for success (max_size bytes read or EOF reached), negative error"]
    #[doc = " code otherwise"]
    pub fn avio_read_to_bprint(
        h: *mut AVIOContext,
        pb: *mut AVBPrint,
        max_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Accept and allocate a client context on a server context."]
    #[doc = " @param  s the server context"]
    #[doc = " @param  c the client context, must be unallocated"]
    #[doc = " @return   >= 0 on success or a negative value corresponding"]
    #[doc = "           to an AVERROR on failure"]
    pub fn avio_accept(s: *mut AVIOContext, c: *mut *mut AVIOContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Perform one step of the protocol handshake to accept a new client."]
    #[doc = " This function must be called on a client returned by avio_accept() before"]
    #[doc = " using it as a read/write context."]
    #[doc = " It is separate from avio_accept() because it may block."]
    #[doc = " A step of the handshake is defined by places where the application may"]
    #[doc = " decide to change the proceedings."]
    #[doc = " For example, on a protocol with a request header and a reply header, each"]
    #[doc = " one can constitute a step because the application may use the parameters"]
    #[doc = " from the request to change parameters in the reply; or each individual"]
    #[doc = " chunk of the request can constitute a step."]
    #[doc = " If the handshake is already finished, avio_handshake() does nothing and"]
    #[doc = " returns 0 immediately."]
    #[doc = ""]
    #[doc = " @param  c the client context to perform the handshake on"]
    #[doc = " @return   0   on a complete and successful handshake"]
    #[doc = "           > 0 if the handshake progressed, but is not complete"]
    #[doc = "           < 0 for an AVERROR code"]
    pub fn avio_handshake(c: *mut AVIOContext) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDeviceInfoList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDeviceCapabilitiesQuery {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate and read the payload of a packet and initialize its"]
    #[doc = " fields with default values."]
    #[doc = ""]
    #[doc = " @param s    associated IO context"]
    #[doc = " @param pkt packet"]
    #[doc = " @param size desired payload size"]
    #[doc = " @return >0 (read size) if OK, AVERROR_xxx otherwise"]
    pub fn av_get_packet(
        s: *mut AVIOContext,
        pkt: *mut AVPacket,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read data and append it to the current content of the AVPacket."]
    #[doc = " If pkt->size is 0 this is identical to av_get_packet."]
    #[doc = " Note that this uses av_grow_packet and thus involves a realloc"]
    #[doc = " which is inefficient. Thus this function should only be used"]
    #[doc = " when there is no reasonable way to know (an upper bound of)"]
    #[doc = " the final size."]
    #[doc = ""]
    #[doc = " @param s    associated IO context"]
    #[doc = " @param pkt packet"]
    #[doc = " @param size amount of data to read"]
    #[doc = " @return >0 (read size) if OK, AVERROR_xxx otherwise, previous data"]
    #[doc = "         will not be lost even if an error occurs."]
    pub fn av_append_packet(
        s: *mut AVIOContext,
        pkt: *mut AVPacket,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " The exact value of the fractional number is: 'val + num / den'."]
#[doc = " num is assumed to be 0 <= num < den."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFrac {
    pub val: i64,
    pub num: i64,
    pub den: i64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecTag {
    _unused: [u8; 0],
}
#[doc = " This structure contains the data a format has to probe a file."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVProbeData {
    pub filename: *const ::std::os::raw::c_char,
    #[doc = "< Buffer must have AVPROBE_PADDING_SIZE of extra allocated bytes filled with zero."]
    pub buf: *mut ::std::os::raw::c_uchar,
    #[doc = "< Size of buf except extra allocated bytes"]
    pub buf_size: ::std::os::raw::c_int,
    #[doc = "< mime_type, when known."]
    pub mime_type: *const ::std::os::raw::c_char,
}
#[doc = " @addtogroup lavf_encoding"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVOutputFormat {
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Descriptive name for the format, meant to be more human-readable"]
    #[doc = " than name. You should use the NULL_IF_CONFIG_SMALL() macro"]
    #[doc = " to define it."]
    pub long_name: *const ::std::os::raw::c_char,
    pub mime_type: *const ::std::os::raw::c_char,
    #[doc = "< comma-separated filename extensions"]
    pub extensions: *const ::std::os::raw::c_char,
    #[doc = "< default audio codec"]
    pub audio_codec: AVCodecID,
    #[doc = "< default video codec"]
    pub video_codec: AVCodecID,
    #[doc = "< default subtitle codec"]
    pub subtitle_codec: AVCodecID,
    #[doc = " can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER,"]
    #[doc = " AVFMT_GLOBALHEADER, AVFMT_NOTIMESTAMPS, AVFMT_VARIABLE_FPS,"]
    #[doc = " AVFMT_NODIMENSIONS, AVFMT_NOSTREAMS, AVFMT_ALLOW_FLUSH,"]
    #[doc = " AVFMT_TS_NONSTRICT, AVFMT_TS_NEGATIVE"]
    pub flags: ::std::os::raw::c_int,
    #[doc = " List of supported codec_id-codec_tag pairs, ordered by \"better"]
    #[doc = " choice first\". The arrays are all terminated by AV_CODEC_ID_NONE."]
    pub codec_tag: *const *const AVCodecTag,
    #[doc = "< AVClass for the private context"]
    pub priv_class: *const AVClass,
    #[doc = " No fields below this line are part of the public API. They"]
    #[doc = " may not be used outside of libavformat and can be changed and"]
    #[doc = " removed at will."]
    #[doc = " New public fields should be added right above."]
    #[doc = ""]
    pub next: *mut AVOutputFormat,
    #[doc = " size of private data so that it can be allocated in the wrapper"]
    pub priv_data_size: ::std::os::raw::c_int,
    pub write_header: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext) -> ::std::os::raw::c_int,
    >,
    #[doc = " Write a packet. If AVFMT_ALLOW_FLUSH is set in flags,"]
    #[doc = " pkt can be NULL in order to flush data buffered in the muxer."]
    #[doc = " When flushing, return 0 if there still is more data to flush,"]
    #[doc = " or 1 if everything was flushed and there is no more buffered"]
    #[doc = " data."]
    pub write_packet: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVFormatContext,
            pkt: *mut AVPacket,
        ) -> ::std::os::raw::c_int,
    >,
    pub write_trailer: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext) -> ::std::os::raw::c_int,
    >,
    #[doc = " Currently only used to set pixel format if not YUV420P."]
    pub interleave_packet: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVFormatContext,
            out: *mut AVPacket,
            in_: *mut AVPacket,
            flush: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Test if the given codec can be stored in this container."]
    #[doc = ""]
    #[doc = " @return 1 if the codec is supported, 0 if it is not."]
    #[doc = "         A negative number if unknown."]
    #[doc = "         MKTAG('A', 'P', 'I', 'C') if the codec is only supported as AV_DISPOSITION_ATTACHED_PIC"]
    pub query_codec: ::std::option::Option<
        unsafe extern "C" fn(
            id: AVCodecID,
            std_compliance: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_output_timestamp: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            stream: ::std::os::raw::c_int,
            dts: *mut i64,
            wall: *mut i64,
        ),
    >,
    #[doc = " Allows sending messages from application to device."]
    pub control_message: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            type_: ::std::os::raw::c_int,
            data: *mut ::std::os::raw::c_void,
            data_size: usize,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Write an uncoded AVFrame."]
    #[doc = ""]
    #[doc = " See av_write_uncoded_frame() for details."]
    #[doc = ""]
    #[doc = " The library will free *frame afterwards, but the muxer can prevent it"]
    #[doc = " by setting the pointer to NULL."]
    pub write_uncoded_frame: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVFormatContext,
            stream_index: ::std::os::raw::c_int,
            frame: *mut *mut AVFrame,
            flags: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Returns device list with it properties."]
    #[doc = " @see avdevice_list_devices() for more details."]
    pub get_device_list: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            device_list: *mut AVDeviceInfoList,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Initialize device capabilities submodule."]
    #[doc = " @see avdevice_capabilities_create() for more details."]
    pub create_device_capabilities: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            caps: *mut AVDeviceCapabilitiesQuery,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Free device capabilities submodule."]
    #[doc = " @see avdevice_capabilities_free() for more details."]
    pub free_device_capabilities: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            caps: *mut AVDeviceCapabilitiesQuery,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = "< default data codec"]
    pub data_codec: AVCodecID,
    #[doc = " Initialize format. May allocate data here, and set any AVFormatContext or"]
    #[doc = " AVStream parameters that need to be set before packets are sent."]
    #[doc = " This method must not write output."]
    #[doc = ""]
    #[doc = " Return 0 if streams were fully configured, 1 if not, negative AVERROR on failure"]
    #[doc = ""]
    #[doc = " Any allocations made here must be freed in deinit()."]
    pub init: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext) -> ::std::os::raw::c_int,
    >,
    #[doc = " Deinitialize format. If present, this is called whenever the muxer is being"]
    #[doc = " destroyed, regardless of whether or not the header has been written."]
    #[doc = ""]
    #[doc = " If a trailer is being written, this is called after write_trailer()."]
    #[doc = ""]
    #[doc = " This is called if init() fails as well."]
    pub deinit: ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFormatContext)>,
    #[doc = " Set up any necessary bitstream filtering and extract any extra data needed"]
    #[doc = " for the global header."]
    #[doc = " Return 0 if more packets from this stream must be checked; 1 if not."]
    pub check_bitstream: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVFormatContext,
            pkt: *const AVPacket,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = " @addtogroup lavf_decoding"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVInputFormat {
    #[doc = " A comma separated list of short names for the format. New names"]
    #[doc = " may be appended with a minor bump."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Descriptive name for the format, meant to be more human-readable"]
    #[doc = " than name. You should use the NULL_IF_CONFIG_SMALL() macro"]
    #[doc = " to define it."]
    pub long_name: *const ::std::os::raw::c_char,
    #[doc = " Can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_SHOW_IDS,"]
    #[doc = " AVFMT_GENERIC_INDEX, AVFMT_TS_DISCONT, AVFMT_NOBINSEARCH,"]
    #[doc = " AVFMT_NOGENSEARCH, AVFMT_NO_BYTE_SEEK, AVFMT_SEEK_TO_PTS."]
    pub flags: ::std::os::raw::c_int,
    #[doc = " If extensions are defined, then no probe is done. You should"]
    #[doc = " usually not use extension format guessing because it is not"]
    #[doc = " reliable enough"]
    pub extensions: *const ::std::os::raw::c_char,
    pub codec_tag: *const *const AVCodecTag,
    #[doc = "< AVClass for the private context"]
    pub priv_class: *const AVClass,
    #[doc = " Comma-separated list of mime types."]
    #[doc = " It is used check for matching mime types while probing."]
    #[doc = " @see av_probe_input_format2"]
    pub mime_type: *const ::std::os::raw::c_char,
    #[doc = " No fields below this line are part of the public API. They"]
    #[doc = " may not be used outside of libavformat and can be changed and"]
    #[doc = " removed at will."]
    #[doc = " New public fields should be added right above."]
    #[doc = ""]
    pub next: *mut AVInputFormat,
    #[doc = " Raw demuxers store their codec ID here."]
    pub raw_codec_id: ::std::os::raw::c_int,
    #[doc = " Size of private data so that it can be allocated in the wrapper."]
    pub priv_data_size: ::std::os::raw::c_int,
    #[doc = " Tell if a given file has a chance of being parsed as this format."]
    #[doc = " The buffer provided is guaranteed to be AVPROBE_PADDING_SIZE bytes"]
    #[doc = " big so you do not have to check for that unless you need more."]
    pub read_probe: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVProbeData) -> ::std::os::raw::c_int,
    >,
    #[doc = " Read the format header and initialize the AVFormatContext"]
    #[doc = " structure. Return 0 if OK. 'avformat_new_stream' should be"]
    #[doc = " called to create new streams."]
    pub read_header: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext) -> ::std::os::raw::c_int,
    >,
    #[doc = " Read one packet and put it in 'pkt'. pts and flags are also"]
    #[doc = " set. 'avformat_new_stream' can be called only if the flag"]
    #[doc = " AVFMTCTX_NOHEADER is used and only in the calling thread (not in a"]
    #[doc = " background thread)."]
    #[doc = " @return 0 on success, < 0 on error."]
    #[doc = "         When returning an error, pkt must not have been allocated"]
    #[doc = "         or must be freed before returning"]
    pub read_packet: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVFormatContext,
            pkt: *mut AVPacket,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Close the stream. The AVFormatContext and AVStreams are not"]
    #[doc = " freed by this function"]
    pub read_close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext) -> ::std::os::raw::c_int,
    >,
    #[doc = " Seek to a given timestamp relative to the frames in"]
    #[doc = " stream component stream_index."]
    #[doc = " @param stream_index Must not be -1."]
    #[doc = " @param flags Selects which direction should be preferred if no exact"]
    #[doc = "              match is available."]
    #[doc = " @return >= 0 on success (but not necessarily the new offset)"]
    pub read_seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVFormatContext,
            stream_index: ::std::os::raw::c_int,
            timestamp: i64,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Get the next timestamp in stream[stream_index].time_base units."]
    #[doc = " @return the timestamp or AV_NOPTS_VALUE if an error occurred"]
    pub read_timestamp: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            stream_index: ::std::os::raw::c_int,
            pos: *mut i64,
            pos_limit: i64,
        ) -> i64,
    >,
    #[doc = " Start/resume playing - only meaningful if using a network-based format"]
    #[doc = " (RTSP)."]
    pub read_play: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext) -> ::std::os::raw::c_int,
    >,
    #[doc = " Pause playing - only meaningful if using a network-based format"]
    #[doc = " (RTSP)."]
    pub read_pause: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext) -> ::std::os::raw::c_int,
    >,
    #[doc = " Seek to timestamp ts."]
    #[doc = " Seeking will be done so that the point from which all active streams"]
    #[doc = " can be presented successfully will be closest to ts and within min/max_ts."]
    #[doc = " Active streams are all streams that have AVStream.discard < AVDISCARD_ALL."]
    pub read_seek2: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            stream_index: ::std::os::raw::c_int,
            min_ts: i64,
            ts: i64,
            max_ts: i64,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Returns device list with it properties."]
    #[doc = " @see avdevice_list_devices() for more details."]
    pub get_device_list: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            device_list: *mut AVDeviceInfoList,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Initialize device capabilities submodule."]
    #[doc = " @see avdevice_capabilities_create() for more details."]
    pub create_device_capabilities: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            caps: *mut AVDeviceCapabilitiesQuery,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Free device capabilities submodule."]
    #[doc = " @see avdevice_capabilities_free() for more details."]
    pub free_device_capabilities: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            caps: *mut AVDeviceCapabilitiesQuery,
        ) -> ::std::os::raw::c_int,
    >,
}
pub const AVStreamParseType_AVSTREAM_PARSE_NONE: AVStreamParseType = 0;
#[doc = "< full parsing and repack"]
pub const AVStreamParseType_AVSTREAM_PARSE_FULL: AVStreamParseType = 1;
#[doc = "< Only parse headers, do not repack."]
pub const AVStreamParseType_AVSTREAM_PARSE_HEADERS: AVStreamParseType = 2;
#[doc = "< full parsing and interpolation of timestamps for frames not starting on a packet boundary"]
pub const AVStreamParseType_AVSTREAM_PARSE_TIMESTAMPS: AVStreamParseType = 3;
#[doc = "< full parsing and repack of the first frame only, only implemented for H.264 currently"]
pub const AVStreamParseType_AVSTREAM_PARSE_FULL_ONCE: AVStreamParseType = 4;
#[doc = "< full parsing and repack with timestamp and position generation by parser for raw"]
#[doc = "this assumes that each packet in the file contains no demuxer level headers and"]
#[doc = "just codec level data, otherwise position generation would fail"]
pub const AVStreamParseType_AVSTREAM_PARSE_FULL_RAW: AVStreamParseType = 1463898624;
#[doc = " @}"]
pub type AVStreamParseType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVIndexEntry {
    pub pos: i64,
    #[doc = "<"]
    #[doc = " Timestamp in AVStream.time_base units, preferably the time from which on correctly decoded frames are available"]
    #[doc = " when seeking to this entry. That means preferable PTS on keyframe based formats."]
    #[doc = " But demuxers can choose to store a different timestamp, if it is more convenient for the implementation or nothing better"]
    #[doc = " is known"]
    pub timestamp: i64,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    #[doc = "< Minimum distance between this and the previous keyframe, used to avoid unneeded searching."]
    pub min_distance: ::std::os::raw::c_int,
}
impl AVIndexEntry {
    #[inline]
    pub fn flags(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn size(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_size(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: ::std::os::raw::c_int,
        size: ::std::os::raw::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let size: u32 = unsafe { ::std::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVStreamInternal {
    _unused: [u8; 0],
}
#[doc = " Stream structure."]
#[doc = " New fields can be added to the end with minor version bumps."]
#[doc = " Removal, reordering and changes to existing fields require a major"]
#[doc = " version bump."]
#[doc = " sizeof(AVStream) must not be used outside libav*."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVStream {
    #[doc = "< stream index in AVFormatContext"]
    pub index: ::std::os::raw::c_int,
    #[doc = " Format-specific stream ID."]
    #[doc = " decoding: set by libavformat"]
    #[doc = " encoding: set by the user, replaced by libavformat if left unset"]
    pub id: ::std::os::raw::c_int,
    #[doc = " @deprecated use the codecpar struct instead"]
    pub codec: *mut AVCodecContext,
    pub priv_data: *mut ::std::os::raw::c_void,
    #[doc = " @deprecated this field is unused"]
    pub pts: AVFrac,
    #[doc = " This is the fundamental unit of time (in seconds) in terms"]
    #[doc = " of which frame timestamps are represented."]
    #[doc = ""]
    #[doc = " decoding: set by libavformat"]
    #[doc = " encoding: May be set by the caller before avformat_write_header() to"]
    #[doc = "           provide a hint to the muxer about the desired timebase. In"]
    #[doc = "           avformat_write_header(), the muxer will overwrite this field"]
    #[doc = "           with the timebase that will actually be used for the timestamps"]
    #[doc = "           written into the file (which may or may not be related to the"]
    #[doc = "           user-provided one, depending on the format)."]
    pub time_base: AVRational,
    #[doc = " Decoding: pts of the first frame of the stream in presentation order, in stream time base."]
    #[doc = " Only set this if you are absolutely 100% sure that the value you set"]
    #[doc = " it to really is the pts of the first frame."]
    #[doc = " This may be undefined (AV_NOPTS_VALUE)."]
    #[doc = " @note The ASF header does NOT contain a correct start_time the ASF"]
    #[doc = " demuxer must NOT set this."]
    pub start_time: i64,
    #[doc = " Decoding: duration of the stream, in stream time base."]
    #[doc = " If a source file does not specify a duration, but does specify"]
    #[doc = " a bitrate, this value will be estimated from bitrate and file size."]
    #[doc = ""]
    #[doc = " Encoding: May be set by the caller before avformat_write_header() to"]
    #[doc = " provide a hint to the muxer about the estimated duration."]
    pub duration: i64,
    #[doc = "< number of frames in this stream if known or 0"]
    pub nb_frames: i64,
    #[doc = "< AV_DISPOSITION_* bit field"]
    pub disposition: ::std::os::raw::c_int,
    #[doc = "< Selects which packets can be discarded at will and do not need to be demuxed."]
    pub discard: AVDiscard,
    #[doc = " sample aspect ratio (0 if unknown)"]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: Set by libavformat."]
    pub sample_aspect_ratio: AVRational,
    pub metadata: *mut AVDictionary,
    #[doc = " Average framerate"]
    #[doc = ""]
    #[doc = " - demuxing: May be set by libavformat when creating the stream or in"]
    #[doc = "             avformat_find_stream_info()."]
    #[doc = " - muxing: May be set by the caller before avformat_write_header()."]
    pub avg_frame_rate: AVRational,
    #[doc = " For streams with AV_DISPOSITION_ATTACHED_PIC disposition, this packet"]
    #[doc = " will contain the attached picture."]
    #[doc = ""]
    #[doc = " decoding: set by libavformat, must not be modified by the caller."]
    #[doc = " encoding: unused"]
    pub attached_pic: AVPacket,
    #[doc = " An array of side data that applies to the whole stream (i.e. the"]
    #[doc = " container does not allow it to change between packets)."]
    #[doc = ""]
    #[doc = " There may be no overlap between the side data in this array and side data"]
    #[doc = " in the packets. I.e. a given side data is either exported by the muxer"]
    #[doc = " (demuxing) / set by the caller (muxing) in this array, then it never"]
    #[doc = " appears in the packets, or the side data is exported / sent through"]
    #[doc = " the packets (always in the first packet where the value becomes known or"]
    #[doc = " changes), then it does not appear in this array."]
    #[doc = ""]
    #[doc = " - demuxing: Set by libavformat when the stream is created."]
    #[doc = " - muxing: May be set by the caller before avformat_write_header()."]
    #[doc = ""]
    #[doc = " Freed by libavformat in avformat_free_context()."]
    #[doc = ""]
    #[doc = " @see av_format_inject_global_side_data()"]
    pub side_data: *mut AVPacketSideData,
    #[doc = " The number of elements in the AVStream.side_data array."]
    pub nb_side_data: ::std::os::raw::c_int,
    #[doc = " Flags for the user to detect events happening on the stream. Flags must"]
    #[doc = " be cleared by the user once the event has been handled."]
    #[doc = " A combination of AVSTREAM_EVENT_FLAG_*."]
    pub event_flags: ::std::os::raw::c_int,
    pub info: *mut AVStream__bindgen_ty_1,
    #[doc = "< number of bits in pts (used for wrapping control)"]
    pub pts_wrap_bits: ::std::os::raw::c_int,
    #[doc = " Timestamp corresponding to the last dts sync point."]
    #[doc = ""]
    #[doc = " Initialized when AVCodecParserContext.dts_sync_point >= 0 and"]
    #[doc = " a DTS is received from the underlying container. Otherwise set to"]
    #[doc = " AV_NOPTS_VALUE by default."]
    pub first_dts: i64,
    pub cur_dts: i64,
    pub last_IP_pts: i64,
    pub last_IP_duration: ::std::os::raw::c_int,
    #[doc = " Number of packets to buffer for codec probing"]
    pub probe_packets: ::std::os::raw::c_int,
    #[doc = " Number of frames that have been demuxed during avformat_find_stream_info()"]
    pub codec_info_nb_frames: ::std::os::raw::c_int,
    pub need_parsing: AVStreamParseType,
    pub parser: *mut AVCodecParserContext,
    #[doc = " last packet in packet_buffer for this stream when muxing."]
    pub last_in_packet_buffer: *mut AVPacketList,
    pub probe_data: AVProbeData,
    pub pts_buffer: [i64; 17usize],
    #[doc = "< Only used if the format does not"]
    #[doc = "support seeking natively."]
    pub index_entries: *mut AVIndexEntry,
    pub nb_index_entries: ::std::os::raw::c_int,
    pub index_entries_allocated_size: ::std::os::raw::c_uint,
    #[doc = " Real base framerate of the stream."]
    #[doc = " This is the lowest framerate with which all timestamps can be"]
    #[doc = " represented accurately (it is the least common multiple of all"]
    #[doc = " framerates in the stream). Note, this value is just a guess!"]
    #[doc = " For example, if the time base is 1/90000 and all frames have either"]
    #[doc = " approximately 3600 or 1800 timer ticks, then r_frame_rate will be 50/1."]
    #[doc = ""]
    #[doc = " Code outside avformat should access this field using:"]
    #[doc = " av_stream_get/set_r_frame_rate(stream)"]
    pub r_frame_rate: AVRational,
    #[doc = " Stream Identifier"]
    #[doc = " This is the MPEG-TS stream identifier +1"]
    #[doc = " 0 means unknown"]
    pub stream_identifier: ::std::os::raw::c_int,
    pub interleaver_chunk_size: i64,
    pub interleaver_chunk_duration: i64,
    #[doc = " stream probing state"]
    #[doc = " -1   -> probing finished"]
    #[doc = "  0   -> no probing requested"]
    #[doc = " rest -> perform probing with request_probe being the minimum score to accept."]
    #[doc = " NOT PART OF PUBLIC API"]
    pub request_probe: ::std::os::raw::c_int,
    #[doc = " Indicates that everything up to the next keyframe"]
    #[doc = " should be discarded."]
    pub skip_to_keyframe: ::std::os::raw::c_int,
    #[doc = " Number of samples to skip at the start of the frame decoded from the next packet."]
    pub skip_samples: ::std::os::raw::c_int,
    #[doc = " If not 0, the number of samples that should be skipped from the start of"]
    #[doc = " the stream (the samples are removed from packets with pts==0, which also"]
    #[doc = " assumes negative timestamps do not happen)."]
    #[doc = " Intended for use with formats such as mp3 with ad-hoc gapless audio"]
    #[doc = " support."]
    pub start_skip_samples: i64,
    #[doc = " If not 0, the first audio sample that should be discarded from the stream."]
    #[doc = " This is broken by design (needs global sample count), but can't be"]
    #[doc = " avoided for broken by design formats such as mp3 with ad-hoc gapless"]
    #[doc = " audio support."]
    pub first_discard_sample: i64,
    #[doc = " The sample after last sample that is intended to be discarded after"]
    #[doc = " first_discard_sample. Works on frame boundaries only. Used to prevent"]
    #[doc = " early EOF if the gapless info is broken (considered concatenated mp3s)."]
    pub last_discard_sample: i64,
    #[doc = " Number of internally decoded frames, used internally in libavformat, do not access"]
    #[doc = " its lifetime differs from info which is why it is not in that structure."]
    pub nb_decoded_frames: ::std::os::raw::c_int,
    #[doc = " Timestamp offset added to timestamps before muxing"]
    #[doc = " NOT PART OF PUBLIC API"]
    pub mux_ts_offset: i64,
    #[doc = " Internal data to check for wrapping of the time stamp"]
    pub pts_wrap_reference: i64,
    #[doc = " Options for behavior, when a wrap is detected."]
    #[doc = ""]
    #[doc = " Defined by AV_PTS_WRAP_ values."]
    #[doc = ""]
    #[doc = " If correction is enabled, there are two possibilities:"]
    #[doc = " If the first time stamp is near the wrap point, the wrap offset"]
    #[doc = " will be subtracted, which will create negative time stamps."]
    #[doc = " Otherwise the offset will be added."]
    pub pts_wrap_behavior: ::std::os::raw::c_int,
    #[doc = " Internal data to prevent doing update_initial_durations() twice"]
    pub update_initial_durations_done: ::std::os::raw::c_int,
    #[doc = " Internal data to generate dts from pts"]
    pub pts_reorder_error: [i64; 17usize],
    pub pts_reorder_error_count: [u8; 17usize],
    #[doc = " Internal data to analyze DTS and detect faulty mpeg streams"]
    pub last_dts_for_order_check: i64,
    pub dts_ordered: u8,
    pub dts_misordered: u8,
    #[doc = " Internal data to inject global side data"]
    pub inject_global_side_data: ::std::os::raw::c_int,
    #[doc = " String containing paris of key and values describing recommended encoder configuration."]
    #[doc = " Paris are separated by ','."]
    #[doc = " Keys are separated from values by '='."]
    pub recommended_encoder_configuration: *mut ::std::os::raw::c_char,
    #[doc = " display aspect ratio (0 if unknown)"]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: Set by libavformat to calculate sample_aspect_ratio internally"]
    pub display_aspect_ratio: AVRational,
    pub priv_pts: *mut FFFrac,
    #[doc = " An opaque field for libavformat internal usage."]
    #[doc = " Must not be accessed in any way by callers."]
    pub internal: *mut AVStreamInternal,
    pub codecpar: *mut AVCodecParameters,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVStream__bindgen_ty_1 {
    pub last_dts: i64,
    pub duration_gcd: i64,
    pub duration_count: ::std::os::raw::c_int,
    pub rfps_duration_sum: i64,
    pub duration_error: *mut [[f64; 399usize]; 2usize],
    pub codec_info_duration: i64,
    pub codec_info_duration_fields: i64,
    #[doc = " 0  -> decoder has not been searched for yet."]
    #[doc = " >0 -> decoder found"]
    #[doc = " <0 -> decoder with codec_id == -found_decoder has not been found"]
    pub found_decoder: ::std::os::raw::c_int,
    pub last_duration: i64,
    #[doc = " Those are used for average framerate estimation."]
    pub fps_first_dts: i64,
    pub fps_first_dts_idx: ::std::os::raw::c_int,
    pub fps_last_dts: i64,
    pub fps_last_dts_idx: ::std::os::raw::c_int,
}
extern "C" {
    pub fn av_stream_get_r_frame_rate(s: *const AVStream) -> AVRational;
}
extern "C" {
    pub fn av_stream_set_r_frame_rate(s: *mut AVStream, r: AVRational);
}
extern "C" {
    pub fn av_stream_get_parser(s: *const AVStream) -> *mut AVCodecParserContext;
}
extern "C" {
    pub fn av_stream_get_recommended_encoder_configuration(
        s: *const AVStream,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_stream_set_recommended_encoder_configuration(
        s: *mut AVStream,
        configuration: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Returns the pts of the last muxed packet + its duration"]
    #[doc = ""]
    #[doc = " the retuned value is undefined when used with a demuxer."]
    pub fn av_stream_get_end_pts(st: *const AVStream) -> i64;
}
#[doc = " New fields can be added to the end with minor version bumps."]
#[doc = " Removal, reordering and changes to existing fields require a major"]
#[doc = " version bump."]
#[doc = " sizeof(AVProgram) must not be used outside libav*."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVProgram {
    pub id: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
    #[doc = "< selects which program to discard and which to feed to the caller"]
    pub discard: AVDiscard,
    pub stream_index: *mut ::std::os::raw::c_uint,
    pub nb_stream_indexes: ::std::os::raw::c_uint,
    pub metadata: *mut AVDictionary,
    pub program_num: ::std::os::raw::c_int,
    pub pmt_pid: ::std::os::raw::c_int,
    pub pcr_pid: ::std::os::raw::c_int,
    #[doc = " All fields below this line are not part of the public API. They"]
    #[doc = " may not be used outside of libavformat and can be changed and"]
    #[doc = " removed at will."]
    #[doc = " New public fields should be added right above."]
    #[doc = ""]
    pub start_time: i64,
    pub end_time: i64,
    #[doc = "< reference dts for wrap detection"]
    pub pts_wrap_reference: i64,
    #[doc = "< behavior on wrap detection"]
    pub pts_wrap_behavior: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVChapter {
    #[doc = "< unique ID to identify the chapter"]
    pub id: ::std::os::raw::c_int,
    #[doc = "< time base in which the start/end timestamps are specified"]
    pub time_base: AVRational,
    #[doc = "< chapter start/end time in time_base units"]
    pub start: i64,
    #[doc = "< chapter start/end time in time_base units"]
    pub end: i64,
    pub metadata: *mut AVDictionary,
}
#[doc = " Callback used by devices to communicate with application."]
pub type av_format_control_message = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut AVFormatContext,
        type_: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
        data_size: usize,
    ) -> ::std::os::raw::c_int,
>;
pub type AVOpenCallback = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut AVFormatContext,
        pb: *mut *mut AVIOContext,
        url: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        int_cb: *const AVIOInterruptCB,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int,
>;
#[doc = "< Duration accurately estimated from PTSes"]
pub const AVDurationEstimationMethod_AVFMT_DURATION_FROM_PTS: AVDurationEstimationMethod = 0;
#[doc = "< Duration estimated from a stream with a known duration"]
pub const AVDurationEstimationMethod_AVFMT_DURATION_FROM_STREAM: AVDurationEstimationMethod = 1;
#[doc = "< Duration estimated from bitrate (less accurate)"]
pub const AVDurationEstimationMethod_AVFMT_DURATION_FROM_BITRATE: AVDurationEstimationMethod = 2;
#[doc = " The duration of a video can be estimated through various ways, and this enum can be used"]
#[doc = " to know how the duration was estimated."]
pub type AVDurationEstimationMethod = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFormatInternal {
    _unused: [u8; 0],
}
#[doc = " Format I/O context."]
#[doc = " New fields can be added to the end with minor version bumps."]
#[doc = " Removal, reordering and changes to existing fields require a major"]
#[doc = " version bump."]
#[doc = " sizeof(AVFormatContext) must not be used outside libav*, use"]
#[doc = " avformat_alloc_context() to create an AVFormatContext."]
#[doc = ""]
#[doc = " Fields can be accessed through AVOptions (av_opt*),"]
#[doc = " the name string used matches the associated command line parameter name and"]
#[doc = " can be found in libavformat/options_table.h."]
#[doc = " The AVOption/command line parameter names differ in some cases from the C"]
#[doc = " structure field names for historic reasons or brevity."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVFormatContext {
    #[doc = " A class for logging and @ref avoptions. Set by avformat_alloc_context()."]
    #[doc = " Exports (de)muxer private options if they exist."]
    pub av_class: *const AVClass,
    #[doc = " The input container format."]
    #[doc = ""]
    #[doc = " Demuxing only, set by avformat_open_input()."]
    pub iformat: *mut AVInputFormat,
    #[doc = " The output container format."]
    #[doc = ""]
    #[doc = " Muxing only, must be set by the caller before avformat_write_header()."]
    pub oformat: *mut AVOutputFormat,
    #[doc = " Format private data. This is an AVOptions-enabled struct"]
    #[doc = " if and only if iformat/oformat.priv_class is not NULL."]
    #[doc = ""]
    #[doc = " - muxing: set by avformat_write_header()"]
    #[doc = " - demuxing: set by avformat_open_input()"]
    pub priv_data: *mut ::std::os::raw::c_void,
    #[doc = " I/O context."]
    #[doc = ""]
    #[doc = " - demuxing: either set by the user before avformat_open_input() (then"]
    #[doc = "             the user must close it manually) or set by avformat_open_input()."]
    #[doc = " - muxing: set by the user before avformat_write_header(). The caller must"]
    #[doc = "           take care of closing / freeing the IO context."]
    #[doc = ""]
    #[doc = " Do NOT set this field if AVFMT_NOFILE flag is set in"]
    #[doc = " iformat/oformat.flags. In such a case, the (de)muxer will handle"]
    #[doc = " I/O in some other way and this field will be NULL."]
    pub pb: *mut AVIOContext,
    #[doc = " Flags signalling stream properties. A combination of AVFMTCTX_*."]
    #[doc = " Set by libavformat."]
    pub ctx_flags: ::std::os::raw::c_int,
    #[doc = " Number of elements in AVFormatContext.streams."]
    #[doc = ""]
    #[doc = " Set by avformat_new_stream(), must not be modified by any other code."]
    pub nb_streams: ::std::os::raw::c_uint,
    #[doc = " A list of all streams in the file. New streams are created with"]
    #[doc = " avformat_new_stream()."]
    #[doc = ""]
    #[doc = " - demuxing: streams are created by libavformat in avformat_open_input()."]
    #[doc = "             If AVFMTCTX_NOHEADER is set in ctx_flags, then new streams may also"]
    #[doc = "             appear in av_read_frame()."]
    #[doc = " - muxing: streams are created by the user before avformat_write_header()."]
    #[doc = ""]
    #[doc = " Freed by libavformat in avformat_free_context()."]
    pub streams: *mut *mut AVStream,
    #[doc = " input or output filename"]
    #[doc = ""]
    #[doc = " - demuxing: set by avformat_open_input()"]
    #[doc = " - muxing: may be set by the caller before avformat_write_header()"]
    pub filename: [::std::os::raw::c_char; 1024usize],
    #[doc = " Position of the first frame of the component, in"]
    #[doc = " AV_TIME_BASE fractional seconds. NEVER set this value directly:"]
    #[doc = " It is deduced from the AVStream values."]
    #[doc = ""]
    #[doc = " Demuxing only, set by libavformat."]
    pub start_time: i64,
    #[doc = " Duration of the stream, in AV_TIME_BASE fractional"]
    #[doc = " seconds. Only set this value if you know none of the individual stream"]
    #[doc = " durations and also do not set any of them. This is deduced from the"]
    #[doc = " AVStream values if not set."]
    #[doc = ""]
    #[doc = " Demuxing only, set by libavformat."]
    pub duration: i64,
    #[doc = " Total stream bitrate in bit/s, 0 if not"]
    #[doc = " available. Never set it directly if the file_size and the"]
    #[doc = " duration are known as FFmpeg can compute it automatically."]
    pub bit_rate: i64,
    pub packet_size: ::std::os::raw::c_uint,
    pub max_delay: ::std::os::raw::c_int,
    #[doc = " Flags modifying the (de)muxer behaviour. A combination of AVFMT_FLAG_*."]
    #[doc = " Set by the user before avformat_open_input() / avformat_write_header()."]
    pub flags: ::std::os::raw::c_int,
    #[doc = " Maximum size of the data read from input for determining"]
    #[doc = " the input container format."]
    #[doc = " Demuxing only, set by the caller before avformat_open_input()."]
    pub probesize: i64,
    #[doc = " Maximum duration (in AV_TIME_BASE units) of the data read"]
    #[doc = " from input in avformat_find_stream_info()."]
    #[doc = " Demuxing only, set by the caller before avformat_find_stream_info()."]
    #[doc = " Can be set to 0 to let avformat choose using a heuristic."]
    pub max_analyze_duration: i64,
    pub key: *const u8,
    pub keylen: ::std::os::raw::c_int,
    pub nb_programs: ::std::os::raw::c_uint,
    pub programs: *mut *mut AVProgram,
    #[doc = " Forced video codec_id."]
    #[doc = " Demuxing: Set by user."]
    pub video_codec_id: AVCodecID,
    #[doc = " Forced audio codec_id."]
    #[doc = " Demuxing: Set by user."]
    pub audio_codec_id: AVCodecID,
    #[doc = " Forced subtitle codec_id."]
    #[doc = " Demuxing: Set by user."]
    pub subtitle_codec_id: AVCodecID,
    #[doc = " Maximum amount of memory in bytes to use for the index of each stream."]
    #[doc = " If the index exceeds this size, entries will be discarded as"]
    #[doc = " needed to maintain a smaller size. This can lead to slower or less"]
    #[doc = " accurate seeking (depends on demuxer)."]
    #[doc = " Demuxers for which a full in-memory index is mandatory will ignore"]
    #[doc = " this."]
    #[doc = " - muxing: unused"]
    #[doc = " - demuxing: set by user"]
    pub max_index_size: ::std::os::raw::c_uint,
    #[doc = " Maximum amount of memory in bytes to use for buffering frames"]
    #[doc = " obtained from realtime capture devices."]
    pub max_picture_buffer: ::std::os::raw::c_uint,
    #[doc = " Number of chapters in AVChapter array."]
    #[doc = " When muxing, chapters are normally written in the file header,"]
    #[doc = " so nb_chapters should normally be initialized before write_header"]
    #[doc = " is called. Some muxers (e.g. mov and mkv) can also write chapters"]
    #[doc = " in the trailer.  To write chapters in the trailer, nb_chapters"]
    #[doc = " must be zero when write_header is called and non-zero when"]
    #[doc = " write_trailer is called."]
    #[doc = " - muxing: set by user"]
    #[doc = " - demuxing: set by libavformat"]
    pub nb_chapters: ::std::os::raw::c_uint,
    pub chapters: *mut *mut AVChapter,
    #[doc = " Metadata that applies to the whole file."]
    #[doc = ""]
    #[doc = " - demuxing: set by libavformat in avformat_open_input()"]
    #[doc = " - muxing: may be set by the caller before avformat_write_header()"]
    #[doc = ""]
    #[doc = " Freed by libavformat in avformat_free_context()."]
    pub metadata: *mut AVDictionary,
    #[doc = " Start time of the stream in real world time, in microseconds"]
    #[doc = " since the Unix epoch (00:00 1st January 1970). That is, pts=0 in the"]
    #[doc = " stream was captured at this real world time."]
    #[doc = " - muxing: Set by the caller before avformat_write_header(). If set to"]
    #[doc = "           either 0 or AV_NOPTS_VALUE, then the current wall-time will"]
    #[doc = "           be used."]
    #[doc = " - demuxing: Set by libavformat. AV_NOPTS_VALUE if unknown. Note that"]
    #[doc = "             the value may become known after some number of frames"]
    #[doc = "             have been received."]
    pub start_time_realtime: i64,
    #[doc = " The number of frames used for determining the framerate in"]
    #[doc = " avformat_find_stream_info()."]
    #[doc = " Demuxing only, set by the caller before avformat_find_stream_info()."]
    pub fps_probe_size: ::std::os::raw::c_int,
    #[doc = " Error recognition; higher values will detect more errors but may"]
    #[doc = " misdetect some more or less valid parts as errors."]
    #[doc = " Demuxing only, set by the caller before avformat_open_input()."]
    pub error_recognition: ::std::os::raw::c_int,
    #[doc = " Custom interrupt callbacks for the I/O layer."]
    #[doc = ""]
    #[doc = " demuxing: set by the user before avformat_open_input()."]
    #[doc = " muxing: set by the user before avformat_write_header()"]
    #[doc = " (mainly useful for AVFMT_NOFILE formats). The callback"]
    #[doc = " should also be passed to avio_open2() if it's used to"]
    #[doc = " open the file."]
    pub interrupt_callback: AVIOInterruptCB,
    #[doc = " Flags to enable debugging."]
    pub debug: ::std::os::raw::c_int,
    #[doc = " Maximum buffering duration for interleaving."]
    #[doc = ""]
    #[doc = " To ensure all the streams are interleaved correctly,"]
    #[doc = " av_interleaved_write_frame() will wait until it has at least one packet"]
    #[doc = " for each stream before actually writing any packets to the output file."]
    #[doc = " When some streams are \"sparse\" (i.e. there are large gaps between"]
    #[doc = " successive packets), this can result in excessive buffering."]
    #[doc = ""]
    #[doc = " This field specifies the maximum difference between the timestamps of the"]
    #[doc = " first and the last packet in the muxing queue, above which libavformat"]
    #[doc = " will output a packet regardless of whether it has queued a packet for all"]
    #[doc = " the streams."]
    #[doc = ""]
    #[doc = " Muxing only, set by the caller before avformat_write_header()."]
    pub max_interleave_delta: i64,
    #[doc = " Allow non-standard and experimental extension"]
    #[doc = " @see AVCodecContext.strict_std_compliance"]
    pub strict_std_compliance: ::std::os::raw::c_int,
    #[doc = " Flags for the user to detect events happening on the file. Flags must"]
    #[doc = " be cleared by the user once the event has been handled."]
    #[doc = " A combination of AVFMT_EVENT_FLAG_*."]
    pub event_flags: ::std::os::raw::c_int,
    #[doc = " Maximum number of packets to read while waiting for the first timestamp."]
    #[doc = " Decoding only."]
    pub max_ts_probe: ::std::os::raw::c_int,
    #[doc = " Avoid negative timestamps during muxing."]
    #[doc = " Any value of the AVFMT_AVOID_NEG_TS_* constants."]
    #[doc = " Note, this only works when using av_interleaved_write_frame. (interleave_packet_per_dts is in use)"]
    #[doc = " - muxing: Set by user"]
    #[doc = " - demuxing: unused"]
    pub avoid_negative_ts: ::std::os::raw::c_int,
    #[doc = " Transport stream id."]
    #[doc = " This will be moved into demuxer private options. Thus no API/ABI compatibility"]
    pub ts_id: ::std::os::raw::c_int,
    #[doc = " Audio preload in microseconds."]
    #[doc = " Note, not all formats support this and unpredictable things may happen if it is used when not supported."]
    #[doc = " - encoding: Set by user"]
    #[doc = " - decoding: unused"]
    pub audio_preload: ::std::os::raw::c_int,
    #[doc = " Max chunk time in microseconds."]
    #[doc = " Note, not all formats support this and unpredictable things may happen if it is used when not supported."]
    #[doc = " - encoding: Set by user"]
    #[doc = " - decoding: unused"]
    pub max_chunk_duration: ::std::os::raw::c_int,
    #[doc = " Max chunk size in bytes"]
    #[doc = " Note, not all formats support this and unpredictable things may happen if it is used when not supported."]
    #[doc = " - encoding: Set by user"]
    #[doc = " - decoding: unused"]
    pub max_chunk_size: ::std::os::raw::c_int,
    #[doc = " forces the use of wallclock timestamps as pts/dts of packets"]
    #[doc = " This has undefined results in the presence of B frames."]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: Set by user"]
    pub use_wallclock_as_timestamps: ::std::os::raw::c_int,
    #[doc = " avio flags, used to force AVIO_FLAG_DIRECT."]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: Set by user"]
    pub avio_flags: ::std::os::raw::c_int,
    #[doc = " The duration field can be estimated through various ways, and this field can be used"]
    #[doc = " to know how the duration was estimated."]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: Read by user"]
    pub duration_estimation_method: AVDurationEstimationMethod,
    #[doc = " Skip initial bytes when opening stream"]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: Set by user"]
    pub skip_initial_bytes: i64,
    #[doc = " Correct single timestamp overflows"]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: Set by user"]
    pub correct_ts_overflow: ::std::os::raw::c_uint,
    #[doc = " Force seeking to any (also non key) frames."]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: Set by user"]
    pub seek2any: ::std::os::raw::c_int,
    #[doc = " Flush the I/O context after each packet."]
    #[doc = " - encoding: Set by user"]
    #[doc = " - decoding: unused"]
    pub flush_packets: ::std::os::raw::c_int,
    #[doc = " format probing score."]
    #[doc = " The maximal score is AVPROBE_SCORE_MAX, its set when the demuxer probes"]
    #[doc = " the format."]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: set by avformat, read by user"]
    pub probe_score: ::std::os::raw::c_int,
    #[doc = " number of bytes to read maximally to identify format."]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: set by user"]
    pub format_probesize: ::std::os::raw::c_int,
    #[doc = " ',' separated list of allowed decoders."]
    #[doc = " If NULL then all are allowed"]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: set by user"]
    pub codec_whitelist: *mut ::std::os::raw::c_char,
    #[doc = " ',' separated list of allowed demuxers."]
    #[doc = " If NULL then all are allowed"]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: set by user"]
    pub format_whitelist: *mut ::std::os::raw::c_char,
    #[doc = " An opaque field for libavformat internal usage."]
    #[doc = " Must not be accessed in any way by callers."]
    pub internal: *mut AVFormatInternal,
    #[doc = " IO repositioned flag."]
    #[doc = " This is set by avformat when the underlaying IO context read pointer"]
    #[doc = " is repositioned, for example when doing byte based seeking."]
    #[doc = " Demuxers can use the flag to detect such changes."]
    pub io_repositioned: ::std::os::raw::c_int,
    #[doc = " Forced video codec."]
    #[doc = " This allows forcing a specific decoder, even when there are multiple with"]
    #[doc = " the same codec_id."]
    #[doc = " Demuxing: Set by user"]
    pub video_codec: *mut AVCodec,
    #[doc = " Forced audio codec."]
    #[doc = " This allows forcing a specific decoder, even when there are multiple with"]
    #[doc = " the same codec_id."]
    #[doc = " Demuxing: Set by user"]
    pub audio_codec: *mut AVCodec,
    #[doc = " Forced subtitle codec."]
    #[doc = " This allows forcing a specific decoder, even when there are multiple with"]
    #[doc = " the same codec_id."]
    #[doc = " Demuxing: Set by user"]
    pub subtitle_codec: *mut AVCodec,
    #[doc = " Forced data codec."]
    #[doc = " This allows forcing a specific decoder, even when there are multiple with"]
    #[doc = " the same codec_id."]
    #[doc = " Demuxing: Set by user"]
    pub data_codec: *mut AVCodec,
    #[doc = " Number of bytes to be written as padding in a metadata header."]
    #[doc = " Demuxing: Unused."]
    #[doc = " Muxing: Set by user via av_format_set_metadata_header_padding."]
    pub metadata_header_padding: ::std::os::raw::c_int,
    #[doc = " User data."]
    #[doc = " This is a place for some private data of the user."]
    pub opaque: *mut ::std::os::raw::c_void,
    #[doc = " Callback used by devices to communicate with application."]
    pub control_message_cb: av_format_control_message,
    #[doc = " Output timestamp offset, in microseconds."]
    #[doc = " Muxing: set by user"]
    pub output_ts_offset: i64,
    #[doc = " dump format separator."]
    #[doc = " can be \", \" or \"\\n      \" or anything else"]
    #[doc = " - muxing: Set by user."]
    #[doc = " - demuxing: Set by user."]
    pub dump_separator: *mut u8,
    #[doc = " Forced Data codec_id."]
    #[doc = " Demuxing: Set by user."]
    pub data_codec_id: AVCodecID,
    #[doc = " Called to open further IO contexts when needed for demuxing."]
    #[doc = ""]
    #[doc = " This can be set by the user application to perform security checks on"]
    #[doc = " the URLs before opening them."]
    #[doc = " The function should behave like avio_open2(), AVFormatContext is provided"]
    #[doc = " as contextual information and to reach AVFormatContext.opaque."]
    #[doc = ""]
    #[doc = " If NULL then some simple checks are used together with avio_open2()."]
    #[doc = ""]
    #[doc = " Must not be accessed directly from outside avformat."]
    #[doc = " @See av_format_set_open_cb()"]
    #[doc = ""]
    #[doc = " Demuxing: Set by user."]
    #[doc = ""]
    #[doc = " @deprecated Use io_open and io_close."]
    pub open_cb: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            p: *mut *mut AVIOContext,
            url: *const ::std::os::raw::c_char,
            flags: ::std::os::raw::c_int,
            int_cb: *const AVIOInterruptCB,
            options: *mut *mut AVDictionary,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " ',' separated list of allowed protocols."]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: set by user"]
    pub protocol_whitelist: *mut ::std::os::raw::c_char,
    pub io_open: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            pb: *mut *mut AVIOContext,
            url: *const ::std::os::raw::c_char,
            flags: ::std::os::raw::c_int,
            options: *mut *mut AVDictionary,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " A callback for closing the streams opened with AVFormatContext.io_open()."]
    pub io_close:
        ::std::option::Option<unsafe extern "C" fn(s: *mut AVFormatContext, pb: *mut AVIOContext)>,
    #[doc = " ',' separated list of disallowed protocols."]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: set by user"]
    pub protocol_blacklist: *mut ::std::os::raw::c_char,
    #[doc = " The maximum number of streams."]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: set by user"]
    pub max_streams: ::std::os::raw::c_int,
}
extern "C" {
    #[doc = " Accessors for some AVFormatContext fields. These used to be provided for ABI"]
    #[doc = " compatibility, and do not need to be used anymore."]
    pub fn av_format_get_probe_score(s: *const AVFormatContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_format_get_video_codec(s: *const AVFormatContext) -> *mut AVCodec;
}
extern "C" {
    pub fn av_format_set_video_codec(s: *mut AVFormatContext, c: *mut AVCodec);
}
extern "C" {
    pub fn av_format_get_audio_codec(s: *const AVFormatContext) -> *mut AVCodec;
}
extern "C" {
    pub fn av_format_set_audio_codec(s: *mut AVFormatContext, c: *mut AVCodec);
}
extern "C" {
    pub fn av_format_get_subtitle_codec(s: *const AVFormatContext) -> *mut AVCodec;
}
extern "C" {
    pub fn av_format_set_subtitle_codec(s: *mut AVFormatContext, c: *mut AVCodec);
}
extern "C" {
    pub fn av_format_get_data_codec(s: *const AVFormatContext) -> *mut AVCodec;
}
extern "C" {
    pub fn av_format_set_data_codec(s: *mut AVFormatContext, c: *mut AVCodec);
}
extern "C" {
    pub fn av_format_get_metadata_header_padding(
        s: *const AVFormatContext,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_format_set_metadata_header_padding(s: *mut AVFormatContext, c: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_format_get_opaque(s: *const AVFormatContext) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_format_set_opaque(s: *mut AVFormatContext, opaque: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn av_format_get_control_message_cb(s: *const AVFormatContext)
        -> av_format_control_message;
}
extern "C" {
    pub fn av_format_set_control_message_cb(
        s: *mut AVFormatContext,
        callback: av_format_control_message,
    );
}
extern "C" {
    pub fn av_format_get_open_cb(s: *const AVFormatContext) -> AVOpenCallback;
}
extern "C" {
    pub fn av_format_set_open_cb(s: *mut AVFormatContext, callback: AVOpenCallback);
}
extern "C" {
    #[doc = " This function will cause global side data to be injected in the next packet"]
    #[doc = " of each stream as well as after any subsequent seek."]
    pub fn av_format_inject_global_side_data(s: *mut AVFormatContext);
}
extern "C" {
    #[doc = " Returns the method used to set ctx->duration."]
    #[doc = ""]
    #[doc = " @return AVFMT_DURATION_FROM_PTS, AVFMT_DURATION_FROM_STREAM, or AVFMT_DURATION_FROM_BITRATE."]
    pub fn av_fmt_ctx_get_duration_estimation_method(
        ctx: *const AVFormatContext,
    ) -> AVDurationEstimationMethod;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVPacketList {
    pub pkt: AVPacket,
    pub next: *mut AVPacketList,
}
extern "C" {
    #[doc = " Return the LIBAVFORMAT_VERSION_INT constant."]
    pub fn avformat_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return the libavformat build-time configuration."]
    pub fn avformat_configuration() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the libavformat license."]
    pub fn avformat_license() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Initialize libavformat and register all the muxers, demuxers and"]
    #[doc = " protocols. If you do not call this function, then you can select"]
    #[doc = " exactly which formats you want to support."]
    #[doc = ""]
    #[doc = " @see av_register_input_format()"]
    #[doc = " @see av_register_output_format()"]
    pub fn av_register_all();
}
extern "C" {
    pub fn av_register_input_format(format: *mut AVInputFormat);
}
extern "C" {
    pub fn av_register_output_format(format: *mut AVOutputFormat);
}
extern "C" {
    #[doc = " Do global initialization of network components. This is optional,"]
    #[doc = " but recommended, since it avoids the overhead of implicitly"]
    #[doc = " doing the setup for each session."]
    #[doc = ""]
    #[doc = " Calling this function will become mandatory if using network"]
    #[doc = " protocols at some major version bump."]
    pub fn avformat_network_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Undo the initialization done by avformat_network_init."]
    pub fn avformat_network_deinit() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " If f is NULL, returns the first registered input format,"]
    #[doc = " if f is non-NULL, returns the next registered input format after f"]
    #[doc = " or NULL if f is the last one."]
    pub fn av_iformat_next(f: *const AVInputFormat) -> *mut AVInputFormat;
}
extern "C" {
    #[doc = " If f is NULL, returns the first registered output format,"]
    #[doc = " if f is non-NULL, returns the next registered output format after f"]
    #[doc = " or NULL if f is the last one."]
    pub fn av_oformat_next(f: *const AVOutputFormat) -> *mut AVOutputFormat;
}
extern "C" {
    #[doc = " Allocate an AVFormatContext."]
    #[doc = " avformat_free_context() can be used to free the context and everything"]
    #[doc = " allocated by the framework within it."]
    pub fn avformat_alloc_context() -> *mut AVFormatContext;
}
extern "C" {
    #[doc = " Free an AVFormatContext and all its streams."]
    #[doc = " @param s context to free"]
    pub fn avformat_free_context(s: *mut AVFormatContext);
}
extern "C" {
    #[doc = " Get the AVClass for AVFormatContext. It can be used in combination with"]
    #[doc = " AV_OPT_SEARCH_FAKE_OBJ for examining options."]
    #[doc = ""]
    #[doc = " @see av_opt_find()."]
    pub fn avformat_get_class() -> *const AVClass;
}
extern "C" {
    #[doc = " Add a new stream to a media file."]
    #[doc = ""]
    #[doc = " When demuxing, it is called by the demuxer in read_header(). If the"]
    #[doc = " flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also"]
    #[doc = " be called in read_packet()."]
    #[doc = ""]
    #[doc = " When muxing, should be called by the user before avformat_write_header()."]
    #[doc = ""]
    #[doc = " User is required to call avcodec_close() and avformat_free_context() to"]
    #[doc = " clean up the allocation by avformat_new_stream()."]
    #[doc = ""]
    #[doc = " @param s media file handle"]
    #[doc = " @param c If non-NULL, the AVCodecContext corresponding to the new stream"]
    #[doc = " will be initialized to use this codec. This is needed for e.g. codec-specific"]
    #[doc = " defaults to be set, so codec should be provided if it is known."]
    #[doc = ""]
    #[doc = " @return newly created stream or NULL on error."]
    pub fn avformat_new_stream(s: *mut AVFormatContext, c: *const AVCodec) -> *mut AVStream;
}
extern "C" {
    #[doc = " Wrap an existing array as stream side data."]
    #[doc = ""]
    #[doc = " @param st stream"]
    #[doc = " @param type side information type"]
    #[doc = " @param data the side data array. It must be allocated with the av_malloc()"]
    #[doc = "             family of functions. The ownership of the data is transferred to"]
    #[doc = "             st."]
    #[doc = " @param size side information size"]
    #[doc = " @return zero on success, a negative AVERROR code on failure. On failure,"]
    #[doc = "         the stream is unchanged and the data remains owned by the caller."]
    pub fn av_stream_add_side_data(
        st: *mut AVStream,
        type_: AVPacketSideDataType,
        data: *mut u8,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate new information from stream."]
    #[doc = ""]
    #[doc = " @param stream stream"]
    #[doc = " @param type desired side information type"]
    #[doc = " @param size side information size"]
    #[doc = " @return pointer to fresh allocated data or NULL otherwise"]
    pub fn av_stream_new_side_data(
        stream: *mut AVStream,
        type_: AVPacketSideDataType,
        size: ::std::os::raw::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn av_stream_get_side_data(
        stream: *mut AVStream,
        type_: AVPacketSideDataType,
        size: *mut ::std::os::raw::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn av_new_program(s: *mut AVFormatContext, id: ::std::os::raw::c_int) -> *mut AVProgram;
}
extern "C" {
    #[doc = " Allocate an AVFormatContext for an output format."]
    #[doc = " avformat_free_context() can be used to free the context and"]
    #[doc = " everything allocated by the framework within it."]
    #[doc = ""]
    #[doc = " @param *ctx is set to the created format context, or to NULL in"]
    #[doc = " case of failure"]
    #[doc = " @param oformat format to use for allocating the context, if NULL"]
    #[doc = " format_name and filename are used instead"]
    #[doc = " @param format_name the name of output format to use for allocating the"]
    #[doc = " context, if NULL filename is used instead"]
    #[doc = " @param filename the name of the filename to use for allocating the"]
    #[doc = " context, may be NULL"]
    #[doc = " @return >= 0 in case of success, a negative AVERROR code in case of"]
    #[doc = " failure"]
    pub fn avformat_alloc_output_context2(
        ctx: *mut *mut AVFormatContext,
        oformat: *mut AVOutputFormat,
        format_name: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find AVInputFormat based on the short name of the input format."]
    pub fn av_find_input_format(short_name: *const ::std::os::raw::c_char) -> *mut AVInputFormat;
}
extern "C" {
    #[doc = " Guess the file format."]
    #[doc = ""]
    #[doc = " @param pd        data to be probed"]
    #[doc = " @param is_opened Whether the file is already opened; determines whether"]
    #[doc = "                  demuxers with or without AVFMT_NOFILE are probed."]
    pub fn av_probe_input_format(
        pd: *mut AVProbeData,
        is_opened: ::std::os::raw::c_int,
    ) -> *mut AVInputFormat;
}
extern "C" {
    #[doc = " Guess the file format."]
    #[doc = ""]
    #[doc = " @param pd        data to be probed"]
    #[doc = " @param is_opened Whether the file is already opened; determines whether"]
    #[doc = "                  demuxers with or without AVFMT_NOFILE are probed."]
    #[doc = " @param score_max A probe score larger that this is required to accept a"]
    #[doc = "                  detection, the variable is set to the actual detection"]
    #[doc = "                  score afterwards."]
    #[doc = "                  If the score is <= AVPROBE_SCORE_MAX / 4 it is recommended"]
    #[doc = "                  to retry with a larger probe buffer."]
    pub fn av_probe_input_format2(
        pd: *mut AVProbeData,
        is_opened: ::std::os::raw::c_int,
        score_max: *mut ::std::os::raw::c_int,
    ) -> *mut AVInputFormat;
}
extern "C" {
    #[doc = " Guess the file format."]
    #[doc = ""]
    #[doc = " @param is_opened Whether the file is already opened; determines whether"]
    #[doc = "                  demuxers with or without AVFMT_NOFILE are probed."]
    #[doc = " @param score_ret The score of the best detection."]
    pub fn av_probe_input_format3(
        pd: *mut AVProbeData,
        is_opened: ::std::os::raw::c_int,
        score_ret: *mut ::std::os::raw::c_int,
    ) -> *mut AVInputFormat;
}
extern "C" {
    #[doc = " Probe a bytestream to determine the input format. Each time a probe returns"]
    #[doc = " with a score that is too low, the probe buffer size is increased and another"]
    #[doc = " attempt is made. When the maximum probe size is reached, the input format"]
    #[doc = " with the highest score is returned."]
    #[doc = ""]
    #[doc = " @param pb the bytestream to probe"]
    #[doc = " @param fmt the input format is put here"]
    #[doc = " @param url the url of the stream"]
    #[doc = " @param logctx the log context"]
    #[doc = " @param offset the offset within the bytestream to probe from"]
    #[doc = " @param max_probe_size the maximum probe buffer size (zero for default)"]
    #[doc = " @return the score in case of success, a negative value corresponding to an"]
    #[doc = "         the maximal score is AVPROBE_SCORE_MAX"]
    #[doc = " AVERROR code otherwise"]
    pub fn av_probe_input_buffer2(
        pb: *mut AVIOContext,
        fmt: *mut *mut AVInputFormat,
        url: *const ::std::os::raw::c_char,
        logctx: *mut ::std::os::raw::c_void,
        offset: ::std::os::raw::c_uint,
        max_probe_size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Like av_probe_input_buffer2() but returns 0 on success"]
    pub fn av_probe_input_buffer(
        pb: *mut AVIOContext,
        fmt: *mut *mut AVInputFormat,
        url: *const ::std::os::raw::c_char,
        logctx: *mut ::std::os::raw::c_void,
        offset: ::std::os::raw::c_uint,
        max_probe_size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Open an input stream and read the header. The codecs are not opened."]
    #[doc = " The stream must be closed with avformat_close_input()."]
    #[doc = ""]
    #[doc = " @param ps Pointer to user-supplied AVFormatContext (allocated by avformat_alloc_context)."]
    #[doc = "           May be a pointer to NULL, in which case an AVFormatContext is allocated by this"]
    #[doc = "           function and written into ps."]
    #[doc = "           Note that a user-supplied AVFormatContext will be freed on failure."]
    #[doc = " @param url URL of the stream to open."]
    #[doc = " @param fmt If non-NULL, this parameter forces a specific input format."]
    #[doc = "            Otherwise the format is autodetected."]
    #[doc = " @param options  A dictionary filled with AVFormatContext and demuxer-private options."]
    #[doc = "                 On return this parameter will be destroyed and replaced with a dict containing"]
    #[doc = "                 options that were not found. May be NULL."]
    #[doc = ""]
    #[doc = " @return 0 on success, a negative AVERROR on failure."]
    #[doc = ""]
    #[doc = " @note If you want to use custom IO, preallocate the format context and set its pb field."]
    pub fn avformat_open_input(
        ps: *mut *mut AVFormatContext,
        url: *const ::std::os::raw::c_char,
        fmt: *mut AVInputFormat,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_demuxer_open(ic: *mut AVFormatContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read packets of a media file to get stream information. This"]
    #[doc = " is useful for file formats with no headers such as MPEG. This"]
    #[doc = " function also computes the real framerate in case of MPEG-2 repeat"]
    #[doc = " frame mode."]
    #[doc = " The logical file position is not changed by this function;"]
    #[doc = " examined packets may be buffered for later processing."]
    #[doc = ""]
    #[doc = " @param ic media file handle"]
    #[doc = " @param options  If non-NULL, an ic.nb_streams long array of pointers to"]
    #[doc = "                 dictionaries, where i-th member contains options for"]
    #[doc = "                 codec corresponding to i-th stream."]
    #[doc = "                 On return each dictionary will be filled with options that were not found."]
    #[doc = " @return >=0 if OK, AVERROR_xxx on error"]
    #[doc = ""]
    #[doc = " @note this function isn't guaranteed to open all the codecs, so"]
    #[doc = "       options being non-empty at return is a perfectly normal behavior."]
    #[doc = ""]
    #[doc = " @todo Let the user decide somehow what information is needed so that"]
    #[doc = "       we do not waste time getting stuff the user does not need."]
    pub fn avformat_find_stream_info(
        ic: *mut AVFormatContext,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find the programs which belong to a given stream."]
    #[doc = ""]
    #[doc = " @param ic    media file handle"]
    #[doc = " @param last  the last found program, the search will start after this"]
    #[doc = "              program, or from the beginning if it is NULL"]
    #[doc = " @param s     stream index"]
    #[doc = " @return the next program which belongs to s, NULL if no program is found or"]
    #[doc = "         the last program is not among the programs of ic."]
    pub fn av_find_program_from_stream(
        ic: *mut AVFormatContext,
        last: *mut AVProgram,
        s: ::std::os::raw::c_int,
    ) -> *mut AVProgram;
}
extern "C" {
    pub fn av_program_add_stream_index(
        ac: *mut AVFormatContext,
        progid: ::std::os::raw::c_int,
        idx: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Find the \"best\" stream in the file."]
    #[doc = " The best stream is determined according to various heuristics as the most"]
    #[doc = " likely to be what the user expects."]
    #[doc = " If the decoder parameter is non-NULL, av_find_best_stream will find the"]
    #[doc = " default decoder for the stream's codec; streams for which no decoder can"]
    #[doc = " be found are ignored."]
    #[doc = ""]
    #[doc = " @param ic                media file handle"]
    #[doc = " @param type              stream type: video, audio, subtitles, etc."]
    #[doc = " @param wanted_stream_nb  user-requested stream number,"]
    #[doc = "                          or -1 for automatic selection"]
    #[doc = " @param related_stream    try to find a stream related (eg. in the same"]
    #[doc = "                          program) to this one, or -1 if none"]
    #[doc = " @param decoder_ret       if non-NULL, returns the decoder for the"]
    #[doc = "                          selected stream"]
    #[doc = " @param flags             flags; none are currently defined"]
    #[doc = " @return  the non-negative stream number in case of success,"]
    #[doc = "          AVERROR_STREAM_NOT_FOUND if no stream with the requested type"]
    #[doc = "          could be found,"]
    #[doc = "          AVERROR_DECODER_NOT_FOUND if streams were found but no decoder"]
    #[doc = " @note  If av_find_best_stream returns successfully and decoder_ret is not"]
    #[doc = "        NULL, then *decoder_ret is guaranteed to be set to a valid AVCodec."]
    pub fn av_find_best_stream(
        ic: *mut AVFormatContext,
        type_: AVMediaType,
        wanted_stream_nb: ::std::os::raw::c_int,
        related_stream: ::std::os::raw::c_int,
        decoder_ret: *mut *mut AVCodec,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the next frame of a stream."]
    #[doc = " This function returns what is stored in the file, and does not validate"]
    #[doc = " that what is there are valid frames for the decoder. It will split what is"]
    #[doc = " stored in the file into frames and return one for each call. It will not"]
    #[doc = " omit invalid data between valid frames so as to give the decoder the maximum"]
    #[doc = " information possible for decoding."]
    #[doc = ""]
    #[doc = " If pkt->buf is NULL, then the packet is valid until the next"]
    #[doc = " av_read_frame() or until avformat_close_input(). Otherwise the packet"]
    #[doc = " is valid indefinitely. In both cases the packet must be freed with"]
    #[doc = " av_packet_unref when it is no longer needed. For video, the packet contains"]
    #[doc = " exactly one frame. For audio, it contains an integer number of frames if each"]
    #[doc = " frame has a known fixed size (e.g. PCM or ADPCM data). If the audio frames"]
    #[doc = " have a variable size (e.g. MPEG audio), then it contains one frame."]
    #[doc = ""]
    #[doc = " pkt->pts, pkt->dts and pkt->duration are always set to correct"]
    #[doc = " values in AVStream.time_base units (and guessed if the format cannot"]
    #[doc = " provide them). pkt->pts can be AV_NOPTS_VALUE if the video format"]
    #[doc = " has B-frames, so it is better to rely on pkt->dts if you do not"]
    #[doc = " decompress the payload."]
    #[doc = ""]
    #[doc = " @return 0 if OK, < 0 on error or end of file"]
    pub fn av_read_frame(s: *mut AVFormatContext, pkt: *mut AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Seek to the keyframe at timestamp."]
    #[doc = " 'timestamp' in 'stream_index'."]
    #[doc = ""]
    #[doc = " @param s media file handle"]
    #[doc = " @param stream_index If stream_index is (-1), a default"]
    #[doc = " stream is selected, and timestamp is automatically converted"]
    #[doc = " from AV_TIME_BASE units to the stream specific time_base."]
    #[doc = " @param timestamp Timestamp in AVStream.time_base units"]
    #[doc = "        or, if no stream is specified, in AV_TIME_BASE units."]
    #[doc = " @param flags flags which select direction and seeking mode"]
    #[doc = " @return >= 0 on success"]
    pub fn av_seek_frame(
        s: *mut AVFormatContext,
        stream_index: ::std::os::raw::c_int,
        timestamp: i64,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Seek to timestamp ts."]
    #[doc = " Seeking will be done so that the point from which all active streams"]
    #[doc = " can be presented successfully will be closest to ts and within min/max_ts."]
    #[doc = " Active streams are all streams that have AVStream.discard < AVDISCARD_ALL."]
    #[doc = ""]
    #[doc = " If flags contain AVSEEK_FLAG_BYTE, then all timestamps are in bytes and"]
    #[doc = " are the file position (this may not be supported by all demuxers)."]
    #[doc = " If flags contain AVSEEK_FLAG_FRAME, then all timestamps are in frames"]
    #[doc = " in the stream with stream_index (this may not be supported by all demuxers)."]
    #[doc = " Otherwise all timestamps are in units of the stream selected by stream_index"]
    #[doc = " or if stream_index is -1, in AV_TIME_BASE units."]
    #[doc = " If flags contain AVSEEK_FLAG_ANY, then non-keyframes are treated as"]
    #[doc = " keyframes (this may not be supported by all demuxers)."]
    #[doc = " If flags contain AVSEEK_FLAG_BACKWARD, it is ignored."]
    #[doc = ""]
    #[doc = " @param s media file handle"]
    #[doc = " @param stream_index index of the stream which is used as time base reference"]
    #[doc = " @param min_ts smallest acceptable timestamp"]
    #[doc = " @param ts target timestamp"]
    #[doc = " @param max_ts largest acceptable timestamp"]
    #[doc = " @param flags flags"]
    #[doc = " @return >=0 on success, error code otherwise"]
    #[doc = ""]
    #[doc = " @note This is part of the new seek API which is still under construction."]
    #[doc = "       Thus do not use this yet. It may change at any time, do not expect"]
    #[doc = "       ABI compatibility yet!"]
    pub fn avformat_seek_file(
        s: *mut AVFormatContext,
        stream_index: ::std::os::raw::c_int,
        min_ts: i64,
        ts: i64,
        max_ts: i64,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Discard all internally buffered data. This can be useful when dealing with"]
    #[doc = " discontinuities in the byte stream. Generally works only with formats that"]
    #[doc = " can resync. This includes headerless formats like MPEG-TS/TS but should also"]
    #[doc = " work with NUT, Ogg and in a limited way AVI for example."]
    #[doc = ""]
    #[doc = " The set of streams, the detected duration, stream parameters and codecs do"]
    #[doc = " not change when calling this function. If you want a complete reset, it's"]
    #[doc = " better to open a new AVFormatContext."]
    #[doc = ""]
    #[doc = " This does not flush the AVIOContext (s->pb). If necessary, call"]
    #[doc = " avio_flush(s->pb) before calling this function."]
    #[doc = ""]
    #[doc = " @param s media file handle"]
    #[doc = " @return >=0 on success, error code otherwise"]
    pub fn avformat_flush(s: *mut AVFormatContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start playing a network-based stream (e.g. RTSP stream) at the"]
    #[doc = " current position."]
    pub fn av_read_play(s: *mut AVFormatContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Pause a network-based stream (e.g. RTSP stream)."]
    #[doc = ""]
    #[doc = " Use av_read_play() to resume it."]
    pub fn av_read_pause(s: *mut AVFormatContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close an opened input AVFormatContext. Free it and all its contents"]
    #[doc = " and set *s to NULL."]
    pub fn avformat_close_input(s: *mut *mut AVFormatContext);
}
extern "C" {
    #[doc = " Allocate the stream private data and write the stream header to"]
    #[doc = " an output media file."]
    #[doc = ""]
    #[doc = " @param s Media file handle, must be allocated with avformat_alloc_context()."]
    #[doc = "          Its oformat field must be set to the desired output format;"]
    #[doc = "          Its pb field must be set to an already opened AVIOContext."]
    #[doc = " @param options  An AVDictionary filled with AVFormatContext and muxer-private options."]
    #[doc = "                 On return this parameter will be destroyed and replaced with a dict containing"]
    #[doc = "                 options that were not found. May be NULL."]
    #[doc = ""]
    #[doc = " @return AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec had not already been fully initialized in avformat_init,"]
    #[doc = "         AVSTREAM_INIT_IN_INIT_OUTPUT  on success if the codec had already been fully initialized in avformat_init,"]
    #[doc = "         negative AVERROR on failure."]
    #[doc = ""]
    #[doc = " @see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_init_output."]
    pub fn avformat_write_header(
        s: *mut AVFormatContext,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate the stream private data and initialize the codec, but do not write the header."]
    #[doc = " May optionally be used before avformat_write_header to initialize stream parameters"]
    #[doc = " before actually writing the header."]
    #[doc = " If using this function, do not pass the same options to avformat_write_header."]
    #[doc = ""]
    #[doc = " @param s Media file handle, must be allocated with avformat_alloc_context()."]
    #[doc = "          Its oformat field must be set to the desired output format;"]
    #[doc = "          Its pb field must be set to an already opened AVIOContext."]
    #[doc = " @param options  An AVDictionary filled with AVFormatContext and muxer-private options."]
    #[doc = "                 On return this parameter will be destroyed and replaced with a dict containing"]
    #[doc = "                 options that were not found. May be NULL."]
    #[doc = ""]
    #[doc = " @return AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec requires avformat_write_header to fully initialize,"]
    #[doc = "         AVSTREAM_INIT_IN_INIT_OUTPUT  on success if the codec has been fully initialized,"]
    #[doc = "         negative AVERROR on failure."]
    #[doc = ""]
    #[doc = " @see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_write_header."]
    pub fn avformat_init_output(
        s: *mut AVFormatContext,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write a packet to an output media file."]
    #[doc = ""]
    #[doc = " This function passes the packet directly to the muxer, without any buffering"]
    #[doc = " or reordering. The caller is responsible for correctly interleaving the"]
    #[doc = " packets if the format requires it. Callers that want libavformat to handle"]
    #[doc = " the interleaving should call av_interleaved_write_frame() instead of this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " @param s media file handle"]
    #[doc = " @param pkt The packet containing the data to be written. Note that unlike"]
    #[doc = "            av_interleaved_write_frame(), this function does not take"]
    #[doc = "            ownership of the packet passed to it (though some muxers may make"]
    #[doc = "            an internal reference to the input packet)."]
    #[doc = "            <br>"]
    #[doc = "            This parameter can be NULL (at any time, not just at the end), in"]
    #[doc = "            order to immediately flush data buffered within the muxer, for"]
    #[doc = "            muxers that buffer up data internally before writing it to the"]
    #[doc = "            output."]
    #[doc = "            <br>"]
    #[doc = "            Packet's @ref AVPacket.stream_index \"stream_index\" field must be"]
    #[doc = "            set to the index of the corresponding stream in @ref"]
    #[doc = "            AVFormatContext.streams \"s->streams\"."]
    #[doc = "            <br>"]
    #[doc = "            The timestamps (@ref AVPacket.pts \"pts\", @ref AVPacket.dts \"dts\")"]
    #[doc = "            must be set to correct values in the stream's timebase (unless the"]
    #[doc = "            output format is flagged with the AVFMT_NOTIMESTAMPS flag, then"]
    #[doc = "            they can be set to AV_NOPTS_VALUE)."]
    #[doc = "            The dts for subsequent packets passed to this function must be strictly"]
    #[doc = "            increasing when compared in their respective timebases (unless the"]
    #[doc = "            output format is flagged with the AVFMT_TS_NONSTRICT, then they"]
    #[doc = "            merely have to be nondecreasing).  @ref AVPacket.duration"]
    #[doc = "            \"duration\") should also be set if known."]
    #[doc = " @return < 0 on error, = 0 if OK, 1 if flushed and there is no more data to flush"]
    #[doc = ""]
    #[doc = " @see av_interleaved_write_frame()"]
    pub fn av_write_frame(s: *mut AVFormatContext, pkt: *mut AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write a packet to an output media file ensuring correct interleaving."]
    #[doc = ""]
    #[doc = " This function will buffer the packets internally as needed to make sure the"]
    #[doc = " packets in the output file are properly interleaved in the order of"]
    #[doc = " increasing dts. Callers doing their own interleaving should call"]
    #[doc = " av_write_frame() instead of this function."]
    #[doc = ""]
    #[doc = " Using this function instead of av_write_frame() can give muxers advance"]
    #[doc = " knowledge of future packets, improving e.g. the behaviour of the mp4"]
    #[doc = " muxer for VFR content in fragmenting mode."]
    #[doc = ""]
    #[doc = " @param s media file handle"]
    #[doc = " @param pkt The packet containing the data to be written."]
    #[doc = "            <br>"]
    #[doc = "            If the packet is reference-counted, this function will take"]
    #[doc = "            ownership of this reference and unreference it later when it sees"]
    #[doc = "            fit."]
    #[doc = "            The caller must not access the data through this reference after"]
    #[doc = "            this function returns. If the packet is not reference-counted,"]
    #[doc = "            libavformat will make a copy."]
    #[doc = "            <br>"]
    #[doc = "            This parameter can be NULL (at any time, not just at the end), to"]
    #[doc = "            flush the interleaving queues."]
    #[doc = "            <br>"]
    #[doc = "            Packet's @ref AVPacket.stream_index \"stream_index\" field must be"]
    #[doc = "            set to the index of the corresponding stream in @ref"]
    #[doc = "            AVFormatContext.streams \"s->streams\"."]
    #[doc = "            <br>"]
    #[doc = "            The timestamps (@ref AVPacket.pts \"pts\", @ref AVPacket.dts \"dts\")"]
    #[doc = "            must be set to correct values in the stream's timebase (unless the"]
    #[doc = "            output format is flagged with the AVFMT_NOTIMESTAMPS flag, then"]
    #[doc = "            they can be set to AV_NOPTS_VALUE)."]
    #[doc = "            The dts for subsequent packets in one stream must be strictly"]
    #[doc = "            increasing (unless the output format is flagged with the"]
    #[doc = "            AVFMT_TS_NONSTRICT, then they merely have to be nondecreasing)."]
    #[doc = "            @ref AVPacket.duration \"duration\") should also be set if known."]
    #[doc = ""]
    #[doc = " @return 0 on success, a negative AVERROR on error. Libavformat will always"]
    #[doc = "         take care of freeing the packet, even if this function fails."]
    #[doc = ""]
    #[doc = " @see av_write_frame(), AVFormatContext.max_interleave_delta"]
    pub fn av_interleaved_write_frame(
        s: *mut AVFormatContext,
        pkt: *mut AVPacket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write an uncoded frame to an output media file."]
    #[doc = ""]
    #[doc = " The frame must be correctly interleaved according to the container"]
    #[doc = " specification; if not, then av_interleaved_write_frame() must be used."]
    #[doc = ""]
    #[doc = " See av_interleaved_write_frame() for details."]
    pub fn av_write_uncoded_frame(
        s: *mut AVFormatContext,
        stream_index: ::std::os::raw::c_int,
        frame: *mut AVFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write an uncoded frame to an output media file."]
    #[doc = ""]
    #[doc = " If the muxer supports it, this function makes it possible to write an AVFrame"]
    #[doc = " structure directly, without encoding it into a packet."]
    #[doc = " It is mostly useful for devices and similar special muxers that use raw"]
    #[doc = " video or PCM data and will not serialize it into a byte stream."]
    #[doc = ""]
    #[doc = " To test whether it is possible to use it with a given muxer and stream,"]
    #[doc = " use av_write_uncoded_frame_query()."]
    #[doc = ""]
    #[doc = " The caller gives up ownership of the frame and must not access it"]
    #[doc = " afterwards."]
    #[doc = ""]
    #[doc = " @return  >=0 for success, a negative code on error"]
    pub fn av_interleaved_write_uncoded_frame(
        s: *mut AVFormatContext,
        stream_index: ::std::os::raw::c_int,
        frame: *mut AVFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Test whether a muxer supports uncoded frame."]
    #[doc = ""]
    #[doc = " @return  >=0 if an uncoded frame can be written to that muxer and stream,"]
    #[doc = "          <0 if not"]
    pub fn av_write_uncoded_frame_query(
        s: *mut AVFormatContext,
        stream_index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write the stream trailer to an output media file and free the"]
    #[doc = " file private data."]
    #[doc = ""]
    #[doc = " May only be called after a successful call to avformat_write_header."]
    #[doc = ""]
    #[doc = " @param s media file handle"]
    #[doc = " @return 0 if OK, AVERROR_xxx on error"]
    pub fn av_write_trailer(s: *mut AVFormatContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the output format in the list of registered output formats"]
    #[doc = " which best matches the provided parameters, or return NULL if"]
    #[doc = " there is no match."]
    #[doc = ""]
    #[doc = " @param short_name if non-NULL checks if short_name matches with the"]
    #[doc = " names of the registered formats"]
    #[doc = " @param filename if non-NULL checks if filename terminates with the"]
    #[doc = " extensions of the registered formats"]
    #[doc = " @param mime_type if non-NULL checks if mime_type matches with the"]
    #[doc = " MIME type of the registered formats"]
    pub fn av_guess_format(
        short_name: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        mime_type: *const ::std::os::raw::c_char,
    ) -> *mut AVOutputFormat;
}
extern "C" {
    #[doc = " Guess the codec ID based upon muxer and filename."]
    pub fn av_guess_codec(
        fmt: *mut AVOutputFormat,
        short_name: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        mime_type: *const ::std::os::raw::c_char,
        type_: AVMediaType,
    ) -> AVCodecID;
}
extern "C" {
    #[doc = " Get timing information for the data currently output."]
    #[doc = " The exact meaning of \"currently output\" depends on the format."]
    #[doc = " It is mostly relevant for devices that have an internal buffer and/or"]
    #[doc = " work in real time."]
    #[doc = " @param s          media file handle"]
    #[doc = " @param stream     stream in the media file"]
    #[doc = " @param[out] dts   DTS of the last packet output for the stream, in stream"]
    #[doc = "                   time_base units"]
    #[doc = " @param[out] wall  absolute time when that packet whas output,"]
    #[doc = "                   in microsecond"]
    #[doc = " @return  0 if OK, AVERROR(ENOSYS) if the format does not support it"]
    #[doc = " Note: some formats or devices may not allow to measure dts and wall"]
    #[doc = " atomically."]
    pub fn av_get_output_timestamp(
        s: *mut AVFormatContext,
        stream: ::std::os::raw::c_int,
        dts: *mut i64,
        wall: *mut i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send a nice hexadecimal dump of a buffer to the specified file stream."]
    #[doc = ""]
    #[doc = " @param f The file stream pointer where the dump should be sent to."]
    #[doc = " @param buf buffer"]
    #[doc = " @param size buffer size"]
    #[doc = ""]
    #[doc = " @see av_hex_dump_log, av_pkt_dump2, av_pkt_dump_log2"]
    pub fn av_hex_dump(f: *mut FILE, buf: *const u8, size: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Send a nice hexadecimal dump of a buffer to the log."]
    #[doc = ""]
    #[doc = " @param avcl A pointer to an arbitrary struct of which the first field is a"]
    #[doc = " pointer to an AVClass struct."]
    #[doc = " @param level The importance level of the message, lower values signifying"]
    #[doc = " higher importance."]
    #[doc = " @param buf buffer"]
    #[doc = " @param size buffer size"]
    #[doc = ""]
    #[doc = " @see av_hex_dump, av_pkt_dump2, av_pkt_dump_log2"]
    pub fn av_hex_dump_log(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        buf: *const u8,
        size: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Send a nice dump of a packet to the specified file stream."]
    #[doc = ""]
    #[doc = " @param f The file stream pointer where the dump should be sent to."]
    #[doc = " @param pkt packet to dump"]
    #[doc = " @param dump_payload True if the payload must be displayed, too."]
    #[doc = " @param st AVStream that the packet belongs to"]
    pub fn av_pkt_dump2(
        f: *mut FILE,
        pkt: *const AVPacket,
        dump_payload: ::std::os::raw::c_int,
        st: *const AVStream,
    );
}
extern "C" {
    #[doc = " Send a nice dump of a packet to the log."]
    #[doc = ""]
    #[doc = " @param avcl A pointer to an arbitrary struct of which the first field is a"]
    #[doc = " pointer to an AVClass struct."]
    #[doc = " @param level The importance level of the message, lower values signifying"]
    #[doc = " higher importance."]
    #[doc = " @param pkt packet to dump"]
    #[doc = " @param dump_payload True if the payload must be displayed, too."]
    #[doc = " @param st AVStream that the packet belongs to"]
    pub fn av_pkt_dump_log2(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        pkt: *const AVPacket,
        dump_payload: ::std::os::raw::c_int,
        st: *const AVStream,
    );
}
extern "C" {
    #[doc = " Get the AVCodecID for the given codec tag tag."]
    #[doc = " If no codec id is found returns AV_CODEC_ID_NONE."]
    #[doc = ""]
    #[doc = " @param tags list of supported codec_id-codec_tag pairs, as stored"]
    #[doc = " in AVInputFormat.codec_tag and AVOutputFormat.codec_tag"]
    #[doc = " @param tag  codec tag to match to a codec ID"]
    pub fn av_codec_get_id(
        tags: *const *const AVCodecTag,
        tag: ::std::os::raw::c_uint,
    ) -> AVCodecID;
}
extern "C" {
    #[doc = " Get the codec tag for the given codec id id."]
    #[doc = " If no codec tag is found returns 0."]
    #[doc = ""]
    #[doc = " @param tags list of supported codec_id-codec_tag pairs, as stored"]
    #[doc = " in AVInputFormat.codec_tag and AVOutputFormat.codec_tag"]
    #[doc = " @param id   codec ID to match to a codec tag"]
    pub fn av_codec_get_tag(
        tags: *const *const AVCodecTag,
        id: AVCodecID,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the codec tag for the given codec id."]
    #[doc = ""]
    #[doc = " @param tags list of supported codec_id - codec_tag pairs, as stored"]
    #[doc = " in AVInputFormat.codec_tag and AVOutputFormat.codec_tag"]
    #[doc = " @param id codec id that should be searched for in the list"]
    #[doc = " @param tag A pointer to the found tag"]
    #[doc = " @return 0 if id was not found in tags, > 0 if it was found"]
    pub fn av_codec_get_tag2(
        tags: *const *const AVCodecTag,
        id: AVCodecID,
        tag: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_find_default_stream_index(s: *mut AVFormatContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the index for a specific timestamp."]
    #[doc = ""]
    #[doc = " @param st        stream that the timestamp belongs to"]
    #[doc = " @param timestamp timestamp to retrieve the index for"]
    #[doc = " @param flags if AVSEEK_FLAG_BACKWARD then the returned index will correspond"]
    #[doc = "                 to the timestamp which is <= the requested one, if backward"]
    #[doc = "                 is 0, then it will be >="]
    #[doc = "              if AVSEEK_FLAG_ANY seek to any frame, only keyframes otherwise"]
    #[doc = " @return < 0 if no such timestamp could be found"]
    pub fn av_index_search_timestamp(
        st: *mut AVStream,
        timestamp: i64,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add an index entry into a sorted list. Update the entry if the list"]
    #[doc = " already contains it."]
    #[doc = ""]
    #[doc = " @param timestamp timestamp in the time base of the given stream"]
    pub fn av_add_index_entry(
        st: *mut AVStream,
        pos: i64,
        timestamp: i64,
        size: ::std::os::raw::c_int,
        distance: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Split a URL string into components."]
    #[doc = ""]
    #[doc = " The pointers to buffers for storing individual components may be null,"]
    #[doc = " in order to ignore that component. Buffers for components not found are"]
    #[doc = " set to empty strings. If the port is not found, it is set to a negative"]
    #[doc = " value."]
    #[doc = ""]
    #[doc = " @param proto the buffer for the protocol"]
    #[doc = " @param proto_size the size of the proto buffer"]
    #[doc = " @param authorization the buffer for the authorization"]
    #[doc = " @param authorization_size the size of the authorization buffer"]
    #[doc = " @param hostname the buffer for the host name"]
    #[doc = " @param hostname_size the size of the hostname buffer"]
    #[doc = " @param port_ptr a pointer to store the port number in"]
    #[doc = " @param path the buffer for the path"]
    #[doc = " @param path_size the size of the path buffer"]
    #[doc = " @param url the URL to split"]
    pub fn av_url_split(
        proto: *mut ::std::os::raw::c_char,
        proto_size: ::std::os::raw::c_int,
        authorization: *mut ::std::os::raw::c_char,
        authorization_size: ::std::os::raw::c_int,
        hostname: *mut ::std::os::raw::c_char,
        hostname_size: ::std::os::raw::c_int,
        port_ptr: *mut ::std::os::raw::c_int,
        path: *mut ::std::os::raw::c_char,
        path_size: ::std::os::raw::c_int,
        url: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Print detailed information about the input or output format, such as"]
    #[doc = " duration, bitrate, streams, container, programs, metadata, side data,"]
    #[doc = " codec and time base."]
    #[doc = ""]
    #[doc = " @param ic        the context to analyze"]
    #[doc = " @param index     index of the stream to dump information about"]
    #[doc = " @param url       the URL to print, such as source or destination file"]
    #[doc = " @param is_output Select whether the specified context is an input(0) or output(1)"]
    pub fn av_dump_format(
        ic: *mut AVFormatContext,
        index: ::std::os::raw::c_int,
        url: *const ::std::os::raw::c_char,
        is_output: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Return in 'buf' the path with '%d' replaced by a number."]
    #[doc = ""]
    #[doc = " Also handles the '%0nd' format where 'n' is the total number"]
    #[doc = " of digits and '%%'."]
    #[doc = ""]
    #[doc = " @param buf destination buffer"]
    #[doc = " @param buf_size destination buffer size"]
    #[doc = " @param path numbered sequence string"]
    #[doc = " @param number frame number"]
    #[doc = " @param flags AV_FRAME_FILENAME_FLAGS_*"]
    #[doc = " @return 0 if OK, -1 on format error"]
    pub fn av_get_frame_filename2(
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_int,
        path: *const ::std::os::raw::c_char,
        number: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_get_frame_filename(
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_int,
        path: *const ::std::os::raw::c_char,
        number: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check whether filename actually is a numbered sequence generator."]
    #[doc = ""]
    #[doc = " @param filename possible numbered sequence string"]
    #[doc = " @return 1 if a valid numbered sequence string, 0 otherwise"]
    pub fn av_filename_number_test(
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Generate an SDP for an RTP session."]
    #[doc = ""]
    #[doc = " Note, this overwrites the id values of AVStreams in the muxer contexts"]
    #[doc = " for getting unique dynamic payload types."]
    #[doc = ""]
    #[doc = " @param ac array of AVFormatContexts describing the RTP streams. If the"]
    #[doc = "           array is composed by only one context, such context can contain"]
    #[doc = "           multiple AVStreams (one AVStream per RTP stream). Otherwise,"]
    #[doc = "           all the contexts in the array (an AVCodecContext per RTP stream)"]
    #[doc = "           must contain only one AVStream."]
    #[doc = " @param n_files number of AVCodecContexts contained in ac"]
    #[doc = " @param buf buffer where the SDP will be stored (must be allocated by"]
    #[doc = "            the caller)"]
    #[doc = " @param size the size of the buffer"]
    #[doc = " @return 0 if OK, AVERROR_xxx on error"]
    pub fn av_sdp_create(
        ac: *mut *mut AVFormatContext,
        n_files: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a positive value if the given filename has one of the given"]
    #[doc = " extensions, 0 otherwise."]
    #[doc = ""]
    #[doc = " @param filename   file name to check against the given extensions"]
    #[doc = " @param extensions a comma-separated list of filename extensions"]
    pub fn av_match_ext(
        filename: *const ::std::os::raw::c_char,
        extensions: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Test if the given container can store a codec."]
    #[doc = ""]
    #[doc = " @param ofmt           container to check for compatibility"]
    #[doc = " @param codec_id       codec to potentially store in container"]
    #[doc = " @param std_compliance standards compliance level, one of FF_COMPLIANCE_*"]
    #[doc = ""]
    #[doc = " @return 1 if codec with ID codec_id can be stored in ofmt, 0 if it cannot."]
    #[doc = "         A negative number if this information is not available."]
    pub fn avformat_query_codec(
        ofmt: *const AVOutputFormat,
        codec_id: AVCodecID,
        std_compliance: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @defgroup riff_fourcc RIFF FourCCs"]
    #[doc = " @{"]
    #[doc = " Get the tables mapping RIFF FourCCs to libavcodec AVCodecIDs. The tables are"]
    #[doc = " meant to be passed to av_codec_get_id()/av_codec_get_tag() as in the"]
    #[doc = " following code:"]
    #[doc = " @code"]
    #[doc = " uint32_t tag = MKTAG('H', '2', '6', '4');"]
    #[doc = " const struct AVCodecTag *table[] = { avformat_get_riff_video_tags(), 0 };"]
    #[doc = " enum AVCodecID id = av_codec_get_id(table, tag);"]
    #[doc = " @endcode"]
    #[doc = " @return the table mapping RIFF FourCCs for video to libavcodec AVCodecID."]
    pub fn avformat_get_riff_video_tags() -> *const AVCodecTag;
}
extern "C" {
    #[doc = " @return the table mapping RIFF FourCCs for audio to AVCodecID."]
    pub fn avformat_get_riff_audio_tags() -> *const AVCodecTag;
}
extern "C" {
    #[doc = " @return the table mapping MOV FourCCs for video to libavcodec AVCodecID."]
    pub fn avformat_get_mov_video_tags() -> *const AVCodecTag;
}
extern "C" {
    #[doc = " @return the table mapping MOV FourCCs for audio to AVCodecID."]
    pub fn avformat_get_mov_audio_tags() -> *const AVCodecTag;
}
extern "C" {
    #[doc = " Guess the sample aspect ratio of a frame, based on both the stream and the"]
    #[doc = " frame aspect ratio."]
    #[doc = ""]
    #[doc = " Since the frame aspect ratio is set by the codec but the stream aspect ratio"]
    #[doc = " is set by the demuxer, these two may not be equal. This function tries to"]
    #[doc = " return the value that you should use if you would like to display the frame."]
    #[doc = ""]
    #[doc = " Basic logic is to use the stream aspect ratio if it is set to something sane"]
    #[doc = " otherwise use the frame aspect ratio. This way a container setting, which is"]
    #[doc = " usually easy to modify can override the coded value in the frames."]
    #[doc = ""]
    #[doc = " @param format the format context which the stream is part of"]
    #[doc = " @param stream the stream which the frame is part of"]
    #[doc = " @param frame the frame with the aspect ratio to be determined"]
    #[doc = " @return the guessed (valid) sample_aspect_ratio, 0/1 if no idea"]
    pub fn av_guess_sample_aspect_ratio(
        format: *mut AVFormatContext,
        stream: *mut AVStream,
        frame: *mut AVFrame,
    ) -> AVRational;
}
extern "C" {
    #[doc = " Guess the frame rate, based on both the container and codec information."]
    #[doc = ""]
    #[doc = " @param ctx the format context which the stream is part of"]
    #[doc = " @param stream the stream which the frame is part of"]
    #[doc = " @param frame the frame for which the frame rate should be determined, may be NULL"]
    #[doc = " @return the guessed (valid) frame rate, 0/1 if no idea"]
    pub fn av_guess_frame_rate(
        ctx: *mut AVFormatContext,
        stream: *mut AVStream,
        frame: *mut AVFrame,
    ) -> AVRational;
}
extern "C" {
    #[doc = " Check if the stream st contained in s is matched by the stream specifier"]
    #[doc = " spec."]
    #[doc = ""]
    #[doc = " See the \"stream specifiers\" chapter in the documentation for the syntax"]
    #[doc = " of spec."]
    #[doc = ""]
    #[doc = " @return  >0 if st is matched by spec;"]
    #[doc = "          0  if st is not matched by spec;"]
    #[doc = "          AVERROR code if spec is invalid"]
    #[doc = ""]
    #[doc = " @note  A stream specifier can match several streams in the format."]
    pub fn avformat_match_stream_specifier(
        s: *mut AVFormatContext,
        st: *mut AVStream,
        spec: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avformat_queue_attached_pictures(s: *mut AVFormatContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_apply_bitstream_filters(
        codec: *mut AVCodecContext,
        pkt: *mut AVPacket,
        bsfc: *mut AVBitStreamFilterContext,
    ) -> ::std::os::raw::c_int;
}
pub const AVTimebaseSource_AVFMT_TBCF_AUTO: AVTimebaseSource = -1;
pub const AVTimebaseSource_AVFMT_TBCF_DECODER: AVTimebaseSource = 0;
pub const AVTimebaseSource_AVFMT_TBCF_DEMUXER: AVTimebaseSource = 1;
pub const AVTimebaseSource_AVFMT_TBCF_R_FRAMERATE: AVTimebaseSource = 2;
pub type AVTimebaseSource = i32;
extern "C" {
    #[doc = " Transfer internal timing information from one stream to another."]
    #[doc = ""]
    #[doc = " This function is useful when doing stream copy."]
    #[doc = ""]
    #[doc = " @param ofmt     target output format for ost"]
    #[doc = " @param ost      output stream which needs timings copy and adjustments"]
    #[doc = " @param ist      reference input stream to copy timings from"]
    #[doc = " @param copy_tb  define from where the stream codec timebase needs to be imported"]
    pub fn avformat_transfer_internal_stream_timing_info(
        ofmt: *const AVOutputFormat,
        ost: *mut AVStream,
        ist: *const AVStream,
        copy_tb: AVTimebaseSource,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the internal codec timebase from a stream."]
    #[doc = ""]
    #[doc = " @param st  input stream to extract the timebase from"]
    pub fn av_stream_get_codec_timebase(st: *const AVStream) -> AVRational;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVOption {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct URLContext {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FFFrac {
    pub _address: u8,
}
